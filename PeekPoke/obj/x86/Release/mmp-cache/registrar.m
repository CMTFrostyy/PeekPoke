#include <xamarin/xamarin.h>
#include "registrar.h"
extern "C" {
static id native_to_managed_trampoline_1 (id self, SEL _cmd, MonoMethod **managed_method_ptr, bool* call_super, uint32_t token_ref)
{
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static id native_to_managed_trampoline_2 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MLModelDescription * p0, NSDictionary <NSString *, NSObject *>* p1, NSError ** p2, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *mobj2 = NULL;
	void * handle2 = NULL;
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = (int *) &mobj2;

	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

	if (mobj2 != NULL)
	handle2 = xamarin_get_nsobject_handle (mobj2);
	if (p2 != NULL)
		*p2 = (id) handle2;

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static BOOL native_to_managed_trampoline_3 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static id native_to_managed_trampoline_4 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCoder * p0, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static void native_to_managed_trampoline_5 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_6 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_7 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_8 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_9 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_10 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenuItem * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_11 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_12 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, NSInteger p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_13 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNotification * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_14 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_15 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTimer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_16 (id self, SEL _cmd, MonoMethod **managed_method_ptr, DOMEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_17 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrame * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_18 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_19 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, JSContext * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_20 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_21 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSImage * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_22 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_23 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURL * p1, double p2, NSDate * p3, WebFrame * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_24 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSWindow * native_to_managed_trampoline_25 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebDownload * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_26 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLAuthenticationChallenge * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_27 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSError * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_28 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_29 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_30 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_31 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSInteger p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_32 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLResponse * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSURLRequest * native_to_managed_trampoline_33 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLRequest * p2, NSURLResponse * p3, WebDataSource * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSURLRequest * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_34 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_35 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static WebView * native_to_managed_trampoline_36 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	WebView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_37 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGPoint p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_38 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_39 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_40 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_41 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id<NSDraggingInfo> p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSResponder * native_to_managed_trampoline_42 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSResponder * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_43 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_44 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_45 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSResponder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_46 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_47 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrameView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_48 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_49 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_50 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_51 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_52 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, WebFrame * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_53 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "WebKit.WebOpenPanelResultListenerWrapper, Xamarin.Mac", "WebKit.IWebOpenPanelResultListener, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_54 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_55 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, SEL p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_56 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_57 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, id<NSDraggingInfo> p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_58 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_59 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_60 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_61 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, NSString * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = p3 ? mono_string_new (mono_domain_get (), [p3 UTF8String]) : NULL;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_62 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_63 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_64 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKProductsRequest * p0, SKProductsResponse * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_65 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKPhysicsContact * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_66 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSError * p1, uint32_t token_ref)
{
	void * a0 = p0;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_67 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SCNPhysicsWorld * p0, SCNPhysicsContact * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static Class native_to_managed_trampoline_68 (id self, SEL _cmd, MonoMethod **managed_method_ptr, Class p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_class (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_69 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFSelection * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static Class native_to_managed_trampoline_70 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? mono_string_new (mono_domain_get (), [p0 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_71 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, PDFActionRemoteGoTo * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_72 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSString * native_to_managed_trampoline_73 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_74 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, CGFloat p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_75 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_76 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_77 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSViewController * native_to_managed_trampoline_78 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_79 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_80 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_81 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_82 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_83 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_84 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, NSUInteger p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	unsigned long long nativeEnum3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;
	arg_ptrs [3] = &nativeEnum3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKClusterAnnotation * native_to_managed_trampoline_85 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKClusterAnnotation * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				MonoType *type1;
				type1 = xamarin_get_parameter_type (managed_method, 1);
				mobj1 = xamarin_get_inative_object_dynamic (nobj, false, mono_type_get_object (mono_domain_get (), mono_class_get_type (e_class)), &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_86 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_87 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_88 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_89 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_90 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_91 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKUserLocation * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKAnnotationView * native_to_managed_trampoline_92 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKAnnotationView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "MapKit.MKAnnotationWrapper, Xamarin.Mac", "MapKit.IMKAnnotation, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static MKOverlayRenderer * native_to_managed_trampoline_93 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKOverlayRenderer * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "MapKit.MKOverlayWrapper, Xamarin.Mac", "MapKit.IMKOverlay, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_94 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_95 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_96 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKDeviceBrowserView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_97 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_98 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_99 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, NSEvent * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_100 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_101 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKSaveOptions * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_102 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_103 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSURL * p1, NSData * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_104 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSURL * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_105 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKGameCenterViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_106 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKAchievementViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_107 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKChallenge * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_108 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKChallenge * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_109 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKFriendRequestComposeViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_110 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKLeaderboardViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_111 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_112 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_113 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, GKPlayer * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_114 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_115 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_116 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_117 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_118 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_119 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_120 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_121 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_122 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKMatch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_123 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_124 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_125 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_126 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_127 (id self, SEL _cmd, MonoMethod **managed_method_ptr, EAAccessory * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_128 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, unsigned int p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_129 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_130 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSInteger p1, CLRegion * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum1 = p1;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_131 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_132 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_133 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_134 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_135 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_136 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLLocation * p1, CLLocation * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_137 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_138 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_139 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSDictionary * p2, NSNumber * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_140 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_141 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_142 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_143 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_144 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_145 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBCharacteristic * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_146 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_147 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_148 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_149 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSNumber * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_150 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBDescriptor * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_151 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_152 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBCentral * p1, CBCharacteristic * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_153 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_154 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, unsigned short p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_155 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBATTRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_156 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_157 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_158 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_159 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_160 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_161 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_162 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_163 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_164 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_165 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_166 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_167 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_168 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSMenu * native_to_managed_trampoline_169 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_170 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_171 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_172 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_173 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		arg_ptrs [2] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x12C5362 /* AppKit.ContinueUserActivityRestorationHandler ObjCRuntime.Trampolines/NIDContinueUserActivityRestorationHandler::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_174 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_175 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_176 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_177 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_178 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_179 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_180 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_181 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDictionary * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_182 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, NSDictionary * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_183 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_184 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_185 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSArray * p0, NSArray * p1, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (p0) {
		NSArray *arr = (NSArray *) p0;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 0);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [0] = marr;
	} else {
		arg_ptrs [0] = NULL;
	}
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_186 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_187 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_188 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, CKShareMetadata * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSError * native_to_managed_trampoline_189 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSError * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_190 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_191 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SEL p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_selector (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_192 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSClickGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_193 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_194 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_195 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, SEL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? xamarin_get_selector (p2, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_196 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_197 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, NSArray * p2, NSRange p3, NSInteger* p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	arg_ptrs [3] = &p3;
	arg_ptrs [4] = p4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_198 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSArray * p2, NSRange p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_199 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_200 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_201 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSText * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_202 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDatePickerCell * p0, NSDate ** p1, double p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *mobj1 = NULL;
	NSObject *nsobj1 = NULL;
	MonoType *paramtype1 = NULL;
	void * handle1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = *(NSObject **) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr (nsobj1, false, paramtype1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = (int *) &mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj1 != NULL)
	handle1 = xamarin_get_nsobject_handle (mobj1);
	if (p1 != NULL)
		*p1 = (id) handle1;

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_203 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDocument * p0, BOOL p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_204 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_205 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_206 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_207 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSGestureRecognizer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_208 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_209 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSTouch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_210 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_211 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_212 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_213 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSImage * native_to_managed_trampoline_214 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_215 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMagnificationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_216 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_217 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_218 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_219 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSViewController * native_to_managed_trampoline_220 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_221 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSViewController * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_222 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPanGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_223 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSOpenPanel * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_224 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_225 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPressGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_226 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRotationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_227 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSInteger p1, NSObject * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	unsigned long long nativeEnum3 = p3;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &nativeEnum3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_228 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_229 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_230 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSObject * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_231 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, NSString * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_232 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_233 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_234 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_235 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_236 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_237 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_238 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, NSError ** p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *mobj2 = NULL;
	void * handle2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = (int *) &mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj2 != NULL)
	handle2 = xamarin_get_nsobject_handle (mobj2);
	if (p2 != NULL)
		*p2 = (id) handle2;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_239 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_240 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSearchField * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSView * native_to_managed_trampoline_241 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, CGRect* p1, NSUInteger* p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1;
	arg_ptrs [2] = p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_242 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_243 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_244 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "AppKit.NSPasteboardWritingWrapper, Xamarin.Mac", "AppKit.INSPasteboardWriting, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSWindow * native_to_managed_trampoline_245 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSImage * native_to_managed_trampoline_246 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "AppKit.NSPasteboardWritingWrapper, Xamarin.Mac", "AppKit.INSPasteboardWriting, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static id native_to_managed_trampoline_247 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_248 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_249 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_250 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSound * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTableRowView * native_to_managed_trampoline_251 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTableRowView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_252 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableRowView * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_253 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSCell * native_to_managed_trampoline_254 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSCell * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_255 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, NSString * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = p3 ? mono_string_new (mono_domain_get (), [p3 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_256 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_257 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSIndexSet * native_to_managed_trampoline_258 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSIndexSet * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSIndexSet * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_259 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, CGRect* p2, NSTableColumn * p3, NSInteger p4, CGPoint p5, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [6];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = &p4;
	arg_ptrs [5] = &p5;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSView * native_to_managed_trampoline_260 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_261 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_262 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_263 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_264 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_265 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_266 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_267 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_268 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSEvent * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_269 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSObject * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_270 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_271 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_272 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_273 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSText * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_274 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextStorage * p0, NSUInteger p1, NSRange p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_275 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_276 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, unsigned long long p2, NSDictionary * p3, NSArray * p4, NSOrthography * p5, NSInteger p6, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj5 = NULL;
	MonoObject *mobj5 = NULL;
	int32_t created5 = false;
	MonoType *paramtype5 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [7];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		NSArray *arr = (NSArray *) p4;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 4);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj4 = NULL;
			if (nobj) {
				mobj4 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj4);
		}
		arg_ptrs [4] = marr;
	} else {
		arg_ptrs [4] = NULL;
	}
	nsobj5 = (NSObject *) p5;
	if (nsobj5) {
		paramtype5 = xamarin_get_parameter_type (managed_method, 5);
		mobj5 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj5, false, paramtype5, &created5, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [5] = mobj5;
	arg_ptrs [6] = &p6;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_277 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, SEL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_278 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSEvent * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_279 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_280 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, NSInteger* p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_281 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_282 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_283 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_284 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSMenu * native_to_managed_trampoline_285 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSMenu * p1, NSEvent * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_286 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_287 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_288 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSDictionary * p1, NSDictionary * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_289 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_290 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSInteger p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_291 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSRange native_to_managed_trampoline_292 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSRange res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSRange *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_293 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_294 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSDictionary * p2, unsigned long long p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_295 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_296 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, NSPasteboard * p3, NSString * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = p4 ? mono_string_new (mono_domain_get (), [p4 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_297 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSToolbarItem * native_to_managed_trampoline_298 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSToolbarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSTouchBarItem * native_to_managed_trampoline_299 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTouchBar * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTouchBarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_300 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_301 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_302 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_303 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSEvent * p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_304 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_305 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_306 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, double p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_307 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSWindow * p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_308 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_309 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, CGSize p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_310 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_311 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_312 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_313 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_314 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_315 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_316 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSUInteger p1, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_317 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void ** p0, NSUInteger* p1, uint32_t token_ref)
{
	void ** a0 = 0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	*p0 = a0;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_318 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_319 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_320 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, void * p1, void * p2, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	void * a1 = p1;
	void * a2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &a1;
	arg_ptrs [2] = &a2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_321 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRunLoop * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_322 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCache * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_323 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_324 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_325 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_326 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static Class native_to_managed_trampoline_327 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSString * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_328 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_329 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_330 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_331 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSMetadataItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_332 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSString * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_333 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_334 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSInputStream * p1, NSOutputStream * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_335 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_336 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_337 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_338 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSNetService * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_339 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_340 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_341 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, NULL, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_342 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, NSObject * p1, NSDictionary * p2, void * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	void * a3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &a3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_343 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSStream * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_344 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_345 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_346 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1350962 /* System.Action`1<Foundation.NSUrlSessionResponseDisposition> ObjCRuntime.Trampolines/NIDActionArity1V35::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_347 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSData * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_348 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_349 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSCachedURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1346962 /* System.Action`1<Foundation.NSCachedUrlResponse> ObjCRuntime.Trampolines/NIDActionArity1V32::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_350 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSHTTPURLResponse * p2, NSURLRequest * p3, id p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		arg_ptrs [4] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x134FF62 /* System.Action`1<Foundation.NSUrlRequest> ObjCRuntime.Trampolines/NIDActionArity1V37::Create(System.IntPtr) */ , 4, p4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [4] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_351 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSURLAuthenticationChallenge * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1388362 /* System.Action`2<Foundation.NSUrlSessionAuthChallengeDisposition,Foundation.NSUrlCredential> ObjCRuntime.Trampolines/NIDActionArity2V37::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTextField * native_to_managed_trampoline_352 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTextField * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_353 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSStepper * native_to_managed_trampoline_354 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSStepper * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_355 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSStepper * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTextFieldCell * native_to_managed_trampoline_356 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTextFieldCell * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_357 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextFieldCell * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSButton * native_to_managed_trampoline_358 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSButton * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_359 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSButton * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSComboBox * native_to_managed_trampoline_360 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSComboBox * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_361 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSComboBox * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTextView * native_to_managed_trampoline_362 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTextView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_363 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSScrollView * native_to_managed_trampoline_364 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSScrollView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_365 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSScrollView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSView * native_to_managed_trampoline_366 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_367 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSProgressIndicator * native_to_managed_trampoline_368 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSProgressIndicator * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_369 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSProgressIndicator * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTableView * native_to_managed_trampoline_370 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTableView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_371 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTableColumn * native_to_managed_trampoline_372 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTableColumn * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_373 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableColumn * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSClipView * native_to_managed_trampoline_374 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSClipView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_375 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSClipView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSCollectionView * native_to_managed_trampoline_376 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSCollectionView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_377 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCollectionView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_378 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_379 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}




#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation VSAccountManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCF062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UNUserNotificationCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE4662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation DOMEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFF862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation DOMEventTarget {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x100462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_DomNodeFilter {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x141762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebDocumentRepresentation {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14EA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14FB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebFrameLoadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x152A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_WebOpenPanelResultListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x157162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_WebPolicyDecisionListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x157B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebPolicyDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x158662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebResourceLoadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x15EC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebUIDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x163162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKNavigationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x18A062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKScriptMessageHandler {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x18E362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKUIDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x18FF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPaymentTransactionObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1C7F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1CEF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKProductsRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1CBA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1F9562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x207D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x229262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SBApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x27C962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNActionable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x283B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAnimatable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x285E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAvoidOccluderConstraintDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x28FF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNBoundingVolume {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x291462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNCameraControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x29F362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNNodeRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2D2962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2E6562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNProgramDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2F7B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneExportDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x304162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x30AA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x30E562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNShadable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x312962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNTechniqueSupport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x319E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x345262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewPanelDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x348062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewPanelDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x348962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHLivePhotoViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x385962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHProjectTypeDescriptionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x38F462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHPhotoLibraryChangeObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x3A2E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFDocumentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4E7562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4F9362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetListViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4FE662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetProviding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4FF662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetSearchViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x502762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NWTCPConnectionAuthenticationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x52AF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCAdvertiserAssistantDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x555B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCBrowserViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x557C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceAdvertiserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x559662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x55B062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x55E962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MDLLightProbeIrradianceDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x576C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MPSCNNConvolutionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x5C3C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x635262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__Metal_MTLCaptureScope {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x643A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTLDrawable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x655B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKAnnotation {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6ACF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKLocalSearchCompleterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6B9262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKMapViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6CC462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKOverlay {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6CEB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__JavaScriptCore_JSExport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6E6862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKCameraDeviceViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x726062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKDeviceBrowserViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x728562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKFilterCustomUIProvider {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x72AA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x72E062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x72F562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x730762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageEditPanelDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x739B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKSaveOptionsDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x741962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKScannerDeviceViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x745B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKSlideshowDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x748962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GLKNamedEffect {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x78B662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAgentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x797362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAchievementViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7CD662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D1762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D2662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengesViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D3A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKFriendRequestComposeViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D6A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKGameCenterControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D7162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKInviteEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7DCF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLeaderboardViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E2362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLocalPlayerListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E5962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7EC662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F3262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSavedGameListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F8062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FD262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FEA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FFA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x807862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EAAccessoryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x821062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CWEventDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x837762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CSSearchableIndexDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x899F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__CoreML_MLCustomModel {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C2B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithModelDescription:(MLModelDescription *)p0 parameterDictionary:(NSDictionary <NSString *, NSObject *>*)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, p1, p2, &call_super, 0x8C2E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, MLModelDescription *, NSDictionary <NSString *, NSObject *>*, NSError **)) objc_msgSendSuper) (&super, @selector (initWithModelDescription:parameterDictionary:error:), p0, p1, p2);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CLLocationManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x91E162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation CoreImage_CIAccordionFoldTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x922762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x922A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICompositingFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAdditionCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x923562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x923862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x923F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineClamp {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x923962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x923C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x924462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTransform {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x924862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x924C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaHistogram {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x925262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIReductionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A5862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x925962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x925C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximumAlpha {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x925E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimumAlpha {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMax {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMaxRed {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x927162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIImageGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x97B262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAttributedTextImageGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x927462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x927762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x936862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAztecCodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x928662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x928962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarcodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x929862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x929B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITransitionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BCF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarsSwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x929E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92A162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBicubicScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92A862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92AB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92B662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92F162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92F462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithAlphaMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92E962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92EC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithBlueMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92ED62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92F062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithRedMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92F862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92FB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92FC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92FF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x985462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBokehBlur {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x930462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x930762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBoxBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x930E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x931162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDistortionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x953162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x931462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x931762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortionLinear {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x931A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x931D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICameraCalibrationLensCorrection {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x932262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x932562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICheckerboardGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x932A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x932D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircleSplashDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x933862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x933B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ABE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x933C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x933F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularWrap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x934062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x934362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x934A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x934D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICmykHalftone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x935062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x935362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICode128BarcodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x936062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x936362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x939262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x939562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x939662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x939962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x939A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x939D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorControls {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93A262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93A562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCrossPolynomial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93AC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93AF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCube {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93B762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93BA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubesMixedWithMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93C062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93C362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubeWithColorSpace {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93CE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93D162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCurves {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93D462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93D762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93DE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93E162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorInvert {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93E262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93E562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93EC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93EF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMatrix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93F262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93F562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMonochrome {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x940062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x940362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPolynomial {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x940862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x940B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPosterize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x940E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColumnAverage {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x941462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIComicEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x941862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConstantColorGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x942262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x942562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionCore {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x948162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution3X3 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x946B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x946E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution5X5 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x946F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution7X7 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x947362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Horizontal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x947762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Vertical {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x947B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICopyMachineTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x948762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x948A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICoreMLModelFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x949562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x949862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x949B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x949E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrystallize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94A162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94A462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDarkenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94A962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94AC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthBlurEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94B962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94BC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthDisparityConverter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94D362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthOfField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94D562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94D862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthToDisparity {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94E562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94E862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDifferenceBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x950962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x950C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDiscBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x950D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x951062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisintegrateWithMaskTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x951362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x951662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisparityToDepth {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x951F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x952262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisplacementDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x952362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x952662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDissolveTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x952B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x952E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDither {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x953762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x953A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDivideBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x953D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x954062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDotScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x954162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x954462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDroste {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x954762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x954A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgePreserveUpsampleFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x955762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x955A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdges {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x956162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x956462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgeWork {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x956762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x956A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITileFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BAB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEightfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x956D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExclusionBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x957162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExposureAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x957562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFaceBalance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFalseColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x959262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x959562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFlashTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x966362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x966662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x967562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x967862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldRotatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x967B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x967E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldTranslatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x967F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x968262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGammaAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x968562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x968862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x968B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x968E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x969162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x969462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x969D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96A062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassLozenge {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96A762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96AA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlideReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96B362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96B662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96B762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96BA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGuidedFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96BF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96C262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHardLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96C962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96CC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHatchedScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96CD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96D062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHeightFieldFromMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96D362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96D662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHexagonalPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96D962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96DC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHighlightShadowAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96E162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96E462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHistogramDisplayFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96EB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96EE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHoleDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96F562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96F862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96F962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96FC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96FF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x970262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueSaturationValueGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x970362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x970662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end


@implementation CoreImage_CIKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x980D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x981062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILabDeltaE {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x982262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x982562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILanczosScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x982862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x982B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILenticularHaloGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x983062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x983362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x984462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x984762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightTunnel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x984862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x984B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x985862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x985B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x985C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x985F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x986062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x986362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearToSRGBToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x986D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x987062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineOverlay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x987162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x987462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x987F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x988262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILuminosityBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x988562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x988862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskedVariableBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x988962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x988C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskToAlpha {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x988F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMedianFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMeshGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98A262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98A962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98AC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98AD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98B062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98B162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98B462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIModTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98B962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98BC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphology {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98C762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyGradient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98CB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98CE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMaximum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98CF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98D262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMinimum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98D362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98D662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMotionBlur {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98D762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98DA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98DD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98E062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98E162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98E462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartStretched {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98E562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98E862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartTiled {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98EF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98F262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINoiseReduction {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98FB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98FE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOpTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x990362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x990662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOverlayBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x990962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x990C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x990D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x991062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlWithShadowTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x991B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x991E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIParallelogramTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x993162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x993462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPdf417BarcodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x993762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x993A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x996D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x997062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveCorrection {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x995D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x996062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTile {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x996162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x996462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransformWithExtent {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x997A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x997D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectChrome {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x998462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectFade {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x998862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectInstant {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x998C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectMono {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectNoir {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectProcess {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTonal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTransfer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99A062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99A362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinchDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99A462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99A762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99AA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99AD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99AE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99B162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPointillize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99BE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99C162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIQRCodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99E162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99E462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRadialGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99E762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99EA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRandomGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99F562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99F862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRippleTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A8262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A8562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRowAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A9062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A9362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaliencyMapFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A9662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A9962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISampleNearest {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A9A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A9D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaturationBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AB462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AB762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AB862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ABB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISepiaTone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AC662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AC962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIShadedMaterial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9ACC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ACF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISharpenLuminance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AD462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AD762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9ADA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ADD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldRotatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9ADE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AE162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISmoothLinearGradient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AE262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AE562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISoftLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AEE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AF162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceAtopCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AF262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AF562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceInCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AF662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AF962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOutCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AFA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AFD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOverCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AFE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B0162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B0262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B0562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotLight {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B1E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B2162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISRGBToneCurveToLinear {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B2C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B2F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStarShineGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B3062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B3362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStraightenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B4462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B4762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStretchCrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B4A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B4D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStripesGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B5462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B5762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISubtractBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B6262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B6562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISunbeamsGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B6662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B6962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B7A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B7D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITemperatureAndTint {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B8862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B8B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITextImageGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B9B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B9E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIThermal {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BA562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BA862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BB362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BB662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITorusLensDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BC162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BC462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BD562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BD862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BE162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BE462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwelvefoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BE562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BE862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwirlDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BE962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BEC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIUnsharpMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BF362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BF662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVibrance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C1F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C2262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignette {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C2562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C2862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignetteEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C2D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C3062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVortexDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C3962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C3C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIWhitePointAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C4562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C4862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIXRay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C4B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C4E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIZoomBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C4F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C5262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICMYKHalftone {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C8562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICmykHalftone class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBCentralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xA9E462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAAAC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAB2062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAAnimationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAC0E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CALayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAE1762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAMediaTiming {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAE4262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CNContactPickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAFE962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CKRecordValue {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB4D862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB5EA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAssetResourceLoaderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB72262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAsynchronousKeyValueLoading {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB83762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudio3DMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB86362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioPlayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBA3C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioRecorderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBAA062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioStereoMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBADD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureAudioDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBBFE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureFileOutputDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBCB262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureFileOutputRecordingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBCBE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureVideoDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBD5D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVContentKeySessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBDFA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC35662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemLegibleOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC31662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataCollectorPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC32B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC33E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPullDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC34F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVVideoCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC4E362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation AVFoundation_AVCaptureDataOutputSynchronizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@implementation AVFoundation_AVCaptureDataOutputSynchronizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC58162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_InternalAVAudioPlayerDelegate : NSObject<AVAudioPlayerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1;
	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioPlayerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, p0, p1, 0xC58C62);
	}

	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, p1, 0xC58D62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC58B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_InternalAVAudioRecorderDelegate : NSObject<AVAudioRecorderDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1;
	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioRecorderDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_7 (self, _cmd, &managed_method, p0, p1, 0xC58F62);
	}

	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, p1, 0xC59062);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC58E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAccessibilityCustomRotorItemSearchDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCBAF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAlertDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCE2F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAlignmentFeedbackToken {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCE4062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAnimationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCE9562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAppearanceCustomization {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCEB862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD12562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD30562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCandidateListTouchBarItemDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD3DD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF25362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCloudSharingServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD60262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD68162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD6A662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDelegateFlowLayout {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD6CD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewElement {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD6F962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxCellDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD98A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD99662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFB8062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD9A262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSControlTextEditingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDA1F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDatePickerCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDADC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDockTilePlugIn {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDB1162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDraggingDestination {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDBFF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDraggingSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDC6C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDrawerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDDE662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSGestureRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE01762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSHapticFeedbackPerformer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE0FB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSImageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE19F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSLayoutManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE35E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMatrixDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE43D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMenuDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE5D862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOpenSavePanelDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE8C462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOutlineViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE93262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOutlineViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE96A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPageControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE9CF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardItemDataProvider {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEA9E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardReading {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEAA662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardWriting {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEAB462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPathCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEAF262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPathControlDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEB3062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPopoverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xECAD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPrintPanelAccessorizing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEE0D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSRuleEditorDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEEF462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF0A562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF0B162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberFlowLayoutDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF0C762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSearchFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF16A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSeguePerforming {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF1FD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServicePickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF29262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServicePickerTouchBarItemDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF2AA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSoundDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4B162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpeechRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4CB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpeechSynthesizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4F962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSplitViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF5A662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpringLoadingDestination {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF5E162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSStackViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF61B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF8D962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF90662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF93462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTabViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF9C362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextAttachmentContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFA8062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFAE762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFinderBarContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFBB062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFinderClient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFBDC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextInputClient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFC1962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextStorageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFC9762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFE4862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTokenFieldCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFEB062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTokenFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFEC862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSToolbarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFF1D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTouchBarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFF8E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSViewControllerPresentationAnimator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x103A662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSWindowDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1072662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSWindowRestoration {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1075A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface __monomac_internal_ActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0;
	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0;
	-(BOOL) validateMenuItem:(NSMenuItem *)p0;
	-(BOOL) worksWhenModal;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __monomac_internal_ActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x10A3662);
	}

	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x10A3762);
	}

	-(BOOL) validateMenuItem:(NSMenuItem *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, p0, 0x10A3E62);
	}

	-(BOOL) worksWhenModal
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_11 (self, _cmd, &managed_method, 0x10A3F62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10A3962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAlertDidEndDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_NSAlertDidEndDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, p2, 0x10A4962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCacheDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10E2A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCoding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10F0C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x10F0F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10F8262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10F8E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSExtensionRequestHandling {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1121F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFileManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x112EC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFilePresenter {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1131162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedArchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x114DB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedUnarchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1151162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x11C6162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMachPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1160D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMetadataQueryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x117F362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMutableCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1185362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x119B662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x119CA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x11E4462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLAuthenticationChallengeSender {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1225B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122E562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122D462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122F362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUrlDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1234162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1247462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionTaskDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x124D262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1246362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1247F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1249162);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUserActivityDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1254562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUserNotificationCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x125DC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface Foundation_InternalNSNotificationHandler : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) post:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_InternalNSNotificationHandler {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) post:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x127EB62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@implementation Foundation_NSUrlProtocolClient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface Foundation_NSDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinApplySelector;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x1289C62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1289B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSActionDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x1289F62);
	}
@end

@interface __MonoMac_NSSynchronizationContextDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128A162);
	}
@end

@interface __Xamarin_NSTimerActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinFireSelector:(NSTimer *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __Xamarin_NSTimerActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinFireSelector:(NSTimer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x128A362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface Foundation_NSAsyncDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
	-(id) init;
@end

@implementation Foundation_NSAsyncDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128A662);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x128A562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Foundation_NSDispatcher class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAsyncActionDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128A862);
	}
@end

@interface __MonoMac_NSAsyncSynchronizationContextDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128AA62);
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, 0x12A5162);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy2 : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy2 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, 0x12A5362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface WebKit_WebView__WebFrameLoadDelegate : NSObject<WebFrameLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4;
	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebFrameLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5762);
	}

	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5862);
	}

	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_18 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5962);
	}

	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5A62);
	}

	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5B62);
	}

	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5C62);
	}

	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5D62);
	}

	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5E62);
	}

	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5F62);
	}

	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A6062);
	}

	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6162);
	}

	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A6262);
	}

	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A6362);
	}

	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A6462);
	}

	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, p1, 0x12A6562);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A5662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebDownloadDelegate : NSObject<WebDownloadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebDownloadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x12A6762);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A6662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebResourceLoadDelegate : NSObject<WebResourceLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2;
	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3;
	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebResourceLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6962);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6A62);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_28 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6B62);
	}

	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6C62);
	}

	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_30 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6D62);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6E62);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6F62);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_32 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A7062);
	}

	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A7162);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A6862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebUIDelegate : NSObject<WebUIDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0;
	-(void) webViewClose:(WebView *)p0;
	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1;
	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1;
	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1;
	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1;
	-(void) webViewFocus:(WebView *)p0;
	-(CGRect) webViewContentRect:(WebView *)p0;
	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2;
	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1;
	-(NSResponder *) webViewFirstResponder:(WebView *)p0;
	-(float) webViewFooterHeight:(WebView *)p0;
	-(CGRect) webViewFrame:(WebView *)p0;
	-(float) webViewHeaderHeight:(WebView *)p0;
	-(NSString *) webViewStatusText:(WebView *)p0;
	-(BOOL) webViewIsResizable:(WebView *)p0;
	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0;
	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1;
	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2;
	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1;
	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3;
	-(void) webViewRunModal:(WebView *)p0;
	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1;
	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1;
	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1;
	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1;
	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2;
	-(void) webViewShow:(WebView *)p0;
	-(void) webViewUnfocus:(WebView *)p0;
	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2;
	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2;
	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebUIDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x12A7362);
	}

	-(void) webViewClose:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A7462);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_36 (self, _cmd, &managed_method, p0, p1, 0x12A7562);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_36 (self, _cmd, &managed_method, p0, p1, 0x12A7662);
	}

	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, p0, p1, 0x12A7762);
	}

	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A7862);
	}

	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A7962);
	}

	-(void) webViewFocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A7A62);
	}

	-(CGRect) webViewContentRect:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, 0x12A7B62);
	}

	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_40 (self, _cmd, &managed_method, p0, p1, p2, 0x12A7C62);
	}

	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_41 (self, _cmd, &managed_method, p0, p1, 0x12A7D62);
	}

	-(NSResponder *) webViewFirstResponder:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x12A7E62);
	}

	-(float) webViewFooterHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, 0x12A7F62);
	}

	-(CGRect) webViewFrame:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, 0x12A8062);
	}

	-(float) webViewHeaderHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, 0x12A8162);
	}

	-(NSString *) webViewStatusText:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_44 (self, _cmd, &managed_method, p0, 0x12A8262);
	}

	-(BOOL) webViewIsResizable:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x12A8362);
	}

	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x12A8462);
	}

	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_45 (self, _cmd, &managed_method, p0, p1, 0x12A8562);
	}

	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8662);
	}

	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_47 (self, _cmd, &managed_method, p0, p1, 0x12A8762);
	}

	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_48 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8862);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, 0x12A8962);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8A62);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_50 (self, _cmd, &managed_method, p0, p1, 0x12A8B62);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_48 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8C62);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_51 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8D62);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_52 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A8E62);
	}

	-(void) webViewRunModal:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A8F62);
	}

	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_53 (self, _cmd, &managed_method, p0, p1, 0x12A9062);
	}

	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A9162);
	}

	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A9262);
	}

	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, 0x12A9362);
	}

	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, 0x12A9462);
	}

	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, 0x12A9562);
	}

	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, 0x12A9662);
	}

	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_55 (self, _cmd, &managed_method, p0, p1, p2, 0x12A9762);
	}

	-(void) webViewShow:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A9862);
	}

	-(void) webViewUnfocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A9962);
	}

	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, p1, p2, 0x12A9A62);
	}

	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, p2, 0x12A9B62);
	}

	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_58 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A9C62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A7262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebPolicyDelegate : NSObject<WebPolicyDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebPolicyDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A9E62);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_60 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A9F62);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_61 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12AA062);
	}

	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, p2, 0x12AA162);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A9D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKRequest__SKRequestDelegate : NSObject<SKRequestDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1;
	-(void) requestDidFinish:(SKRequest *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation StoreKit_SKRequest__SKRequestDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_62 (self, _cmd, &managed_method, p0, p1, 0x12ABF62);
	}

	-(void) requestDidFinish:(SKRequest *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_63 (self, _cmd, &managed_method, p0, 0x12AC062);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12ABE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKProductsRequest__SKProductsRequestDelegate : StoreKit_SKRequest__SKRequestDelegate<SKProductsRequestDelegate, SKRequestDelegate> {
}
	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1;
	-(id) init;
@end

@implementation StoreKit_SKProductsRequest__SKProductsRequestDelegate {
}

	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_64 (self, _cmd, &managed_method, p0, p1, 0x12ABD62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12ABC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [StoreKit_SKRequest__SKRequestDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate : NSObject<SKPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) didBeginContact:(SKPhysicsContact *)p0;
	-(void) didEndContact:(SKPhysicsContact *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) didBeginContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_65 (self, _cmd, &managed_method, p0, 0x12ACA62);
	}

	-(void) didEndContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_65 (self, _cmd, &managed_method, p0, 0x12ACB62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12AC962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ScriptingBridge_SBApplication__SBApplicationDelegate : NSObject<SBApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ScriptingBridge_SBApplication__SBApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_66 (self, _cmd, &managed_method, p0, p1, 0x12AEE62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12AED62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate : NSObject<SCNPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, 0x12AFE62);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, 0x12AFF62);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, 0x12B0062);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12AFD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfDocument__PdfDocumentDelegate : NSObject<PDFDocumentDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) classForAnnotationClass:(Class)p0;
	-(void) documentDidBeginDocumentFind:(NSNotification *)p0;
	-(void) didMatchString:(PDFSelection *)p0;
	-(void) documentDidUnlock:(NSNotification *)p0;
	-(void) documentDidEndDocumentFind:(NSNotification *)p0;
	-(Class) classForAnnotationType:(NSString *)p0;
	-(void) documentDidFindMatch:(NSNotification *)p0;
	-(void) documentDidEndPageFind:(NSNotification *)p0;
	-(void) documentDidBeginPageFind:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfDocument__PdfDocumentDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) classForAnnotationClass:(Class)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_68 (self, _cmd, &managed_method, p0, 0x13B6662);
	}

	-(void) documentDidBeginDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6762);
	}

	-(void) didMatchString:(PDFSelection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_69 (self, _cmd, &managed_method, p0, 0x13B6862);
	}

	-(void) documentDidUnlock:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6962);
	}

	-(void) documentDidEndDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6A62);
	}

	-(Class) classForAnnotationType:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_70 (self, _cmd, &managed_method, p0, 0x13B6B62);
	}

	-(void) documentDidFindMatch:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6C62);
	}

	-(void) documentDidEndPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6D62);
	}

	-(void) documentDidBeginPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6E62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13B6562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfView__PdfViewDelegate : NSObject<PDFViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1;
	-(void) PDFViewPerformFind:(PDFView *)p0;
	-(void) PDFViewPerformGoToPage:(PDFView *)p0;
	-(void) PDFViewPerformPrint:(PDFView *)p0;
	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0;
	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1;
	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfView__PdfViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_71 (self, _cmd, &managed_method, p0, p1, 0x13B8962);
	}

	-(void) PDFViewPerformFind:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, 0x13B8A62);
	}

	-(void) PDFViewPerformGoToPage:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, 0x13B8B62);
	}

	-(void) PDFViewPerformPrint:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, 0x13B8C62);
	}

	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_73 (self, _cmd, &managed_method, p0, 0x13B8D62);
	}

	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, p1, 0x13B8E62);
	}

	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_75 (self, _cmd, &managed_method, p0, p1, 0x13B8F62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13B8862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate : NSObject<NCWidgetListViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1;
	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2;
	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1;
	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_76 (self, _cmd, &managed_method, p0, p1, 0x13BA962);
	}

	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, p1, p2, 0x13BAA62);
	}

	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_78 (self, _cmd, &managed_method, p0, p1, 0x13BAB62);
	}

	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_79 (self, _cmd, &managed_method, p0, 0x13BAC62);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, 0x13BAD62);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, 0x13BAE62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13BA862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate : NSObject<NCWidgetSearchViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2;
	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_81 (self, _cmd, &managed_method, p0, p1, 0x13BB062);
	}

	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, p2, 0x13BB162);
	}

	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x13BB262);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13BAF62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MapKit_MKMapView__MKMapViewDelegate : NSObject<MKMapViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3;
	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1;
	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1;
	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1;
	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1;
	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1;
	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0;
	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1;
	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1;
	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0;
	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0;
	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MapKit_MKMapView__MKMapViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13C8462);
	}

	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_85 (self, _cmd, &managed_method, p0, p1, 0x13C8562);
	}

	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x13C8662);
	}

	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x13C8762);
	}

	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C8862);
	}

	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, p1, 0x13C8962);
	}

	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x13C8A62);
	}

	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x13C8B62);
	}

	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, p1, 0x13C8C62);
	}

	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C8D62);
	}

	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_91 (self, _cmd, &managed_method, p0, p1, 0x13C8E62);
	}

	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, p1, 0x13C8F62);
	}

	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x13C9062);
	}

	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9162);
	}

	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, p1, 0x13C9262);
	}

	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x13C9362);
	}

	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x13C9462);
	}

	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9562);
	}

	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9662);
	}

	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9762);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13C8362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate : NSObject<IKCameraDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, p1, 0x13CA362);
	}

	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_95 (self, _cmd, &managed_method, p0, 0x13CA462);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CA262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate : NSObject<IKDeviceBrowserViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_96 (self, _cmd, &managed_method, p0, p1, 0x13CA662);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CA562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKImageBrowserView__IKImageBrowserDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2;
	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKImageBrowserView__IKImageBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_97 (self, _cmd, &managed_method, p0, p1, 0x13CAE62);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, p1, 0x13CAF62);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_99 (self, _cmd, &managed_method, p0, p1, p2, 0x13CB062);
	}

	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_100 (self, _cmd, &managed_method, p0, 0x13CB162);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CAD62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKSaveOptions__IKSaveOptionsDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKSaveOptions__IKSaveOptionsDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x13CB362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CB262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate : NSObject<IKScannerDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_102 (self, _cmd, &managed_method, p0, p1, 0x13CB562);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_103 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13CB662);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_104 (self, _cmd, &managed_method, p0, p1, p2, 0x13CB762);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CB462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate : NSObject<GKGameCenterControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_105 (self, _cmd, &managed_method, p0, 0x13CED62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CEC62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKAchievementViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate {
}

	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_106 (self, _cmd, &managed_method, p0, 0x13CDF62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CDE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate : NSObject<GKChallengeEventHandlerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0;
	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE362);
	}

	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE462);
	}

	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE562);
	}

	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE662);
	}

	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, 0x13CE762);
	}

	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, 0x13CE862);
	}

	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, 0x13CE962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CE262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate : NSObject<GKFriendRequestComposeViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_109 (self, _cmd, &managed_method, p0, 0x13CEB62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CEA62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKLeaderboardViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate {
}

	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_110 (self, _cmd, &managed_method, p0, 0x13D1362);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D1262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatch__GKMatchDelegate : NSObject<GKMatchDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2;
	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1;
	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2;
	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatch__GKMatchDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_111 (self, _cmd, &managed_method, p0, p1, p2, 0x13D2962);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_112 (self, _cmd, &managed_method, p0, p1, p2, 0x13D2A62);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13D2B62);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, p1, p2, 0x13D2C62);
	}

	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, p1, 0x13D2D62);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_116 (self, _cmd, &managed_method, p0, p1, 0x13D2E62);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_117 (self, _cmd, &managed_method, p0, p1, 0x13D2F62);
	}

	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_118 (self, _cmd, &managed_method, p0, p1, p2, 0x13D3062);
	}

	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, p1, p2, 0x13D3162);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D2862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate : NSObject<GKMatchmakerViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1;
	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_120 (self, _cmd, &managed_method, p0, p1, 0x13D4762);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_121 (self, _cmd, &managed_method, p0, p1, 0x13D4862);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_122 (self, _cmd, &managed_method, p0, p1, 0x13D4962);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_123 (self, _cmd, &managed_method, p0, p1, 0x13D4A62);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_124 (self, _cmd, &managed_method, p0, p1, 0x13D4B62);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0x13D4C62);
	}

	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, 0x13D4D62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D4662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ExternalAccessory_EAAccessory__EAAccessoryDelegate : NSObject<EAAccessoryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) accessoryDidDisconnect:(EAAccessory *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ExternalAccessory_EAAccessory__EAAccessoryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) accessoryDidDisconnect:(EAAccessory *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, 0x13D9D62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D9C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreLocation_CLLocationManager__CLLocationManagerDelegate : NSObject<CLLocationManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1;
	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1;
	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1;
	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreLocation_CLLocationManager__CLLocationManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_128 (self, _cmd, &managed_method, p0, p1, 0x13E2E62);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, 0x13E2F62);
	}

	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_130 (self, _cmd, &managed_method, p0, p1, p2, 0x13E3062);
	}

	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, 0x13E3162);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, 0x13E3262);
	}

	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, 0x13E3362);
	}

	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, 0x13E3462);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_133 (self, _cmd, &managed_method, p0, p1, 0x13E3562);
	}

	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_134 (self, _cmd, &managed_method, p0, p1, p2, 0x13E3662);
	}

	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, 0x13E3762);
	}

	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, 0x13E3862);
	}

	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_135 (self, _cmd, &managed_method, p0, 0x13E3962);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_136 (self, _cmd, &managed_method, p0, p1, p2, 0x13E3A62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13E2D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBCentralManager__CBCentralManagerDelegate : NSObject<CBCentralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3;
	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1;
	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0;
	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBCentralManager__CBCentralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_137 (self, _cmd, &managed_method, p0, p1, 0x13F3762);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_138 (self, _cmd, &managed_method, p0, p1, p2, 0x13F3862);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_139 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13F3962);
	}

	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_138 (self, _cmd, &managed_method, p0, p1, p2, 0x13F3A62);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, 0x13F3B62);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, 0x13F3C62);
	}

	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_141 (self, _cmd, &managed_method, p0, 0x13F3D62);
	}

	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_142 (self, _cmd, &managed_method, p0, p1, 0x13F3E62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F3662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheral__CBPeripheralDelegate : NSObject<CBPeripheralDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1;
	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0;
	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateName:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheral__CBPeripheralDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_143 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4062);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4162);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4262);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4362);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x13F4462);
	}

	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x13F4562);
	}

	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x13F4662);
	}

	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, p1, 0x13F4762);
	}

	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_149 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4862);
	}

	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x13F4962);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4A62);
	}

	-(void) peripheralDidUpdateName:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x13F4B62);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4C62);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4D62);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4E62);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4F62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F3F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate : NSObject<CBPeripheralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1;
	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_151 (self, _cmd, &managed_method, p0, p1, 0x13F5162);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5262);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5362);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_153 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5462);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5562);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5662);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_155 (self, _cmd, &managed_method, p0, p1, 0x13F5762);
	}

	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_156 (self, _cmd, &managed_method, p0, 0x13F5862);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_157 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5962);
	}

	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_156 (self, _cmd, &managed_method, p0, 0x13F5A62);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, 0x13F5B62);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_159 (self, _cmd, &managed_method, p0, p1, 0x13F5C62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F5062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreAnimation_CAAnimation__CAAnimationDelegate : NSObject<CAAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidStart:(CAAnimation *)p0;
	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreAnimation_CAAnimation__CAAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidStart:(CAAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_160 (self, _cmd, &managed_method, p0, 0x13F5E62);
	}

	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_161 (self, _cmd, &managed_method, p0, p1, 0x13F5F62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F5D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_AVCaptureFileOutput_recordingProxy : NSObject<AVCaptureFileOutputRecordingDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation AVFoundation_AVCaptureFileOutput_recordingProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_162 (self, _cmd, &managed_method, p0, p1, p2, 0x13FE262);
	}

	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_163 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13FE362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface AppKit_NSAlert__NSAlertDelegate : NSObject<NSAlertDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) alertShowHelp:(NSAlert *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAlert__NSAlertDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) alertShowHelp:(NSAlert *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, 0x1418D62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1418C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSAnimation__NSAnimationDelegate : NSObject<NSAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidEnd:(NSAnimation *)p0;
	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1;
	-(void) animationDidStop:(NSAnimation *)p0;
	-(BOOL) animationShouldStart:(NSAnimation *)p0;
	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAnimation__NSAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidEnd:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_165 (self, _cmd, &managed_method, p0, 0x1419562);
	}

	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_166 (self, _cmd, &managed_method, p0, p1, 0x1419662);
	}

	-(void) animationDidStop:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_165 (self, _cmd, &managed_method, p0, 0x1419762);
	}

	-(BOOL) animationShouldStart:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_167 (self, _cmd, &managed_method, p0, 0x1419862);
	}

	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_168 (self, _cmd, &managed_method, p0, p1, 0x1419962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1419462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSApplication__NSApplicationDelegate : NSObject<NSApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSMenu *) applicationDockMenu:(NSApplication *)p0;
	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0;
	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1;
	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0;
	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0;
	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0;
	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2;
	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) applicationDidBecomeActive:(NSNotification *)p0;
	-(void) applicationDidFinishLaunching:(NSNotification *)p0;
	-(void) applicationDidHide:(NSNotification *)p0;
	-(void) applicationDidResignActive:(NSNotification *)p0;
	-(void) applicationDidUnhide:(NSNotification *)p0;
	-(void) applicationDidUpdate:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2;
	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1;
	-(BOOL) application:(NSApplication *)p0 delegateHandlesKey:(NSString *)p1;
	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1;
	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1;
	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1;
	-(void) orderFrontStandardAboutPanel:(NSObject *)p0;
	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0;
	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1;
	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3;
	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0;
	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1;
	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1;
	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1;
	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1;
	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1;
	-(void) applicationWillBecomeActive:(NSNotification *)p0;
	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1;
	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) applicationWillFinishLaunching:(NSNotification *)p0;
	-(void) applicationWillHide:(NSNotification *)p0;
	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1;
	-(void) applicationWillResignActive:(NSNotification *)p0;
	-(void) applicationWillTerminate:(NSNotification *)p0;
	-(void) applicationWillUnhide:(NSNotification *)p0;
	-(void) applicationWillUpdate:(NSNotification *)p0;
	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSApplication__NSApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSMenu *) applicationDockMenu:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_169 (self, _cmd, &managed_method, p0, 0x1419D62);
	}

	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x1419E62);
	}

	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_171 (self, _cmd, &managed_method, p0, p1, 0x1419F62);
	}

	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x141A062);
	}

	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, 0x141A162);
	}

	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x141A262);
	}

	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, p2, 0x141A362);
	}

	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, p1, 0x141A462);
	}

	-(void) applicationDidBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A562);
	}

	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A662);
	}

	-(void) applicationDidHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A762);
	}

	-(void) applicationDidResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A862);
	}

	-(void) applicationDidUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A962);
	}

	-(void) applicationDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141AA62);
	}

	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, p2, 0x141AB62);
	}

	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, p1, 0x141AC62);
	}

	-(BOOL) application:(NSApplication *)p0 delegateHandlesKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141AD62);
	}

	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141AE62);
	}

	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_178 (self, _cmd, &managed_method, p0, p1, 0x141AF62);
	}

	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, 0x141B062);
	}

	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141B162);
	}

	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_180 (self, _cmd, &managed_method, p0, p1, 0x141B262);
	}

	-(void) orderFrontStandardAboutPanel:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x141B362);
	}

	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_181 (self, _cmd, &managed_method, p0, 0x141B462);
	}

	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141B562);
	}

	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_182 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x141B662);
	}

	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_183 (self, _cmd, &managed_method, p0, 0x141B762);
	}

	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_184 (self, _cmd, &managed_method, p0, p1, 0x141B862);
	}

	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_185 (self, _cmd, &managed_method, p0, p1, 0x141B962);
	}

	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, 0x141BA62);
	}

	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141BB62);
	}

	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_187 (self, _cmd, &managed_method, p0, p1, 0x141BC62);
	}

	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_188 (self, _cmd, &managed_method, p0, p1, 0x141BD62);
	}

	-(void) applicationWillBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141BE62);
	}

	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141BF62);
	}

	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, p1, 0x141C062);
	}

	-(void) applicationWillFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C162);
	}

	-(void) applicationWillHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C262);
	}

	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, p1, 0x141C362);
	}

	-(void) applicationWillResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C462);
	}

	-(void) applicationWillTerminate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C562);
	}

	-(void) applicationWillUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C662);
	}

	-(void) applicationWillUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C762);
	}

	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_190 (self, _cmd, &managed_method, p0, p1, 0x141C862);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x141C962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1419C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation __NSGestureRecognizerToken {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1433E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSClickGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSClickGestureRecognizer *)p0;
@end

@implementation __NSClickGestureRecognizer {
}

	-(void) target:(NSClickGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_192 (self, _cmd, &managed_method, p0, 0x1427262);
	}
@end

@interface AppKit_NSTextField__NSTextFieldDelegate : NSObject<NSTextFieldDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2;
	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3;
	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1;
	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2;
	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1;
	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextField__NSTextFieldDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1452662);
	}

	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, p1, p2, 0x1452762);
	}

	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, p2, 0x1452862);
	}

	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_195 (self, _cmd, &managed_method, p0, p1, p2, 0x1452962);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1452A62);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1452B62);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_196 (self, _cmd, &managed_method, p0, p1, p2, 0x1452C62);
	}

	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x1452D62);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_198 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1452E62);
	}

	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_199 (self, _cmd, &managed_method, p0, p1, 0x1452F62);
	}

	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_200 (self, _cmd, &managed_method, p0, p1, p2, 0x1453062);
	}

	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, 0x1453162);
	}

	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, 0x1453262);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1452562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSComboBox__NSComboBoxDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSComboBoxDelegate, NSTextFieldDelegate> {
}
	-(void) comboBoxSelectionDidChange:(NSNotification *)p0;
	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0;
	-(void) comboBoxWillDismiss:(NSNotification *)p0;
	-(void) comboBoxWillPopUp:(NSNotification *)p0;
	-(id) init;
@end

@implementation AppKit_NSComboBox__NSComboBoxDelegate {
}

	-(void) comboBoxSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427862);
	}

	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427962);
	}

	-(void) comboBoxWillDismiss:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427A62);
	}

	-(void) comboBoxWillPopUp:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427B62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1427762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePicker__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePicker__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0x1428B62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1428A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePickerCell__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePickerCell__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0x1428D62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1428C62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSDocumentDuplicateCallback : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __NSDocumentDuplicateCallback {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_203 (self, _cmd, &managed_method, p0, p1, p2, 0x1429362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface AppKit_NSDrawer__NSDrawerDelegate : NSObject<NSDrawerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawerDidClose:(NSNotification *)p0;
	-(void) drawerDidOpen:(NSNotification *)p0;
	-(BOOL) drawerShouldClose:(NSDrawer *)p0;
	-(BOOL) drawerShouldOpen:(NSDrawer *)p0;
	-(void) drawerWillClose:(NSNotification *)p0;
	-(void) drawerWillOpen:(NSNotification *)p0;
	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDrawer__NSDrawerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawerDidClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429962);
	}

	-(void) drawerDidOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429A62);
	}

	-(BOOL) drawerShouldClose:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, 0x1429B62);
	}

	-(BOOL) drawerShouldOpen:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, 0x1429C62);
	}

	-(void) drawerWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429D62);
	}

	-(void) drawerWillOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429E62);
	}

	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_205 (self, _cmd, &managed_method, p0, p1, 0x1429F62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1429862);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate : NSObject<NSGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0;
	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x1433762);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, 0x1433862);
	}

	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_208 (self, _cmd, &managed_method, p0, 0x1433962);
	}

	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x1433A62);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_209 (self, _cmd, &managed_method, p0, p1, 0x1433B62);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, 0x1433C62);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, 0x1433D62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1433662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation __NSGestureRecognizerParameterlessToken {
}

	-(void) target
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x1434062);
	}
@end

@implementation __NSGestureRecognizerParametrizedToken {
}

	-(void) target:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_210 (self, _cmd, &managed_method, p0, 0x1434262);
	}
@end

@interface AppKit_NSImage__NSImageDelegate : NSObject<NSImageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1;
	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1;
	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSImage__NSImageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_211 (self, _cmd, &managed_method, p0, p1, p2, 0x1434B62);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_212 (self, _cmd, &managed_method, p0, p1, p2, 0x1434C62);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_213 (self, _cmd, &managed_method, p0, p1, 0x1434D62);
	}

	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_214 (self, _cmd, &managed_method, p0, p1, 0x1434E62);
	}

	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_213 (self, _cmd, &managed_method, p0, p1, 0x1434F62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1434A62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSMagnificationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSMagnificationGestureRecognizer *)p0;
@end

@implementation __NSMagnificationGestureRecognizer {
}

	-(void) target:(NSMagnificationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_215 (self, _cmd, &managed_method, p0, 0x1435362);
	}
@end

@interface AppKit_NSMatrix__NSMatrixDelegate : NSObject<NSMatrixDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSMatrix__NSMatrixDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1435462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSPageController__NSPageControllerDelegate : NSObject<NSPageControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0;
	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1;
	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1;
	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1;
	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1;
	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2;
	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPageController__NSPageControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_216 (self, _cmd, &managed_method, p0, 0x143F862);
	}

	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_217 (self, _cmd, &managed_method, p0, p1, 0x143F962);
	}

	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_218 (self, _cmd, &managed_method, p0, p1, 0x143FA62);
	}

	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_219 (self, _cmd, &managed_method, p0, p1, 0x143FB62);
	}

	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_220 (self, _cmd, &managed_method, p0, p1, 0x143FC62);
	}

	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_221 (self, _cmd, &managed_method, p0, p1, p2, 0x143FD62);
	}

	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_216 (self, _cmd, &managed_method, p0, 0x143FE62);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x143FF62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x143F762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSPanGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPanGestureRecognizer *)p0;
@end

@implementation __NSPanGestureRecognizer {
}

	-(void) target:(NSPanGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_222 (self, _cmd, &managed_method, p0, 0x1440262);
	}
@end

@interface AppKit_NSPathCell__NSPathCellDelegate : NSObject<NSPathCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1;
	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPathCell__NSPathCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_223 (self, _cmd, &managed_method, p0, p1, 0x1440462);
	}

	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, p1, 0x1440562);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1440362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSPressGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPressGestureRecognizer *)p0;
@end

@implementation __NSPressGestureRecognizer {
}

	-(void) target:(NSPressGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_225 (self, _cmd, &managed_method, p0, 0x1445D62);
	}
@end

@interface __NSRotationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSRotationGestureRecognizer *)p0;
@end

@implementation __NSRotationGestureRecognizer {
}

	-(void) target:(NSRotationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_226 (self, _cmd, &managed_method, p0, 0x1445F62);
	}
@end

@interface AppKit_NSRuleEditor__NSRuleEditorDelegate : NSObject<NSRuleEditorDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2;
	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3;
	-(void) ruleEditorRowsDidChange:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSRuleEditor__NSRuleEditorDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446162);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_227 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1446262);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_228 (self, _cmd, &managed_method, p0, p1, p2, 0x1446362);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446462);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446562);
	}

	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_229 (self, _cmd, &managed_method, p0, p1, p2, 0x1446662);
	}

	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_230 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1446762);
	}

	-(void) ruleEditorRowsDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446862);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1446062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSavePanel__NSOpenSavePanelDelegate : NSObject<NSOpenSavePanelDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3;
	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1;
	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1;
	-(void) panelSelectionDidChange:(NSSavePanel *)p0;
	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1;
	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2;
	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2;
	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSavePanel__NSOpenSavePanelDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_231 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1446C62);
	}

	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_232 (self, _cmd, &managed_method, p0, p1, 0x1446D62);
	}

	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_233 (self, _cmd, &managed_method, p0, p1, 0x1446E62);
	}

	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, p1, 0x1446F62);
	}

	-(void) panelSelectionDidChange:(NSSavePanel *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_235 (self, _cmd, &managed_method, p0, 0x1447062);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_236 (self, _cmd, &managed_method, p0, p1, 0x1447162);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, p1, 0x1447262);
	}

	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_237 (self, _cmd, &managed_method, p0, p1, p2, 0x1447362);
	}

	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_238 (self, _cmd, &managed_method, p0, p1, p2, 0x1447462);
	}

	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_239 (self, _cmd, &managed_method, p0, p1, 0x1447562);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1446B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSearchField__NSSearchFieldDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSSearchFieldDelegate, NSTextFieldDelegate> {
}
	-(void) searchFieldDidEndSearching:(NSSearchField *)p0;
	-(void) searchFieldDidStartSearching:(NSSearchField *)p0;
	-(id) init;
@end

@implementation AppKit_NSSearchField__NSSearchFieldDelegate {
}

	-(void) searchFieldDidEndSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_240 (self, _cmd, &managed_method, p0, 0x1448362);
	}

	-(void) searchFieldDidStartSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_240 (self, _cmd, &managed_method, p0, 0x1448462);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1448262);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingService__NSSharingServiceDelegate : NSObject<NSSharingServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2;
	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2;
	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1;
	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1;
	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2;
	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2;
	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingService__NSSharingServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_241 (self, _cmd, &managed_method, p0, p1, p2, 0x1448662);
	}

	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_242 (self, _cmd, &managed_method, p0, p1, p2, 0x1448762);
	}

	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_243 (self, _cmd, &managed_method, p0, p1, 0x1448862);
	}

	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_244 (self, _cmd, &managed_method, p0, p1, 0x1448962);
	}

	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_245 (self, _cmd, &managed_method, p0, p1, p2, 0x1448A62);
	}

	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_246 (self, _cmd, &managed_method, p0, p1, p2, 0x1448B62);
	}

	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_243 (self, _cmd, &managed_method, p0, p1, 0x1448C62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1448562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate : NSObject<NSSharingServicePickerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1;
	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1;
	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_247 (self, _cmd, &managed_method, p0, p1, 0x1448E62);
	}

	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_248 (self, _cmd, &managed_method, p0, p1, 0x1448F62);
	}

	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_249 (self, _cmd, &managed_method, p0, p1, p2, 0x1449062);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1448D62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSound__NSSoundDelegate : NSObject<NSSoundDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSound__NSSoundDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_250 (self, _cmd, &managed_method, p0, p1, 0x144D462);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x144D362);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTableView__NSTableViewDelegate : NSObject<NSTableViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tableViewColumnDidMove:(NSNotification *)p0;
	-(void) tableViewColumnDidResize:(NSNotification *)p0;
	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3;
	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1;
	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5;
	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1;
	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2;
	-(void) tableViewSelectionDidChange:(NSNotification *)p0;
	-(void) tableViewSelectionIsChanging:(NSNotification *)p0;
	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0;
	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2;
	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTableView__NSTableViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tableViewColumnDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144E862);
	}

	-(void) tableViewColumnDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144E962);
	}

	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_251 (self, _cmd, &managed_method, p0, p1, 0x144EA62);
	}

	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_252 (self, _cmd, &managed_method, p0, p1, p2, 0x144EB62);
	}

	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, 0x144EC62);
	}

	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, 0x144ED62);
	}

	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_252 (self, _cmd, &managed_method, p0, p1, p2, 0x144EE62);
	}

	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_254 (self, _cmd, &managed_method, p0, p1, p2, 0x144EF62);
	}

	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_255 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x144F062);
	}

	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_256 (self, _cmd, &managed_method, p0, p1, 0x144F162);
	}

	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_257 (self, _cmd, &managed_method, p0, p1, p2, 0x144F262);
	}

	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_258 (self, _cmd, &managed_method, p0, p1, 0x144F362);
	}

	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_256 (self, _cmd, &managed_method, p0, p1, 0x144F462);
	}

	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_259 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, 0x144F562);
	}

	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_260 (self, _cmd, &managed_method, p0, p1, p2, 0x144F662);
	}

	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_261 (self, _cmd, &managed_method, p0, p1, 0x144F762);
	}

	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, 0x144F862);
	}

	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_262 (self, _cmd, &managed_method, p0, p1, p2, 0x144F962);
	}

	-(void) tableViewSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144FA62);
	}

	-(void) tableViewSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144FB62);
	}

	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_263 (self, _cmd, &managed_method, p0, 0x144FC62);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_264 (self, _cmd, &managed_method, p0, p1, p2, 0x144FD62);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_265 (self, _cmd, &managed_method, p0, p1, p2, 0x144FE62);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_261 (self, _cmd, &managed_method, p0, p1, 0x144FF62);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_266 (self, _cmd, &managed_method, p0, p1, 0x1450062);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_264 (self, _cmd, &managed_method, p0, p1, p2, 0x1450162);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_267 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1450262);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_268 (self, _cmd, &managed_method, p0, p1, p2, 0x1450362);
	}

	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_269 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1450462);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x1450562);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x144E762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTabView__NSTabViewDelegate : NSObject<NSTabViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0;
	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTabView__NSTabViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_270 (self, _cmd, &managed_method, p0, p1, 0x1451062);
	}

	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_271 (self, _cmd, &managed_method, p0, 0x1451162);
	}

	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_272 (self, _cmd, &managed_method, p0, p1, 0x1451262);
	}

	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_270 (self, _cmd, &managed_method, p0, p1, 0x1451362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1450F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSText__NSTextDelegate : NSObject<NSTextDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textDidBeginEditing:(NSNotification *)p0;
	-(void) textDidChange:(NSNotification *)p0;
	-(void) textDidEndEditing:(NSNotification *)p0;
	-(BOOL) textShouldBeginEditing:(NSText *)p0;
	-(BOOL) textShouldEndEditing:(NSText *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSText__NSTextDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1451562);
	}

	-(void) textDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1451662);
	}

	-(void) textDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1451762);
	}

	-(BOOL) textShouldBeginEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, 0x1451862);
	}

	-(BOOL) textShouldEndEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, 0x1451962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1451462);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextStorage__NSTextStorageDelegate : NSObject<NSTextStorageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(void) textStorageDidProcessEditing:(NSNotification *)p0;
	-(void) textStorageWillProcessEditing:(NSNotification *)p0;
	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextStorage__NSTextStorageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1453662);
	}

	-(void) textStorageDidProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1453762);
	}

	-(void) textStorageWillProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1453862);
	}

	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1453962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1453562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextView__NSTextViewDelegate : AppKit_NSText__NSTextDelegate<NSTextViewDelegate, NSTextDelegate> {
}
	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textViewDidChangeSelection:(NSNotification *)p0;
	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0;
	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6;
	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1;
	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1;
	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2;
	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0;
	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2;
	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1;
	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1;
	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3;
	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(id) init;
@end

@implementation AppKit_NSTextView__NSTextViewDelegate {
}

	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1453F62);
	}

	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454062);
	}

	-(void) textViewDidChangeSelection:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1454162);
	}

	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1454262);
	}

	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_276 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, p6, 0x1454362);
	}

	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_277 (self, _cmd, &managed_method, p0, p1, 0x1454462);
	}

	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_278 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454562);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_279 (self, _cmd, &managed_method, p0, p1, 0x1454662);
	}

	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_280 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454762);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_281 (self, _cmd, &managed_method, p0, p1, p2, 0x1454862);
	}

	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_282 (self, _cmd, &managed_method, p0, 0x1454962);
	}

	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_283 (self, _cmd, &managed_method, p0, p1, p2, 0x1454A62);
	}

	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_284 (self, _cmd, &managed_method, p0, p1, p2, 0x1454B62);
	}

	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_285 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454C62);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_286 (self, _cmd, &managed_method, p0, p1, p2, 0x1454D62);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_287 (self, _cmd, &managed_method, p0, p1, p2, 0x1454E62);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_288 (self, _cmd, &managed_method, p0, p1, p2, 0x1454F62);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_289 (self, _cmd, &managed_method, p0, p1, 0x1455062);
	}

	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_290 (self, _cmd, &managed_method, p0, p1, p2, 0x1455162);
	}

	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_291 (self, _cmd, &managed_method, p0, p1, 0x1455262);
	}

	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_292 (self, _cmd, &managed_method, p0, p1, p2, 0x1455362);
	}

	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_293 (self, _cmd, &managed_method, p0, p1, p2, 0x1455462);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_294 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1455562);
	}

	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_295 (self, _cmd, &managed_method, p0, p1, p2, 0x1455662);
	}

	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_296 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x1455762);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x1455862);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1453E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSText__NSTextDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSToolbar__NSToolbarDelegate : NSObject<NSToolbarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0;
	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarDidRemoveItem:(NSNotification *)p0;
	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarWillAddItem:(NSNotification *)p0;
	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSToolbar__NSToolbarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, 0x1456162);
	}

	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, 0x1456262);
	}

	-(void) toolbarDidRemoveItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1456362);
	}

	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, 0x1456462);
	}

	-(void) toolbarWillAddItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1456562);
	}

	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_298 (self, _cmd, &managed_method, p0, p1, p2, 0x1456662);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1456062);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTouchBar__NSTouchBarDelegate : NSObject<NSTouchBarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTouchBar__NSTouchBarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_299 (self, _cmd, &managed_method, p0, p1, 0x1456C62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1456B62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSWindow__NSWindowDelegate : NSObject<NSWindowDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0;
	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0;
	-(void) windowDidBecomeKey:(NSNotification *)p0;
	-(void) windowDidBecomeMain:(NSNotification *)p0;
	-(void) windowDidChangeBackingProperties:(NSNotification *)p0;
	-(void) windowDidChangeScreen:(NSNotification *)p0;
	-(void) windowDidChangeScreenProfile:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) windowDidDeminiaturize:(NSNotification *)p0;
	-(void) windowDidEndLiveResize:(NSNotification *)p0;
	-(void) windowDidEndSheet:(NSNotification *)p0;
	-(void) windowDidEnterFullScreen:(NSNotification *)p0;
	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExitFullScreen:(NSNotification *)p0;
	-(void) windowDidExitVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExpose:(NSNotification *)p0;
	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0;
	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0;
	-(void) windowDidMiniaturize:(NSNotification *)p0;
	-(void) windowDidMove:(NSNotification *)p0;
	-(void) windowDidResignKey:(NSNotification *)p0;
	-(void) windowDidResignMain:(NSNotification *)p0;
	-(void) windowDidResize:(NSNotification *)p0;
	-(void) windowDidUpdate:(NSNotification *)p0;
	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1;
	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1;
	-(void) windowWillBeginSheet:(NSNotification *)p0;
	-(void) windowWillClose:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) windowWillEnterFullScreen:(NSNotification *)p0;
	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowWillExitFullScreen:(NSNotification *)p0;
	-(void) windowWillExitVersionBrowser:(NSNotification *)p0;
	-(void) windowWillMiniaturize:(NSNotification *)p0;
	-(void) windowWillMove:(NSNotification *)p0;
	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2;
	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1;
	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2;
	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1;
	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0;
	-(void) windowWillStartLiveResize:(NSNotification *)p0;
	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1;
	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1;
	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1;
	-(BOOL) windowShouldClose:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSWindow__NSWindowDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_300 (self, _cmd, &managed_method, p0, 0x145BA62);
	}

	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_300 (self, _cmd, &managed_method, p0, 0x145BB62);
	}

	-(void) windowDidBecomeKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BC62);
	}

	-(void) windowDidBecomeMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BD62);
	}

	-(void) windowDidChangeBackingProperties:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BE62);
	}

	-(void) windowDidChangeScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BF62);
	}

	-(void) windowDidChangeScreenProfile:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C062);
	}

	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_301 (self, _cmd, &managed_method, p0, p1, 0x145C162);
	}

	-(void) windowDidDeminiaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C262);
	}

	-(void) windowDidEndLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C362);
	}

	-(void) windowDidEndSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C462);
	}

	-(void) windowDidEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C562);
	}

	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C662);
	}

	-(void) windowDidExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C762);
	}

	-(void) windowDidExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C862);
	}

	-(void) windowDidExpose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C962);
	}

	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_302 (self, _cmd, &managed_method, p0, 0x145CA62);
	}

	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_302 (self, _cmd, &managed_method, p0, 0x145CB62);
	}

	-(void) windowDidMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CC62);
	}

	-(void) windowDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CD62);
	}

	-(void) windowDidResignKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CE62);
	}

	-(void) windowDidResignMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CF62);
	}

	-(void) windowDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D062);
	}

	-(void) windowDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D162);
	}

	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_303 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x145D262);
	}

	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_304 (self, _cmd, &managed_method, p0, p1, 0x145D362);
	}

	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_305 (self, _cmd, &managed_method, p0, p1, 0x145D462);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_306 (self, _cmd, &managed_method, p0, p1, 0x145D562);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_306 (self, _cmd, &managed_method, p0, p1, 0x145D662);
	}

	-(void) windowWillBeginSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D762);
	}

	-(void) windowWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D862);
	}

	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_301 (self, _cmd, &managed_method, p0, p1, 0x145D962);
	}

	-(void) windowWillEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DA62);
	}

	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DB62);
	}

	-(void) windowWillExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DC62);
	}

	-(void) windowWillExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DD62);
	}

	-(void) windowWillMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DE62);
	}

	-(void) windowWillMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DF62);
	}

	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_307 (self, _cmd, &managed_method, p0, p1, p2, 0x145E062);
	}

	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_308 (self, _cmd, &managed_method, p0, p1, 0x145E162);
	}

	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_309 (self, _cmd, &managed_method, p0, p1, p2, 0x145E262);
	}

	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_310 (self, _cmd, &managed_method, p0, p1, 0x145E362);
	}

	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_311 (self, _cmd, &managed_method, p0, 0x145E462);
	}

	-(void) windowWillStartLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145E562);
	}

	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_308 (self, _cmd, &managed_method, p0, p1, 0x145E662);
	}

	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_312 (self, _cmd, &managed_method, p0, p1, 0x145E762);
	}

	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_313 (self, _cmd, &managed_method, p0, p1, 0x145E862);
	}

	-(BOOL) windowShouldClose:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_314 (self, _cmd, &managed_method, p0, 0x145E962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x145B962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUrlSessionHandler_WrappedNSInputStream : NSInputStream {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSUInteger) streamStatus;
	-(void) open;
	-(void) close;
	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1;
	-(BOOL) hasBytesAvailable;
	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1;
	-(NSObject *) propertyForKey:(NSString *)p0;
	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1;
	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2;
	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_WrappedNSInputStream {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSUInteger) streamStatus
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_315 (self, _cmd, &managed_method, 0x146EF62);
	}

	-(void) open
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x146F062);
	}

	-(void) close
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x146F162);
	}

	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_316 (self, _cmd, &managed_method, p0, p1, 0x146F262);
	}

	-(BOOL) hasBytesAvailable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_11 (self, _cmd, &managed_method, 0x146F362);
	}

	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_317 (self, _cmd, &managed_method, p0, p1, 0x146F462);
	}

	-(NSObject *) propertyForKey:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_318 (self, _cmd, &managed_method, p0, 0x146F562);
	}

	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, p1, 0x146F662);
	}

	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_320 (self, _cmd, &managed_method, p0, p1, p2, 0x146F762);
	}

	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_321 (self, _cmd, &managed_method, p0, p1, 0x146F862);
	}

	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_321 (self, _cmd, &managed_method, p0, p1, 0x146F962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface Foundation_NSCache__NSCacheDelegate : NSObject<NSCacheDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSCache__NSCacheDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_322 (self, _cmd, &managed_method, p0, p1, 0x1470862);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1470762);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate : NSObject<NSKeyedArchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1;
	-(void) archiverDidFinish:(NSKeyedArchiver *)p0;
	-(void) archiverWillFinish:(NSKeyedArchiver *)p0;
	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_323 (self, _cmd, &managed_method, p0, p1, 0x1477A62);
	}

	-(void) archiverDidFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_324 (self, _cmd, &managed_method, p0, 0x1477B62);
	}

	-(void) archiverWillFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_324 (self, _cmd, &managed_method, p0, 0x1477C62);
	}

	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_325 (self, _cmd, &managed_method, p0, p1, p2, 0x1477D62);
	}

	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_326 (self, _cmd, &managed_method, p0, p1, 0x1477E62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1477962);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate : NSObject<NSKeyedUnarchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2;
	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1;
	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_327 (self, _cmd, &managed_method, p0, p1, p2, 0x1478062);
	}

	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_328 (self, _cmd, &managed_method, p0, p1, 0x1478162);
	}

	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_329 (self, _cmd, &managed_method, p0, 0x1478262);
	}

	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_329 (self, _cmd, &managed_method, p0, 0x1478362);
	}

	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_330 (self, _cmd, &managed_method, p0, p1, p2, 0x1478462);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1477F62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSMetadataQuery__NSMetadataQueryDelegate : NSObject<NSMetadataQueryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSMetadataQuery__NSMetadataQueryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_331 (self, _cmd, &managed_method, p0, p1, 0x1478F62);
	}

	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_332 (self, _cmd, &managed_method, p0, p1, p2, 0x1479062);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1478E62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetService__NSNetServiceDelegate : NSObject<NSNetServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceDidResolveAddress:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2;
	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1;
	-(void) netServiceDidPublish:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1;
	-(void) netServiceDidStop:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1;
	-(void) netServiceWillPublish:(NSNetService *)p0;
	-(void) netServiceWillResolve:(NSNetService *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetService__NSNetServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceDidResolveAddress:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147AC62);
	}

	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_334 (self, _cmd, &managed_method, p0, p1, p2, 0x147AD62);
	}

	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_335 (self, _cmd, &managed_method, p0, p1, 0x147AE62);
	}

	-(void) netServiceDidPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147AF62);
	}

	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_335 (self, _cmd, &managed_method, p0, p1, 0x147B062);
	}

	-(void) netServiceDidStop:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147B162);
	}

	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_336 (self, _cmd, &managed_method, p0, p1, 0x147B262);
	}

	-(void) netServiceWillPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147B362);
	}

	-(void) netServiceWillResolve:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147B462);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147AB62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate : NSObject<NSNetServiceBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1;
	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_337 (self, _cmd, &managed_method, p0, p1, p2, 0x147B662);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_337 (self, _cmd, &managed_method, p0, p1, p2, 0x147B762);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_338 (self, _cmd, &managed_method, p0, p1, p2, 0x147B862);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_339 (self, _cmd, &managed_method, p0, p1, 0x147B962);
	}

	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_340 (self, _cmd, &managed_method, p0, 0x147BA62);
	}

	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_340 (self, _cmd, &managed_method, p0, 0x147BB62);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_338 (self, _cmd, &managed_method, p0, p1, p2, 0x147BC62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147B562);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSObject_Disposer : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	+(void) drain:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __NSObject_Disposer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	+(void) drain:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_341 (self, _cmd, &managed_method, p0, 0x147C062);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147BE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __XamarinObjectObserver : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __XamarinObjectObserver {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_342 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x147C362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface Foundation_NSStream__NSStreamDelegate : NSObject<NSStreamDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSStream__NSStreamDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_343 (self, _cmd, &managed_method, p0, p1, 0x147DF62);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147DE62);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSThread_ActionThread : NSThread {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) main;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSThread_ActionThread {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) main
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x147E762);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@interface Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate : NSObject<NSUserNotificationCenterDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1;
	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_344 (self, _cmd, &managed_method, p0, p1, 0x1483762);
	}

	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_344 (self, _cmd, &managed_method, p0, p1, 0x1483862);
	}

	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_345 (self, _cmd, &managed_method, p0, p1, 0x1483962);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1483662);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate : NSObject<NSURLSessionDataDelegate, NSURLSessionTaskDelegate, NSURLSessionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_346 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x146BD62);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, p2, 0x146BE62);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_348 (self, _cmd, &managed_method, p0, p1, p2, 0x146BF62);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_349 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x146C162);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_350 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x146C262);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_351 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x146C362);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@implementation AppDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x3);
	}

	-(void) applicationWillTerminate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x5);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation ViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSTextField *) addrBox
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xB);
	}

	-(void) setAddrBox:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xD);
	}

	-(NSTextField *) addressTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xF);
	}

	-(void) setAddressTable:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x11);
	}

	-(NSTextField *) bpIndex
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x13);
	}

	-(void) setBpIndex:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x15);
	}

	-(NSStepper *) bpStepper
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_354 (self, _cmd, &managed_method, 0x17);
	}

	-(void) setBpStepper:(NSStepper *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_355 (self, _cmd, &managed_method, p0, 0x19);
	}

	-(NSTextFieldCell *) byteBoxx
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_356 (self, _cmd, &managed_method, 0x1B);
	}

	-(void) setByteBoxx:(NSTextFieldCell *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_357 (self, _cmd, &managed_method, p0, 0x1D);
	}

	-(NSTextField *) bytes
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x1F);
	}

	-(void) setBytes:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x21);
	}

	-(NSButton *) clearWP
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_358 (self, _cmd, &managed_method, 0x23);
	}

	-(void) setClearWP:(NSButton *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0x25);
	}

	-(NSComboBox *) comPort
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0x27);
	}

	-(void) setComPort:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x29);
	}

	-(NSTextView *) convertFrom
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_362 (self, _cmd, &managed_method, 0x2B);
	}

	-(void) setConvertFrom:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, 0x2D);
	}

	-(NSComboBox *) convertFromItems
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0x2F);
	}

	-(void) setConvertFromItems:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x31);
	}

	-(NSTextField *) convertResults
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x33);
	}

	-(void) setConvertResults:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x35);
	}

	-(NSTextField *) convertTo
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x37);
	}

	-(void) setConvertTo:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x39);
	}

	-(NSComboBox *) convertToItems
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0x3B);
	}

	-(void) setConvertToItems:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x3D);
	}

	-(NSTextField *) descTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x3F);
	}

	-(void) setDescTable:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x41);
	}

	-(NSTextField *) dissassembleField
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x43);
	}

	-(void) setDissassembleField:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x45);
	}

	-(NSTextView *) dissassField
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_362 (self, _cmd, &managed_method, 0x47);
	}

	-(void) setDissassField:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, 0x49);
	}

	-(NSTextField *) elfPath
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x4B);
	}

	-(void) setElfPath:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x4D);
	}

	-(NSButton *) filterTextUart
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_358 (self, _cmd, &managed_method, 0x4F);
	}

	-(void) setFilterTextUart:(NSButton *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0x51);
	}

	-(NSButton *) getMemory
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_358 (self, _cmd, &managed_method, 0x53);
	}

	-(void) setGetMemory:(NSButton *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0x55);
	}

	-(NSButton *) grabMemTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_358 (self, _cmd, &managed_method, 0x57);
	}

	-(void) setGrabMemTable:(NSButton *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0x59);
	}

	-(NSTextView *) hexView
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_362 (self, _cmd, &managed_method, 0x5B);
	}

	-(void) setHexView:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, 0x5D);
	}

	-(NSTextView *) idk
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_362 (self, _cmd, &managed_method, 0x5F);
	}

	-(void) setIdk:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, 0x61);
	}

	-(NSScrollView *) idkLOL
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_364 (self, _cmd, &managed_method, 0x63);
	}

	-(void) setIdkLOL:(NSScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_365 (self, _cmd, &managed_method, p0, 0x65);
	}

	-(NSTextField *) instructionField
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x67);
	}

	-(void) setInstructionField:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x69);
	}

	-(NSTextField *) ipTextBox
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x6B);
	}

	-(void) setIpTextBox:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x6D);
	}

	-(NSTextView *) justATest
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_362 (self, _cmd, &managed_method, 0x6F);
	}

	-(void) setJustATest:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, 0x71);
	}

	-(NSScrollView *) justTes
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_364 (self, _cmd, &managed_method, 0x73);
	}

	-(void) setJustTes:(NSScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_365 (self, _cmd, &managed_method, p0, 0x75);
	}

	-(NSView *) mainWindow
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_366 (self, _cmd, &managed_method, 0x77);
	}

	-(void) setMainWindow:(NSView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_367 (self, _cmd, &managed_method, p0, 0x79);
	}

	-(NSTextField *) memScanFrom
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x7B);
	}

	-(void) setMemScanFrom:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x7D);
	}

	-(NSProgressIndicator *) memScanProgress
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_368 (self, _cmd, &managed_method, 0x7F);
	}

	-(void) setMemScanProgress:(NSProgressIndicator *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_369 (self, _cmd, &managed_method, p0, 0x81);
	}

	-(NSTextField *) memScanRange
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x83);
	}

	-(void) setMemScanRange:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x85);
	}

	-(NSTextField *) memScanTotalRange
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x87);
	}

	-(void) setMemScanTotalRange:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x89);
	}

	-(NSComboBox *) memScanType
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0x8B);
	}

	-(void) setMemScanType:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x8D);
	}

	-(NSTextField *) memScanValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x8F);
	}

	-(void) setMemScanValue:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x91);
	}

	-(NSTableView *) OutPutTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_370 (self, _cmd, &managed_method, 0x93);
	}

	-(void) setOutPutTable:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_371 (self, _cmd, &managed_method, p0, 0x95);
	}

	-(NSComboBox *) processBox
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0x97);
	}

	-(void) setProcessBox:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x99);
	}

	-(NSTableView *) ptTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_370 (self, _cmd, &managed_method, 0x9B);
	}

	-(void) setPtTable:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_371 (self, _cmd, &managed_method, p0, 0x9D);
	}

	-(NSTextField *) ptTableFilePath
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0x9F);
	}

	-(void) setPtTableFilePath:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xA1);
	}

	-(NSTextField *) ptTableSaveName
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xA3);
	}

	-(void) setPtTableSaveName:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xA5);
	}

	-(NSTextView *) scanRes
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_362 (self, _cmd, &managed_method, 0xA7);
	}

	-(void) setScanRes:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_363 (self, _cmd, &managed_method, p0, 0xA9);
	}

	-(NSTableView *) ScanTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_370 (self, _cmd, &managed_method, 0xAB);
	}

	-(void) setScanTable:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_371 (self, _cmd, &managed_method, p0, 0xAD);
	}

	-(NSTableColumn *) scanTableOffset
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_372 (self, _cmd, &managed_method, 0xAF);
	}

	-(void) setScanTableOffset:(NSTableColumn *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_373 (self, _cmd, &managed_method, p0, 0xB1);
	}

	-(NSTableColumn *) scanTableValue
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_372 (self, _cmd, &managed_method, 0xB3);
	}

	-(void) setScanTableValue:(NSTableColumn *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_373 (self, _cmd, &managed_method, p0, 0xB5);
	}

	-(NSView *) selectPTTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_366 (self, _cmd, &managed_method, 0xB7);
	}

	-(void) setSelectPTTable:(NSView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_367 (self, _cmd, &managed_method, p0, 0xB9);
	}

	-(NSTextField *) setMemAddrBox
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xBB);
	}

	-(void) setSetMemAddrBox:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xBD);
	}

	-(NSTextField *) setMemByteBox
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xBF);
	}

	-(void) setSetMemByteBox:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xC1);
	}

	-(NSTextField *) setStringAddr
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xC3);
	}

	-(void) setSetStringAddr:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xC5);
	}

	-(NSButton *) setStringBtn
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_358 (self, _cmd, &managed_method, 0xC7);
	}

	-(void) setSetStringBtn:(NSButton *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_359 (self, _cmd, &managed_method, p0, 0xC9);
	}

	-(NSTextField *) setStringString
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xCB);
	}

	-(void) setSetStringString:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xCD);
	}

	-(NSTextField *) statusLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xCF);
	}

	-(void) setStatusLabel:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xD1);
	}

	-(NSClipView *) test
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_374 (self, _cmd, &managed_method, 0xD3);
	}

	-(void) setTest:(NSClipView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_375 (self, _cmd, &managed_method, p0, 0xD5);
	}

	-(NSScrollView *) testin
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_364 (self, _cmd, &managed_method, 0xD7);
	}

	-(void) setTestin:(NSScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_365 (self, _cmd, &managed_method, p0, 0xD9);
	}

	-(NSCollectionView *) testing
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_376 (self, _cmd, &managed_method, 0xDB);
	}

	-(void) setTesting:(NSCollectionView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_377 (self, _cmd, &managed_method, p0, 0xDD);
	}

	-(NSTextFieldCell *) testingAGAIN
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_356 (self, _cmd, &managed_method, 0xDF);
	}

	-(void) setTestingAGAIN:(NSTextFieldCell *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_357 (self, _cmd, &managed_method, p0, 0xE1);
	}

	-(NSTextFieldCell *) testingText
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_356 (self, _cmd, &managed_method, 0xE3);
	}

	-(void) setTestingText:(NSTextFieldCell *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_357 (self, _cmd, &managed_method, p0, 0xE5);
	}

	-(NSTextField *) testinLOL
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xE7);
	}

	-(void) setTestinLOL:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xE9);
	}

	-(NSTextField *) testLabel
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xEB);
	}

	-(void) setTestLabel:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xED);
	}

	-(NSTextField *) textToFilter
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xEF);
	}

	-(void) setTextToFilter:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xF1);
	}

	-(NSTextField *) textView
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xF3);
	}

	-(void) setTextView:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xF5);
	}

	-(NSComboBox *) typeTable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0xF7);
	}

	-(void) setTypeTable:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0xF9);
	}

	-(NSScrollView *) uartOutputBox
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_364 (self, _cmd, &managed_method, 0xFB);
	}

	-(void) setUartOutputBox:(NSScrollView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_365 (self, _cmd, &managed_method, p0, 0xFD);
	}

	-(NSTextField *) wpIndex
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xFF);
	}

	-(void) setWpIndex:(NSTextField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0x101);
	}

	-(NSComboBox *) wpLength
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0x103);
	}

	-(void) setWpLength:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x105);
	}

	-(NSStepper *) wpStepper
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_354 (self, _cmd, &managed_method, 0x107);
	}

	-(void) setWpStepper:(NSStepper *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_355 (self, _cmd, &managed_method, p0, 0x109);
	}

	-(NSComboBox *) wpType
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_360 (self, _cmd, &managed_method, 0x10B);
	}

	-(void) setWpType:(NSComboBox *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_361 (self, _cmd, &managed_method, p0, 0x10D);
	}

	-(void) viewDidLoad
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x10F);
	}

	-(NSObject *) representedObject
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_378 (self, _cmd, &managed_method, 0x111);
	}

	-(void) setRepresentedObject:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x113);
	}

	-(void) attachProcess:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x115);
	}

	-(void) clearBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x117);
	}

	-(void) clearOutput:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x119);
	}

	-(void) connectBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x11B);
	}

	-(void) convertBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x11D);
	}

	-(void) copyAddress:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x11F);
	}

	-(void) copyValue:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x121);
	}

	-(void) disassembleBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x123);
	}

	-(void) disconnectBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x125);
	}

	-(void) discordBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x127);
	}

	-(void) grabMem:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x129);
	}

	-(void) insertToTable:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x12B);
	}

	-(void) loadElf:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x12D);
	}

	-(void) loadPTTable:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x12F);
	}

	-(void) memScanButton:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x131);
	}

	-(void) ptTableClear:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x133);
	}

	-(void) ptTableSelect:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x135);
	}

	-(void) rebootBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x137);
	}

	-(void) refreshProcess:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x139);
	}

	-(void) savePTTable:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x13B);
	}

	-(void) selectelf:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x13D);
	}

	-(void) sendPayloadBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x13F);
	}

	-(void) setMemBtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x141);
	}

	-(void) setStringButtn:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x143);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@implementation PeekPoke_ScanTableDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_379 (self, _cmd, &managed_method, p0, 0x147);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x149);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PeekPoke_ProductTableDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_260 (self, _cmd, &managed_method, p0, p1, p2, 0x14D);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@implementation PeekPoke_OutputTableDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_379 (self, _cmd, &managed_method, p0, 0x151);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x153);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PeekPoke_OutputTableDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_260 (self, _cmd, &managed_method, p0, p1, p2, 0x157);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

@implementation PeekPoke_PTTableDataSource {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) numberOfRowsInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_379 (self, _cmd, &managed_method, p0, 0x15B);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x15D);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation PeekPoke_PTTableDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_260 (self, _cmd, &managed_method, p0, p1, p2, 0x161);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E62);
	}
@end

	static MTClassMap __xamarin_class_map [] = {
		{ NULL, 0x179262 /* #0 'NSObject' => 'Foundation.NSObject, Xamarin.Mac' */ },
		{ NULL, 0x11E62 /* #1 'VSAccountManager' => 'VideoSubscriberAccount.VSAccountManager, Xamarin.Mac' */ },
		{ NULL, 0x12362 /* #2 'VSAccountManagerDelegate' => 'VideoSubscriberAccount.VSAccountManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12462 /* #3 'VSAccountManagerResult' => 'VideoSubscriberAccount.VSAccountManagerResult, Xamarin.Mac' */ },
		{ NULL, 0x12562 /* #4 'VSAccountMetadata' => 'VideoSubscriberAccount.VSAccountMetadata, Xamarin.Mac' */ },
		{ NULL, 0x12662 /* #5 'VSAccountMetadataRequest' => 'VideoSubscriberAccount.VSAccountMetadataRequest, Xamarin.Mac' */ },
		{ NULL, 0x12962 /* #6 'VSAccountProviderResponse' => 'VideoSubscriberAccount.VSAccountProviderResponse, Xamarin.Mac' */ },
		{ NULL, 0x12F62 /* #7 'VSSubscription' => 'VideoSubscriberAccount.VSSubscription, Xamarin.Mac' */ },
		{ NULL, 0x13162 /* #8 'VSSubscriptionRegistrationCenter' => 'VideoSubscriberAccount.VSSubscriptionRegistrationCenter, Xamarin.Mac' */ },
		{ NULL, 0x14A62 /* #9 'UNNotificationTrigger' => 'UserNotifications.UNNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x13562 /* #10 'UNCalendarNotificationTrigger' => 'UserNotifications.UNCalendarNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x14262 /* #11 'UNNotificationContent' => 'UserNotifications.UNNotificationContent, Xamarin.Mac' */ },
		{ NULL, 0x13862 /* #12 'UNMutableNotificationContent' => 'UserNotifications.UNMutableNotificationContent, Xamarin.Mac' */ },
		{ NULL, 0x13962 /* #13 'UNNotification' => 'UserNotifications.UNNotification, Xamarin.Mac' */ },
		{ NULL, 0x13A62 /* #14 'UNNotificationAction' => 'UserNotifications.UNNotificationAction, Xamarin.Mac' */ },
		{ NULL, 0x13D62 /* #15 'UNNotificationAttachment' => 'UserNotifications.UNNotificationAttachment, Xamarin.Mac' */ },
		{ NULL, 0x14062 /* #16 'UNNotificationCategory' => 'UserNotifications.UNNotificationCategory, Xamarin.Mac' */ },
		{ NULL, 0x14462 /* #17 'UNNotificationRequest' => 'UserNotifications.UNNotificationRequest, Xamarin.Mac' */ },
		{ NULL, 0x14562 /* #18 'UNNotificationResponse' => 'UserNotifications.UNNotificationResponse, Xamarin.Mac' */ },
		{ NULL, 0x14662 /* #19 'UNNotificationServiceExtension' => 'UserNotifications.UNNotificationServiceExtension, Xamarin.Mac' */ },
		{ NULL, 0x14862 /* #20 'UNNotificationSettings' => 'UserNotifications.UNNotificationSettings, Xamarin.Mac' */ },
		{ NULL, 0x14962 /* #21 'UNNotificationSound' => 'UserNotifications.UNNotificationSound, Xamarin.Mac' */ },
		{ NULL, 0x14B62 /* #22 'UNPushNotificationTrigger' => 'UserNotifications.UNPushNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x14D62 /* #23 'UNTextInputNotificationAction' => 'UserNotifications.UNTextInputNotificationAction, Xamarin.Mac' */ },
		{ NULL, 0x14E62 /* #24 'UNTextInputNotificationResponse' => 'UserNotifications.UNTextInputNotificationResponse, Xamarin.Mac' */ },
		{ NULL, 0x14F62 /* #25 'UNTimeIntervalNotificationTrigger' => 'UserNotifications.UNTimeIntervalNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x15462 /* #26 'UNUserNotificationCenterDelegate' => 'UserNotifications.UNUserNotificationCenterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20262 /* #27 'WebScriptObject' => 'WebKit.WebScriptObject, Xamarin.Mac' */ },
		{ NULL, 0x1D362 /* #28 'DOMObject' => 'WebKit.DomObject, Xamarin.Mac' */ },
		{ NULL, 0x17162 /* #29 'DOMAbstractView' => 'WebKit.DomAbstractView, Xamarin.Mac' */ },
		{ NULL, 0x1CD62 /* #30 'DOMNode' => 'WebKit.DomNode, Xamarin.Mac' */ },
		{ NULL, 0x17262 /* #31 'DOMAttr' => 'WebKit.DomAttr, Xamarin.Mac' */ },
		{ NULL, 0x17362 /* #32 'DOMBlob' => 'WebKit.DomBlob, Xamarin.Mac' */ },
		{ NULL, 0x17562 /* #33 'DOMCharacterData' => 'WebKit.DomCharacterData, Xamarin.Mac' */ },
		{ NULL, 0x1DA62 /* #34 'DOMText' => 'WebKit.DomText, Xamarin.Mac' */ },
		{ NULL, 0x17462 /* #35 'DOMCDATASection' => 'WebKit.DomCDataSection, Xamarin.Mac' */ },
		{ NULL, 0x17662 /* #36 'DOMComment' => 'WebKit.DomComment, Xamarin.Mac' */ },
		{ NULL, 0x17B62 /* #37 'DOMCSSRule' => 'WebKit.DomCssRule, Xamarin.Mac' */ },
		{ NULL, 0x17762 /* #38 'DOMCSSCharsetRule' => 'WebKit.DomCssCharsetRule, Xamarin.Mac' */ },
		{ NULL, 0x17862 /* #39 'DOMCSSFontFaceRule' => 'WebKit.DomCssFontFaceRule, Xamarin.Mac' */ },
		{ NULL, 0x17962 /* #40 'DOMCSSMediaRule' => 'WebKit.DomCssMediaRule, Xamarin.Mac' */ },
		{ NULL, 0x17A62 /* #41 'DOMCSSPageRule' => 'WebKit.DomCssPageRule, Xamarin.Mac' */ },
		{ NULL, 0x17C62 /* #42 'DOMCSSRuleList' => 'WebKit.DomCssRuleList, Xamarin.Mac' */ },
		{ NULL, 0x17D62 /* #43 'DOMCSSStyleDeclaration' => 'WebKit.DomCssStyleDeclaration, Xamarin.Mac' */ },
		{ NULL, 0x17E62 /* #44 'DOMCSSStyleRule' => 'WebKit.DomCssStyleRule, Xamarin.Mac' */ },
		{ NULL, 0x1D862 /* #45 'DOMStyleSheet' => 'WebKit.DomStyleSheet, Xamarin.Mac' */ },
		{ NULL, 0x17F62 /* #46 'DOMCSSStyleSheet' => 'WebKit.DomCssStyleSheet, Xamarin.Mac' */ },
		{ NULL, 0x18062 /* #47 'DOMCSSUnknownRule' => 'WebKit.DomCssUnknownRule, Xamarin.Mac' */ },
		{ NULL, 0x18162 /* #48 'DOMCSSValue' => 'WebKit.DomCssValue, Xamarin.Mac' */ },
		{ NULL, 0x18262 /* #49 'DOMDocument' => 'WebKit.DomDocument, Xamarin.Mac' */ },
		{ NULL, 0x18362 /* #50 'DOMDocumentFragment' => 'WebKit.DomDocumentFragment, Xamarin.Mac' */ },
		{ NULL, 0x18462 /* #51 'DOMDocumentType' => 'WebKit.DomDocumentType, Xamarin.Mac' */ },
		{ NULL, 0x18562 /* #52 'DOMElement' => 'WebKit.DomElement, Xamarin.Mac' */ },
		{ NULL, 0x18662 /* #53 'DOMEntityReference' => 'WebKit.DomEntityReference, Xamarin.Mac' */ },
		{ NULL, 0x18762 /* #54 'DOMEvent' => 'WebKit.DomEvent, Xamarin.Mac' */ },
		{ NULL, 0x18A62 /* #55 'DOMEventListener' => 'WebKit.DomEventListener, Xamarin.Mac' */ },
		{ NULL, 0x18D62 /* #56 'DOMEventTarget' => 'WebKit.DomEventTarget, Xamarin.Mac' */ },
		{ NULL, 0x18E62 /* #57 'DOMFile' => 'WebKit.DomFile, Xamarin.Mac' */ },
		{ NULL, 0x18F62 /* #58 'DOMFileList' => 'WebKit.DomFileList, Xamarin.Mac' */ },
		{ NULL, 0x19D62 /* #59 'DOMHTMLElement' => 'WebKit.DomHtmlElement, Xamarin.Mac' */ },
		{ NULL, 0x19062 /* #60 'DOMHTMLAnchorElement' => 'WebKit.DomHtmlAnchorElement, Xamarin.Mac' */ },
		{ NULL, 0x19162 /* #61 'DOMHTMLAppletElement' => 'WebKit.DomHtmlAppletElement, Xamarin.Mac' */ },
		{ NULL, 0x19262 /* #62 'DOMHTMLAreaElement' => 'WebKit.DomHtmlAreaElement, Xamarin.Mac' */ },
		{ NULL, 0x19362 /* #63 'DOMHTMLBaseElement' => 'WebKit.DomHtmlBaseElement, Xamarin.Mac' */ },
		{ NULL, 0x19462 /* #64 'DOMHTMLBaseFontElement' => 'WebKit.DomHtmlBaseFontElement, Xamarin.Mac' */ },
		{ NULL, 0x19562 /* #65 'DOMHTMLBodyElement' => 'WebKit.DomHtmlBodyElement, Xamarin.Mac' */ },
		{ NULL, 0x19662 /* #66 'DOMHTMLBRElement' => 'WebKit.DomHtmlBRElement, Xamarin.Mac' */ },
		{ NULL, 0x19762 /* #67 'DOMHTMLButtonElement' => 'WebKit.DomHtmlButtonElement, Xamarin.Mac' */ },
		{ NULL, 0x19862 /* #68 'DOMHTMLCollection' => 'WebKit.DomHtmlCollection, Xamarin.Mac' */ },
		{ NULL, 0x19962 /* #69 'DOMHTMLDirectoryElement' => 'WebKit.DomHtmlDirectoryElement, Xamarin.Mac' */ },
		{ NULL, 0x19A62 /* #70 'DOMHTMLDivElement' => 'WebKit.DomHtmlDivElement, Xamarin.Mac' */ },
		{ NULL, 0x19B62 /* #71 'DOMHTMLDListElement' => 'WebKit.DomHtmlDListElement, Xamarin.Mac' */ },
		{ NULL, 0x19C62 /* #72 'DOMHTMLDocument' => 'WebKit.DomHtmlDocument, Xamarin.Mac' */ },
		{ NULL, 0x19E62 /* #73 'DOMHTMLEmbedElement' => 'WebKit.DomHtmlEmbedElement, Xamarin.Mac' */ },
		{ NULL, 0x19F62 /* #74 'DOMHTMLFieldSetElement' => 'WebKit.DomHtmlFieldSetElement, Xamarin.Mac' */ },
		{ NULL, 0x1A062 /* #75 'DOMHTMLFontElement' => 'WebKit.DomHtmlFontElement, Xamarin.Mac' */ },
		{ NULL, 0x1A162 /* #76 'DOMHTMLFormElement' => 'WebKit.DomHtmlFormElement, Xamarin.Mac' */ },
		{ NULL, 0x1A262 /* #77 'DOMHTMLFrameElement' => 'WebKit.DomHtmlFrameElement, Xamarin.Mac' */ },
		{ NULL, 0x1A362 /* #78 'DOMHTMLFrameSetElement' => 'WebKit.DomHtmlFrameSetElement, Xamarin.Mac' */ },
		{ NULL, 0x1A462 /* #79 'DOMHTMLHeadElement' => 'WebKit.DomHtmlHeadElement, Xamarin.Mac' */ },
		{ NULL, 0x1A562 /* #80 'DOMHTMLHeadingElement' => 'WebKit.DomHtmlHeadingElement, Xamarin.Mac' */ },
		{ NULL, 0x1A662 /* #81 'DOMHTMLHRElement' => 'WebKit.DomHtmlHRElement, Xamarin.Mac' */ },
		{ NULL, 0x1A762 /* #82 'DOMHTMLHtmlElement' => 'WebKit.DomHtmlHtmlElement, Xamarin.Mac' */ },
		{ NULL, 0x1A862 /* #83 'DOMHTMLIFrameElement' => 'WebKit.DomHtmlIFrameElement, Xamarin.Mac' */ },
		{ NULL, 0x1A962 /* #84 'DOMHTMLImageElement' => 'WebKit.DomHtmlImageElement, Xamarin.Mac' */ },
		{ NULL, 0x1AA62 /* #85 'DOMHTMLInputElement' => 'WebKit.DomHtmlInputElement, Xamarin.Mac' */ },
		{ NULL, 0x1AB62 /* #86 'DOMHTMLLabelElement' => 'WebKit.DomHtmlLabelElement, Xamarin.Mac' */ },
		{ NULL, 0x1AC62 /* #87 'DOMHTMLLegendElement' => 'WebKit.DomHtmlLegendElement, Xamarin.Mac' */ },
		{ NULL, 0x1AD62 /* #88 'DOMHTMLLIElement' => 'WebKit.DomHtmlLIElement, Xamarin.Mac' */ },
		{ NULL, 0x1AE62 /* #89 'DOMHTMLLinkElement' => 'WebKit.DomHtmlLinkElement, Xamarin.Mac' */ },
		{ NULL, 0x1AF62 /* #90 'DOMHTMLMapElement' => 'WebKit.DomHtmlMapElement, Xamarin.Mac' */ },
		{ NULL, 0x1B062 /* #91 'DOMHTMLMarqueeElement' => 'WebKit.DomHtmlMarqueeElement, Xamarin.Mac' */ },
		{ NULL, 0x1B162 /* #92 'DOMHTMLMenuElement' => 'WebKit.DomHtmlMenuElement, Xamarin.Mac' */ },
		{ NULL, 0x1B262 /* #93 'DOMHTMLMetaElement' => 'WebKit.DomHtmlMetaElement, Xamarin.Mac' */ },
		{ NULL, 0x1B362 /* #94 'DOMHTMLModElement' => 'WebKit.DomHtmlModElement, Xamarin.Mac' */ },
		{ NULL, 0x1B462 /* #95 'DOMHTMLObjectElement' => 'WebKit.DomHtmlObjectElement, Xamarin.Mac' */ },
		{ NULL, 0x1B562 /* #96 'DOMHTMLOListElement' => 'WebKit.DomHtmlOListElement, Xamarin.Mac' */ },
		{ NULL, 0x1B662 /* #97 'DOMHTMLOptGroupElement' => 'WebKit.DomHtmlOptGroupElement, Xamarin.Mac' */ },
		{ NULL, 0x1B762 /* #98 'DOMHTMLOptionElement' => 'WebKit.DomHtmlOptionElement, Xamarin.Mac' */ },
		{ NULL, 0x1B862 /* #99 'DOMHTMLOptionsCollection' => 'WebKit.DomHtmlOptionsCollection, Xamarin.Mac' */ },
		{ NULL, 0x1B962 /* #100 'DOMHTMLParagraphElement' => 'WebKit.DomHtmlParagraphElement, Xamarin.Mac' */ },
		{ NULL, 0x1BA62 /* #101 'DOMHTMLParamElement' => 'WebKit.DomHtmlParamElement, Xamarin.Mac' */ },
		{ NULL, 0x1BB62 /* #102 'DOMHTMLPreElement' => 'WebKit.DomHtmlPreElement, Xamarin.Mac' */ },
		{ NULL, 0x1BC62 /* #103 'DOMHTMLQuoteElement' => 'WebKit.DomHtmlQuoteElement, Xamarin.Mac' */ },
		{ NULL, 0x1BD62 /* #104 'DOMHTMLScriptElement' => 'WebKit.DomHtmlScriptElement, Xamarin.Mac' */ },
		{ NULL, 0x1BE62 /* #105 'DOMHTMLSelectElement' => 'WebKit.DomHtmlSelectElement, Xamarin.Mac' */ },
		{ NULL, 0x1BF62 /* #106 'DOMHTMLStyleElement' => 'WebKit.DomHtmlStyleElement, Xamarin.Mac' */ },
		{ NULL, 0x1C062 /* #107 'DOMHTMLTableCaptionElement' => 'WebKit.DomHtmlTableCaptionElement, Xamarin.Mac' */ },
		{ NULL, 0x1C162 /* #108 'DOMHTMLTableCellElement' => 'WebKit.DomHtmlTableCellElement, Xamarin.Mac' */ },
		{ NULL, 0x1C262 /* #109 'DOMHTMLTableColElement' => 'WebKit.DomHtmlTableColElement, Xamarin.Mac' */ },
		{ NULL, 0x1C362 /* #110 'DOMHTMLTableElement' => 'WebKit.DomHtmlTableElement, Xamarin.Mac' */ },
		{ NULL, 0x1C462 /* #111 'DOMHTMLTableRowElement' => 'WebKit.DomHtmlTableRowElement, Xamarin.Mac' */ },
		{ NULL, 0x1C562 /* #112 'DOMHTMLTableSectionElement' => 'WebKit.DomHtmlTableSectionElement, Xamarin.Mac' */ },
		{ NULL, 0x1C662 /* #113 'DOMHTMLTextAreaElement' => 'WebKit.DomHtmlTextAreaElement, Xamarin.Mac' */ },
		{ NULL, 0x1C762 /* #114 'DOMImplementation' => 'WebKit.DomImplementation, Xamarin.Mac' */ },
		{ NULL, 0x1C862 /* #115 'DOMCSSImportRule' => 'WebKit.DomImportCssRule, Xamarin.Mac' */ },
		{ NULL, 0x1DB62 /* #116 'DOMUIEvent' => 'WebKit.DomUIEvent, Xamarin.Mac' */ },
		{ NULL, 0x1C962 /* #117 'DOMKeyboardEvent' => 'WebKit.DomKeyboardEvent, Xamarin.Mac' */ },
		{ NULL, 0x1CA62 /* #118 'DOMMediaList' => 'WebKit.DomMediaList, Xamarin.Mac' */ },
		{ NULL, 0x1CB62 /* #119 'DOMMouseEvent' => 'WebKit.DomMouseEvent, Xamarin.Mac' */ },
		{ NULL, 0x1CC62 /* #120 'DOMNamedNodeMap' => 'WebKit.DomNamedNodeMap, Xamarin.Mac' */ },
		{ NULL, 0x1D062 /* #121 'Xamarin_Mac__WebKit_DomNodeFilter' => 'WebKit.DomNodeFilter, Xamarin.Mac' */ },
		{ NULL, 0x1D162 /* #122 'DOMNodeIterator' => 'WebKit.DomNodeIterator, Xamarin.Mac' */ },
		{ NULL, 0x1D262 /* #123 'DOMNodeList' => 'WebKit.DomNodeList, Xamarin.Mac' */ },
		{ NULL, 0x1D462 /* #124 'DOMOverflowEvent' => 'WebKit.DomOverflowEvent, Xamarin.Mac' */ },
		{ NULL, 0x1D562 /* #125 'DOMProcessingInstruction' => 'WebKit.DomProcessingInstruction, Xamarin.Mac' */ },
		{ NULL, 0x1D662 /* #126 'DOMProgressEvent' => 'WebKit.DomProgressEvent, Xamarin.Mac' */ },
		{ NULL, 0x1D762 /* #127 'DOMRange' => 'WebKit.DomRange, Xamarin.Mac' */ },
		{ NULL, 0x1D962 /* #128 'DOMStyleSheetList' => 'WebKit.DomStyleSheetList, Xamarin.Mac' */ },
		{ NULL, 0x1DC62 /* #129 'DOMWheelEvent' => 'WebKit.DomWheelEvent, Xamarin.Mac' */ },
		{ NULL, 0x1DD62 /* #130 'WebArchive' => 'WebKit.WebArchive, Xamarin.Mac' */ },
		{ NULL, 0x1DE62 /* #131 'WebBackForwardList' => 'WebKit.WebBackForwardList, Xamarin.Mac' */ },
		{ NULL, 0x1DF62 /* #132 'WebDataSource' => 'WebKit.WebDataSource, Xamarin.Mac' */ },
		{ NULL, 0x1E262 /* #133 'WebDocumentRepresentation' => 'WebKit.WebDocumentRepresentation, Xamarin.Mac' */ },
		{ NULL, 0x180862 /* #134 'NSURLDownload' => 'Foundation.NSUrlDownload, Xamarin.Mac' */ },
		{ NULL, 0x1E362 /* #135 'WebDownload' => 'WebKit.WebDownload, Xamarin.Mac' */ },
		{ NULL, 0x1E762 /* #136 'WebDownloadDelegate' => 'WebKit.WebDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1E862 /* #137 'WebFrame' => 'WebKit.WebFrame, Xamarin.Mac' */ },
		{ NULL, 0x1EC62 /* #138 'WebFrameLoadDelegate' => 'WebKit.WebFrameLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13E962 /* #139 'NSResponder' => 'AppKit.NSResponder, Xamarin.Mac' */ },
		{ NULL, 0x14F862 /* #140 'NSView' => 'AppKit.NSView, Xamarin.Mac' */ },
		{ NULL, 0x1ED62 /* #141 'WebFrameView' => 'WebKit.WebFrameView, Xamarin.Mac' */ },
		{ NULL, 0x1EE62 /* #142 'WebHistory' => 'WebKit.WebHistory, Xamarin.Mac' */ },
		{ NULL, 0x1F362 /* #143 'Xamarin_Mac__WebKit_WebOpenPanelResultListener' => 'WebKit.WebOpenPanelResultListener, Xamarin.Mac' */ },
		{ NULL, 0x1F762 /* #144 'Xamarin_Mac__WebKit_WebPolicyDecisionListener' => 'WebKit.WebPolicyDecisionListener, Xamarin.Mac' */ },
		{ NULL, 0x1FB62 /* #145 'WebPolicyDelegate' => 'WebKit.WebPolicyDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1FC62 /* #146 'WebPreferences' => 'WebKit.WebPreferences, Xamarin.Mac' */ },
		{ NULL, 0x1FD62 /* #147 'WebResource' => 'WebKit.WebResource, Xamarin.Mac' */ },
		{ NULL, 0x20162 /* #148 'WebResourceLoadDelegate' => 'WebKit.WebResourceLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20662 /* #149 'WebUIDelegate' => 'WebKit.WebUIDelegate, Xamarin.Mac' */ },
		{ NULL, 0x22C62 /* #150 'WKBackForwardList' => 'WebKit.WKBackForwardList, Xamarin.Mac' */ },
		{ NULL, 0x22D62 /* #151 'WKBackForwardListItem' => 'WebKit.WKBackForwardListItem, Xamarin.Mac' */ },
		{ NULL, 0x22E62 /* #152 'WKContentRuleList' => 'WebKit.WKContentRuleList, Xamarin.Mac' */ },
		{ NULL, 0x23262 /* #153 'WKFrameInfo' => 'WebKit.WKFrameInfo, Xamarin.Mac' */ },
		{ NULL, 0x23762 /* #154 'WKNavigation' => 'WebKit.WKNavigation, Xamarin.Mac' */ },
		{ NULL, 0x23862 /* #155 'WKNavigationAction' => 'WebKit.WKNavigationAction, Xamarin.Mac' */ },
		{ NULL, 0x23D62 /* #156 'WKNavigationDelegate' => 'WebKit.WKNavigationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x23E62 /* #157 'WKNavigationResponse' => 'WebKit.WKNavigationResponse, Xamarin.Mac' */ },
		{ NULL, 0x24162 /* #158 'WKOpenPanelParameters' => 'WebKit.WKOpenPanelParameters, Xamarin.Mac' */ },
		{ NULL, 0x24262 /* #159 'WKPreferences' => 'WebKit.WKPreferences, Xamarin.Mac' */ },
		{ NULL, 0x24362 /* #160 'WKProcessPool' => 'WebKit.WKProcessPool, Xamarin.Mac' */ },
		{ NULL, 0x24462 /* #161 'WKScriptMessage' => 'WebKit.WKScriptMessage, Xamarin.Mac' */ },
		{ NULL, 0x24762 /* #162 'WKScriptMessageHandler' => 'WebKit.WKScriptMessageHandler, Xamarin.Mac' */ },
		{ NULL, 0x24862 /* #163 'WKSecurityOrigin' => 'WebKit.WKSecurityOrigin, Xamarin.Mac' */ },
		{ NULL, 0x24A62 /* #164 'WKSnapshotConfiguration' => 'WebKit.WKSnapshotConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x24E62 /* #165 'WKUIDelegate' => 'WebKit.WKUIDelegate, Xamarin.Mac' */ },
		{ NULL, 0x25362 /* #166 'WKUserContentController' => 'WebKit.WKUserContentController, Xamarin.Mac' */ },
		{ NULL, 0x25462 /* #167 'WKUserScript' => 'WebKit.WKUserScript, Xamarin.Mac' */ },
		{ NULL, 0x25662 /* #168 'WKWebsiteDataRecord' => 'WebKit.WKWebsiteDataRecord, Xamarin.Mac' */ },
		{ NULL, 0x25A62 /* #169 'WKWebViewConfiguration' => 'WebKit.WKWebViewConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x25B62 /* #170 'WKWindowFeatures' => 'WebKit.WKWindowFeatures, Xamarin.Mac' */ },
		{ NULL, 0x29B62 /* #171 'VNObservation' => 'Vision.VNObservation, Xamarin.Mac' */ },
		{ NULL, 0x27962 /* #172 'VNDetectedObjectObservation' => 'Vision.VNDetectedObjectObservation, Xamarin.Mac' */ },
		{ NULL, 0x29F62 /* #173 'VNRectangleObservation' => 'Vision.VNRectangleObservation, Xamarin.Mac' */ },
		{ NULL, 0x26E62 /* #174 'VNBarcodeObservation' => 'Vision.VNBarcodeObservation, Xamarin.Mac' */ },
		{ NULL, 0x27262 /* #175 'VNClassificationObservation' => 'Vision.VNClassificationObservation, Xamarin.Mac' */ },
		{ NULL, 0x27362 /* #176 'VNCoreMLFeatureValueObservation' => 'Vision.VNCoreMLFeatureValueObservation, Xamarin.Mac' */ },
		{ NULL, 0x27462 /* #177 'VNCoreMLModel' => 'Vision.VNCoreMLModel, Xamarin.Mac' */ },
		{ NULL, 0x2A162 /* #178 'VNRequest' => 'Vision.VNRequest, Xamarin.Mac' */ },
		{ NULL, 0x29362 /* #179 'VNImageBasedRequest' => 'Vision.VNImageBasedRequest, Xamarin.Mac' */ },
		{ NULL, 0x27562 /* #180 'VNCoreMLRequest' => 'Vision.VNCoreMLRequest, Xamarin.Mac' */ },
		{ NULL, 0x27762 /* #181 'VNDetectBarcodesRequest' => 'Vision.VNDetectBarcodesRequest, Xamarin.Mac' */ },
		{ NULL, 0x27B62 /* #182 'VNDetectFaceLandmarksRequest' => 'Vision.VNDetectFaceLandmarksRequest, Xamarin.Mac' */ },
		{ NULL, 0x27D62 /* #183 'VNDetectFaceRectanglesRequest' => 'Vision.VNDetectFaceRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x27F62 /* #184 'VNDetectHorizonRequest' => 'Vision.VNDetectHorizonRequest, Xamarin.Mac' */ },
		{ NULL, 0x28162 /* #185 'VNDetectRectanglesRequest' => 'Vision.VNDetectRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x28362 /* #186 'VNDetectTextRectanglesRequest' => 'Vision.VNDetectTextRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x28762 /* #187 'VNFaceLandmarkRegion' => 'Vision.VNFaceLandmarkRegion, Xamarin.Mac' */ },
		{ NULL, 0x28862 /* #188 'VNFaceLandmarkRegion2D' => 'Vision.VNFaceLandmarkRegion2D, Xamarin.Mac' */ },
		{ NULL, 0x28962 /* #189 'VNFaceLandmarks' => 'Vision.VNFaceLandmarks, Xamarin.Mac' */ },
		{ NULL, 0x28A62 /* #190 'VNFaceLandmarks2D' => 'Vision.VNFaceLandmarks2D, Xamarin.Mac' */ },
		{ NULL, 0x28B62 /* #191 'VNFaceObservation' => 'Vision.VNFaceObservation, Xamarin.Mac' */ },
		{ NULL, 0x2A762 /* #192 'VNTargetedImageRequest' => 'Vision.VNTargetedImageRequest, Xamarin.Mac' */ },
		{ NULL, 0x29862 /* #193 'VNImageRegistrationRequest' => 'Vision.VNImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x28F62 /* #194 'VNHomographicImageRegistrationRequest' => 'Vision.VNHomographicImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x29162 /* #195 'VNHorizonObservation' => 'Vision.VNHorizonObservation, Xamarin.Mac' */ },
		{ NULL, 0x29262 /* #196 'VNImageAlignmentObservation' => 'Vision.VNImageAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x29562 /* #197 'VNImageHomographicAlignmentObservation' => 'Vision.VNImageHomographicAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x29962 /* #198 'VNImageRequestHandler' => 'Vision.VNImageRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0x29A62 /* #199 'VNImageTranslationAlignmentObservation' => 'Vision.VNImageTranslationAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x29C62 /* #200 'VNPixelBufferObservation' => 'Vision.VNPixelBufferObservation, Xamarin.Mac' */ },
		{ NULL, 0x29D62 /* #201 'VNRecognizedObjectObservation' => 'Vision.VNRecognizedObjectObservation, Xamarin.Mac' */ },
		{ NULL, 0x2A662 /* #202 'VNSequenceRequestHandler' => 'Vision.VNSequenceRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0x2A862 /* #203 'VNTextObservation' => 'Vision.VNTextObservation, Xamarin.Mac' */ },
		{ NULL, 0x2AA62 /* #204 'VNTrackingRequest' => 'Vision.VNTrackingRequest, Xamarin.Mac' */ },
		{ NULL, 0x2AB62 /* #205 'VNTrackObjectRequest' => 'Vision.VNTrackObjectRequest, Xamarin.Mac' */ },
		{ NULL, 0x2AD62 /* #206 'VNTrackRectangleRequest' => 'Vision.VNTrackRectangleRequest, Xamarin.Mac' */ },
		{ NULL, 0x2AF62 /* #207 'VNTranslationalImageRegistrationRequest' => 'Vision.VNTranslationalImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x2B562 /* #208 'SKDownload' => 'StoreKit.SKDownload, Xamarin.Mac' */ },
		{ NULL, 0x2BA62 /* #209 'SKPayment' => 'StoreKit.SKPayment, Xamarin.Mac' */ },
		{ NULL, 0x2B962 /* #210 'SKMutablePayment' => 'StoreKit.SKMutablePayment, Xamarin.Mac' */ },
		{ NULL, 0x2BB62 /* #211 'SKPaymentQueue' => 'StoreKit.SKPaymentQueue, Xamarin.Mac' */ },
		{ NULL, 0x2BC62 /* #212 'SKPaymentTransaction' => 'StoreKit.SKPaymentTransaction, Xamarin.Mac' */ },
		{ NULL, 0x2C062 /* #213 'SKPaymentTransactionObserver' => 'StoreKit.SKPaymentTransactionObserver, Xamarin.Mac' */ },
		{ NULL, 0x2C262 /* #214 'SKProduct' => 'StoreKit.SKProduct, Xamarin.Mac' */ },
		{ NULL, 0x2C362 /* #215 'SKProductDiscount' => 'StoreKit.SKProductDiscount, Xamarin.Mac' */ },
		{ NULL, 0x2D362 /* #216 'SKRequestDelegate' => 'StoreKit.SKRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x2CA62 /* #217 'SKProductsRequestDelegate' => 'StoreKit.SKProductsRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x2CB62 /* #218 'SKProductsResponse' => 'StoreKit.SKProductsResponse, Xamarin.Mac' */ },
		{ NULL, 0x2CC62 /* #219 'SKProductSubscriptionPeriod' => 'StoreKit.SKProductSubscriptionPeriod, Xamarin.Mac' */ },
		{ NULL, 0x2CE62 /* #220 'SKRequest' => 'StoreKit.SKRequest, Xamarin.Mac' */ },
		{ NULL, 0x2CD62 /* #221 'SKReceiptRefreshRequest' => 'StoreKit.SKReceiptRefreshRequest, Xamarin.Mac' */ },
		{ NULL, 0x2D462 /* #222 'SKStoreReviewController' => 'StoreKit.SKStoreReviewController, Xamarin.Mac' */ },
		{ NULL, 0x2EB62 /* #223 'SKNode' => 'SpriteKit.SKNode, Xamarin.Mac' */ },
		{ NULL, 0x2D662 /* #224 'SK3DNode' => 'SpriteKit.SK3DNode, Xamarin.Mac' */ },
		{ NULL, 0x2D762 /* #225 'SKAction' => 'SpriteKit.SKAction, Xamarin.Mac' */ },
		{ NULL, 0x2D962 /* #226 'SKAttribute' => 'SpriteKit.SKAttribute, Xamarin.Mac' */ },
		{ NULL, 0x2DB62 /* #227 'SKAttributeValue' => 'SpriteKit.SKAttributeValue, Xamarin.Mac' */ },
		{ NULL, 0x2DC62 /* #228 'SKAudioNode' => 'SpriteKit.SKAudioNode, Xamarin.Mac' */ },
		{ NULL, 0x2DE62 /* #229 'SKCameraNode' => 'SpriteKit.SKCameraNode, Xamarin.Mac' */ },
		{ NULL, 0x2DF62 /* #230 'SKConstraint' => 'SpriteKit.SKConstraint, Xamarin.Mac' */ },
		{ NULL, 0x2E062 /* #231 'SKCropNode' => 'SpriteKit.SKCropNode, Xamarin.Mac' */ },
		{ NULL, 0x2E162 /* #232 'SKEffectNode' => 'SpriteKit.SKEffectNode, Xamarin.Mac' */ },
		{ NULL, 0x2E262 /* #233 'SKEmitterNode' => 'SpriteKit.SKEmitterNode, Xamarin.Mac' */ },
		{ NULL, 0x2E362 /* #234 'SKFieldNode' => 'SpriteKit.SKFieldNode, Xamarin.Mac' */ },
		{ NULL, 0x2E562 /* #235 'SKKeyframeSequence' => 'SpriteKit.SKKeyframeSequence, Xamarin.Mac' */ },
		{ NULL, 0x2E762 /* #236 'SKLabelNode' => 'SpriteKit.SKLabelNode, Xamarin.Mac' */ },
		{ NULL, 0x2E962 /* #237 'SKLightNode' => 'SpriteKit.SKLightNode, Xamarin.Mac' */ },
		{ NULL, 0x30A62 /* #238 'SKTexture' => 'SpriteKit.SKTexture, Xamarin.Mac' */ },
		{ NULL, 0x2EA62 /* #239 'SKMutableTexture' => 'SpriteKit.SKMutableTexture, Xamarin.Mac' */ },
		{ NULL, 0x2EE62 /* #240 'SKPhysicsBody' => 'SpriteKit.SKPhysicsBody, Xamarin.Mac' */ },
		{ NULL, 0x2EF62 /* #241 'SKPhysicsContact' => 'SpriteKit.SKPhysicsContact, Xamarin.Mac' */ },
		{ NULL, 0x2F362 /* #242 'SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x2F462 /* #243 'SKPhysicsJoint' => 'SpriteKit.SKPhysicsJoint, Xamarin.Mac' */ },
		{ NULL, 0x2F562 /* #244 'SKPhysicsJointFixed' => 'SpriteKit.SKPhysicsJointFixed, Xamarin.Mac' */ },
		{ NULL, 0x2F662 /* #245 'SKPhysicsJointLimit' => 'SpriteKit.SKPhysicsJointLimit, Xamarin.Mac' */ },
		{ NULL, 0x2F762 /* #246 'SKPhysicsJointPin' => 'SpriteKit.SKPhysicsJointPin, Xamarin.Mac' */ },
		{ NULL, 0x2F862 /* #247 'SKPhysicsJointSliding' => 'SpriteKit.SKPhysicsJointSliding, Xamarin.Mac' */ },
		{ NULL, 0x2F962 /* #248 'SKPhysicsJointSpring' => 'SpriteKit.SKPhysicsJointSpring, Xamarin.Mac' */ },
		{ NULL, 0x2FB62 /* #249 'SKRange' => 'SpriteKit.SKRange, Xamarin.Mac' */ },
		{ NULL, 0x2FC62 /* #250 'SKReachConstraints' => 'SpriteKit.SKReachConstraints, Xamarin.Mac' */ },
		{ NULL, 0x2FD62 /* #251 'SKReferenceNode' => 'SpriteKit.SKReferenceNode, Xamarin.Mac' */ },
		{ NULL, 0x2FE62 /* #252 'SKRegion' => 'SpriteKit.SKRegion, Xamarin.Mac' */ },
		{ NULL, 0x2FF62 /* #253 'SKRenderer' => 'SpriteKit.SKRenderer, Xamarin.Mac' */ },
		{ NULL, 0x30162 /* #254 'SKScene' => 'SpriteKit.SKScene, Xamarin.Mac' */ },
		{ NULL, 0x30562 /* #255 'SKSceneDelegate' => 'SpriteKit.SKSceneDelegate, Xamarin.Mac' */ },
		{ NULL, 0x30762 /* #256 'SKShader' => 'SpriteKit.SKShader, Xamarin.Mac' */ },
		{ NULL, 0x30862 /* #257 'SKShapeNode' => 'SpriteKit.SKShapeNode, Xamarin.Mac' */ },
		{ NULL, 0x30962 /* #258 'SKSpriteNode' => 'SpriteKit.SKSpriteNode, Xamarin.Mac' */ },
		{ NULL, 0x30F62 /* #259 'SKTileDefinition' => 'SpriteKit.SKTileDefinition, Xamarin.Mac' */ },
		{ NULL, 0x31162 /* #260 'SKTileGroup' => 'SpriteKit.SKTileGroup, Xamarin.Mac' */ },
		{ NULL, 0x31262 /* #261 'SKTileGroupRule' => 'SpriteKit.SKTileGroupRule, Xamarin.Mac' */ },
		{ NULL, 0x31362 /* #262 'SKTileMapNode' => 'SpriteKit.SKTileMapNode, Xamarin.Mac' */ },
		{ NULL, 0x31462 /* #263 'SKTileSet' => 'SpriteKit.SKTileSet, Xamarin.Mac' */ },
		{ NULL, 0x31662 /* #264 'SKTransformNode' => 'SpriteKit.SKTransformNode, Xamarin.Mac' */ },
		{ NULL, 0x31762 /* #265 'SKTransition' => 'SpriteKit.SKTransition, Xamarin.Mac' */ },
		{ NULL, 0x31962 /* #266 'SKUniform' => 'SpriteKit.SKUniform, Xamarin.Mac' */ },
		{ NULL, 0x31B62 /* #267 'SKVideoNode' => 'SpriteKit.SKVideoNode, Xamarin.Mac' */ },
		{ NULL, 0x31C62 /* #268 'SKView' => 'SpriteKit.SKView, Xamarin.Mac' */ },
		{ NULL, 0x32062 /* #269 'SKViewDelegate' => 'SpriteKit.SKViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x32362 /* #270 'SKWarpGeometry' => 'SpriteKit.SKWarpGeometry, Xamarin.Mac' */ },
		{ NULL, 0x32462 /* #271 'SKWarpGeometryGrid' => 'SpriteKit.SKWarpGeometryGrid, Xamarin.Mac' */ },
		{ NULL, 0x14FC62 /* #272 'NSViewController' => 'AppKit.NSViewController, Xamarin.Mac' */ },
		{ NULL, 0x32E62 /* #273 'SLComposeServiceViewController' => 'Social.SLComposeServiceViewController, Xamarin.Mac' */ },
		{ NULL, 0x39862 /* #274 'SBApplicationDelegate' => 'ScriptingBridge.SBApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x16E662 /* #275 'NSArray' => 'Foundation.NSArray, Xamarin.Mac' */ },
		{ NULL, 0x177062 /* #276 'NSMutableArray' => 'Foundation.NSMutableArray, Xamarin.Mac' */ },
		{ NULL, 0x39962 /* #277 'SBElementArray' => 'ScriptingBridge.SBElementArray, Xamarin.Mac' */ },
		{ NULL, 0x39A62 /* #278 'SBObject' => 'ScriptingBridge.SBObject, Xamarin.Mac' */ },
		{ NULL, 0x3CF62 /* #279 'SCNConstraint' => 'SceneKit.SCNConstraint, Xamarin.Mac' */ },
		{ NULL, 0x39F62 /* #280 'SCNAccelerationConstraint' => 'SceneKit.SCNAccelerationConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3A062 /* #281 'SCNAction' => 'SceneKit.SCNAction, Xamarin.Mac' */ },
		{ NULL, 0x3A462 /* #282 'SCNActionable' => 'SceneKit.SCNActionable, Xamarin.Mac' */ },
		{ NULL, 0x3A962 /* #283 'SCNAnimatable' => 'SceneKit.SCNAnimatable, Xamarin.Mac' */ },
		{ NULL, 0x3AA62 /* #284 'SCNAnimation' => 'SceneKit.SCNAnimation, Xamarin.Mac' */ },
		{ NULL, 0x3AD62 /* #285 'SCNAnimationPlayer' => 'SceneKit.SCNAnimationPlayer, Xamarin.Mac' */ },
		{ NULL, 0x3B162 /* #286 'SCNAudioPlayer' => 'SceneKit.SCNAudioPlayer, Xamarin.Mac' */ },
		{ NULL, 0x3B262 /* #287 'SCNAudioSource' => 'SceneKit.SCNAudioSource, Xamarin.Mac' */ },
		{ NULL, 0x3B362 /* #288 'SCNAvoidOccluderConstraint' => 'SceneKit.SCNAvoidOccluderConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3B762 /* #289 'SCNAvoidOccluderConstraintDelegate' => 'SceneKit.SCNAvoidOccluderConstraintDelegate, Xamarin.Mac' */ },
		{ NULL, 0x3B962 /* #290 'SCNBillboardConstraint' => 'SceneKit.SCNBillboardConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3BD62 /* #291 'SCNBoundingVolume' => 'SceneKit.SCNBoundingVolume, Xamarin.Mac' */ },
		{ NULL, 0x3D962 /* #292 'SCNGeometry' => 'SceneKit.SCNGeometry, Xamarin.Mac' */ },
		{ NULL, 0x3BE62 /* #293 'SCNBox' => 'SceneKit.SCNBox, Xamarin.Mac' */ },
		{ NULL, 0x3C262 /* #294 'SCNCamera' => 'SceneKit.SCNCamera, Xamarin.Mac' */ },
		{ NULL, 0x3C562 /* #295 'SCNCameraController' => 'SceneKit.SCNCameraController, Xamarin.Mac' */ },
		{ NULL, 0x3C962 /* #296 'SCNCameraControllerDelegate' => 'SceneKit.SCNCameraControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x3CB62 /* #297 'SCNCapsule' => 'SceneKit.SCNCapsule, Xamarin.Mac' */ },
		{ NULL, 0x3CE62 /* #298 'SCNCone' => 'SceneKit.SCNCone, Xamarin.Mac' */ },
		{ NULL, 0x3D162 /* #299 'SCNCylinder' => 'SceneKit.SCNCylinder, Xamarin.Mac' */ },
		{ NULL, 0x3D362 /* #300 'SCNDistanceConstraint' => 'SceneKit.SCNDistanceConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3D862 /* #301 'SCNFloor' => 'SceneKit.SCNFloor, Xamarin.Mac' */ },
		{ NULL, 0x3DA62 /* #302 'SCNGeometryElement' => 'SceneKit.SCNGeometryElement, Xamarin.Mac' */ },
		{ NULL, 0x3DC62 /* #303 'SCNGeometrySource' => 'SceneKit.SCNGeometrySource, Xamarin.Mac' */ },
		{ NULL, 0x3DF62 /* #304 'SCNGeometryTessellator' => 'SceneKit.SCNGeometryTessellator, Xamarin.Mac' */ },
		{ NULL, 0x3E262 /* #305 'SCNHitTestResult' => 'SceneKit.SCNHitTestResult, Xamarin.Mac' */ },
		{ NULL, 0x3E462 /* #306 'SCNIKConstraint' => 'SceneKit.SCNIKConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3E762 /* #307 'SCNLevelOfDetail' => 'SceneKit.SCNLevelOfDetail, Xamarin.Mac' */ },
		{ NULL, 0x3E862 /* #308 'SCNLight' => 'SceneKit.SCNLight, Xamarin.Mac' */ },
		{ NULL, 0x3EC62 /* #309 'SCNLookAtConstraint' => 'SceneKit.SCNLookAtConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3ED62 /* #310 'SCNMaterial' => 'SceneKit.SCNMaterial, Xamarin.Mac' */ },
		{ NULL, 0x3EE62 /* #311 'SCNMaterialProperty' => 'SceneKit.SCNMaterialProperty, Xamarin.Mac' */ },
		{ NULL, 0x3EF62 /* #312 'SCNMorpher' => 'SceneKit.SCNMorpher, Xamarin.Mac' */ },
		{ NULL, 0x3F762 /* #313 'SCNNodeRendererDelegate' => 'SceneKit.SCNNodeRendererDelegate, Xamarin.Mac' */ },
		{ NULL, 0x40162 /* #314 'SCNParticlePropertyController' => 'SceneKit.SCNParticlePropertyController, Xamarin.Mac' */ },
		{ NULL, 0x40362 /* #315 'SCNParticleSystem' => 'SceneKit.SCNParticleSystem, Xamarin.Mac' */ },
		{ NULL, 0x40562 /* #316 'SCNPhysicsBehavior' => 'SceneKit.SCNPhysicsBehavior, Xamarin.Mac' */ },
		{ NULL, 0x40462 /* #317 'SCNPhysicsBallSocketJoint' => 'SceneKit.SCNPhysicsBallSocketJoint, Xamarin.Mac' */ },
		{ NULL, 0x40662 /* #318 'SCNPhysicsBody' => 'SceneKit.SCNPhysicsBody, Xamarin.Mac' */ },
		{ NULL, 0x40962 /* #319 'SCNPhysicsConeTwistJoint' => 'SceneKit.SCNPhysicsConeTwistJoint, Xamarin.Mac' */ },
		{ NULL, 0x40A62 /* #320 'SCNPhysicsContact' => 'SceneKit.SCNPhysicsContact, Xamarin.Mac' */ },
		{ NULL, 0x40E62 /* #321 'SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x40F62 /* #322 'SCNPhysicsField' => 'SceneKit.SCNPhysicsField, Xamarin.Mac' */ },
		{ NULL, 0x41162 /* #323 'SCNPhysicsHingeJoint' => 'SceneKit.SCNPhysicsHingeJoint, Xamarin.Mac' */ },
		{ NULL, 0x41362 /* #324 'SCNPhysicsShape' => 'SceneKit.SCNPhysicsShape, Xamarin.Mac' */ },
		{ NULL, 0x41662 /* #325 'SCNPhysicsSliderJoint' => 'SceneKit.SCNPhysicsSliderJoint, Xamarin.Mac' */ },
		{ NULL, 0x41A62 /* #326 'SCNPhysicsVehicle' => 'SceneKit.SCNPhysicsVehicle, Xamarin.Mac' */ },
		{ NULL, 0x41B62 /* #327 'SCNPhysicsVehicleWheel' => 'SceneKit.SCNPhysicsVehicleWheel, Xamarin.Mac' */ },
		{ NULL, 0x41E62 /* #328 'SCNPlane' => 'SceneKit.SCNPlane, Xamarin.Mac' */ },
		{ NULL, 0x41F62 /* #329 'SCNProgram' => 'SceneKit.SCNProgram, Xamarin.Mac' */ },
		{ NULL, 0x42362 /* #330 'SCNProgramDelegate' => 'SceneKit.SCNProgramDelegate, Xamarin.Mac' */ },
		{ NULL, 0x42562 /* #331 'SCNPyramid' => 'SceneKit.SCNPyramid, Xamarin.Mac' */ },
		{ NULL, 0x3F262 /* #332 'SCNNode' => 'SceneKit.SCNNode, Xamarin.Mac' */ },
		{ NULL, 0x42762 /* #333 'SCNReferenceNode' => 'SceneKit.SCNReferenceNode, Xamarin.Mac' */ },
		{ NULL, 0x42D62 /* #334 'SCNReplicatorConstraint' => 'SceneKit.SCNReplicatorConstraint, Xamarin.Mac' */ },
		{ NULL, 0x42E62 /* #335 'SCNScene' => 'SceneKit.SCNScene, Xamarin.Mac' */ },
		{ NULL, 0x43262 /* #336 'SCNSceneExportDelegate' => 'SceneKit.SCNSceneExportDelegate, Xamarin.Mac' */ },
		{ NULL, 0x43762 /* #337 'SCNSceneRenderer' => 'SceneKit.SCNSceneRenderer, Xamarin.Mac' */ },
		{ NULL, 0x43B62 /* #338 'SCNSceneRendererDelegate' => 'SceneKit.SCNSceneRendererDelegate, Xamarin.Mac' */ },
		{ NULL, 0x43C62 /* #339 'SCNSceneSource' => 'SceneKit.SCNSceneSource, Xamarin.Mac' */ },
		{ NULL, 0x44462 /* #340 'SCNShadable' => 'SceneKit.SCNShadable, Xamarin.Mac' */ },
		{ NULL, 0x44762 /* #341 'SCNShape' => 'SceneKit.SCNShape, Xamarin.Mac' */ },
		{ NULL, 0x44862 /* #342 'SCNSkinner' => 'SceneKit.SCNSkinner, Xamarin.Mac' */ },
		{ NULL, 0x44962 /* #343 'SCNSliderConstraint' => 'SceneKit.SCNSliderConstraint, Xamarin.Mac' */ },
		{ NULL, 0x44A62 /* #344 'SCNSphere' => 'SceneKit.SCNSphere, Xamarin.Mac' */ },
		{ NULL, 0x44B62 /* #345 'SCNTechnique' => 'SceneKit.SCNTechnique, Xamarin.Mac' */ },
		{ NULL, 0x44E62 /* #346 'SCNTechniqueSupport' => 'SceneKit.SCNTechniqueSupport, Xamarin.Mac' */ },
		{ NULL, 0x45062 /* #347 'SCNText' => 'SceneKit.SCNText, Xamarin.Mac' */ },
		{ NULL, 0x45162 /* #348 'SCNTimingFunction' => 'SceneKit.SCNTimingFunction, Xamarin.Mac' */ },
		{ NULL, 0x45262 /* #349 'SCNTorus' => 'SceneKit.SCNTorus, Xamarin.Mac' */ },
		{ NULL, 0x45362 /* #350 'SCNTransaction' => 'SceneKit.SCNTransaction, Xamarin.Mac' */ },
		{ NULL, 0x45462 /* #351 'SCNTransformConstraint' => 'SceneKit.SCNTransformConstraint, Xamarin.Mac' */ },
		{ NULL, 0x45662 /* #352 'SCNTube' => 'SceneKit.SCNTube, Xamarin.Mac' */ },
		{ NULL, 0x47262 /* #353 'SFContentBlockerState' => 'SafariServices.SFContentBlockerState, Xamarin.Mac' */ },
		{ NULL, 0x47C62 /* #354 'SFSafariExtensionViewController' => 'SafariServices.SFSafariExtensionViewController, Xamarin.Mac' */ },
		{ NULL, 0x47E62 /* #355 'SFSafariPageProperties' => 'SafariServices.SFSafariPageProperties, Xamarin.Mac' */ },
		{ NULL, 0x48162 /* #356 'SFSafariToolbarItem' => 'SafariServices.SFSafariToolbarItem, Xamarin.Mac' */ },
		{ NULL, 0x48962 /* #357 'QLPreviewItem' => 'QuickLookUI.QLPreviewItem, Xamarin.Mac' */ },
		{ NULL, 0x150362 /* #358 'NSWindow' => 'AppKit.NSWindow, Xamarin.Mac' */ },
		{ NULL, 0x13B062 /* #359 'NSPanel' => 'AppKit.NSPanel, Xamarin.Mac' */ },
		{ NULL, 0x48A62 /* #360 'QLPreviewPanel' => 'QuickLookUI.QLPreviewPanel, Xamarin.Mac' */ },
		{ NULL, 0x48E62 /* #361 'QLPreviewPanelDataSource' => 'QuickLookUI.QLPreviewPanelDataSource, Xamarin.Mac' */ },
		{ NULL, 0x49262 /* #362 'QLPreviewPanelDelegate' => 'QuickLookUI.QLPreviewPanelDelegate, Xamarin.Mac' */ },
		{ NULL, 0x49362 /* #363 'QLPreviewView' => 'QuickLookUI.QLPreviewView, Xamarin.Mac' */ },
		{ NULL, 0x49662 /* #364 'QCComposition' => 'QuartzComposer.QCComposition, Xamarin.Mac' */ },
		{ NULL, 0xF5F62 /* #365 'CALayer' => 'CoreAnimation.CALayer, Xamarin.Mac' */ },
		{ NULL, 0xF6B62 /* #366 'CAOpenGLLayer' => 'CoreAnimation.CAOpenGLLayer, Xamarin.Mac' */ },
		{ NULL, 0x49762 /* #367 'QCCompositionLayer' => 'QuartzComposer.QCCompositionLayer, Xamarin.Mac' */ },
		{ NULL, 0x49862 /* #368 'QCCompositionRepository' => 'QuartzComposer.QCCompositionRepository, Xamarin.Mac' */ },
		{ NULL, 0x4D662 /* #369 'PHLivePhotoView' => 'PhotosUI.PHLivePhotoView, Xamarin.Mac' */ },
		{ NULL, 0x4DB62 /* #370 'PHLivePhotoViewDelegate' => 'PhotosUI.PHLivePhotoViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x4E062 /* #371 'PHProjectElement' => 'PhotosUI.PHProjectElement, Xamarin.Mac' */ },
		{ NULL, 0x4DD62 /* #372 'PHProjectAssetElement' => 'PhotosUI.PHProjectAssetElement, Xamarin.Mac' */ },
		{ NULL, 0x171C62 /* #373 'NSExtensionContext' => 'Foundation.NSExtensionContext, Xamarin.Mac' */ },
		{ NULL, 0x4E162 /* #374 'PHProjectExtensionContext' => 'PhotosUI.PHProjectExtensionContext, Xamarin.Mac' */ },
		{ NULL, 0x4E562 /* #375 'PHProjectInfo' => 'PhotosUI.PHProjectInfo, Xamarin.Mac' */ },
		{ NULL, 0x4E662 /* #376 'PHProjectJournalEntryElement' => 'PhotosUI.PHProjectJournalEntryElement, Xamarin.Mac' */ },
		{ NULL, 0x4E762 /* #377 'PHProjectMapElement' => 'PhotosUI.PHProjectMapElement, Xamarin.Mac' */ },
		{ NULL, 0x4E862 /* #378 'PHProjectRegionOfInterest' => 'PhotosUI.PHProjectRegionOfInterest, Xamarin.Mac' */ },
		{ NULL, 0x4E962 /* #379 'PHProjectSection' => 'PhotosUI.PHProjectSection, Xamarin.Mac' */ },
		{ NULL, 0x4EA62 /* #380 'PHProjectSectionContent' => 'PhotosUI.PHProjectSectionContent, Xamarin.Mac' */ },
		{ NULL, 0x4EB62 /* #381 'PHProjectTextElement' => 'PhotosUI.PHProjectTextElement, Xamarin.Mac' */ },
		{ NULL, 0x4ED62 /* #382 'PHProjectTypeDescription' => 'PhotosUI.PHProjectTypeDescription, Xamarin.Mac' */ },
		{ NULL, 0x4F162 /* #383 'PHProjectTypeDescriptionDataSource' => 'PhotosUI.PHProjectTypeDescriptionDataSource, Xamarin.Mac' */ },
		{ NULL, 0x4F562 /* #384 'PHAdjustmentData' => 'Photos.PHAdjustmentData, Xamarin.Mac' */ },
		{ NULL, 0x51E62 /* #385 'PHObject' => 'Photos.PHObject, Xamarin.Mac' */ },
		{ NULL, 0x4F662 /* #386 'PHAsset' => 'Photos.PHAsset, Xamarin.Mac' */ },
		{ NULL, 0x50462 /* #387 'PHCollection' => 'Photos.PHCollection, Xamarin.Mac' */ },
		{ NULL, 0x4F862 /* #388 'PHAssetCollection' => 'Photos.PHAssetCollection, Xamarin.Mac' */ },
		{ NULL, 0x50262 /* #389 'PHChange' => 'Photos.PHChange, Xamarin.Mac' */ },
		{ NULL, 0x50362 /* #390 'PHCloudIdentifier' => 'Photos.PHCloudIdentifier, Xamarin.Mac' */ },
		{ NULL, 0x50662 /* #391 'PHCollectionList' => 'Photos.PHCollectionList, Xamarin.Mac' */ },
		{ NULL, 0x50962 /* #392 'PHContentEditingInput' => 'Photos.PHContentEditingInput, Xamarin.Mac' */ },
		{ NULL, 0x50A62 /* #393 'PHContentEditingOutput' => 'Photos.PHContentEditingOutput, Xamarin.Mac' */ },
		{ NULL, 0x50B62 /* #394 'PHFetchOptions' => 'Photos.PHFetchOptions, Xamarin.Mac' */ },
		{ NULL, 0x50C62 /* #395 'PHFetchResult' => 'Photos.PHFetchResult, Xamarin.Mac' */ },
		{ NULL, 0x50D62 /* #396 'PHFetchResultChangeDetails' => 'Photos.PHFetchResultChangeDetails, Xamarin.Mac' */ },
		{ NULL, 0x51062 /* #397 'PHImageManager' => 'Photos.PHImageManager, Xamarin.Mac' */ },
		{ NULL, 0x51162 /* #398 'PHImageRequestOptions' => 'Photos.PHImageRequestOptions, Xamarin.Mac' */ },
		{ NULL, 0x51562 /* #399 'PHLivePhoto' => 'Photos.PHLivePhoto, Xamarin.Mac' */ },
		{ NULL, 0x51F62 /* #400 'PHObjectChangeDetails' => 'Photos.PHObjectChangeDetails, Xamarin.Mac' */ },
		{ NULL, 0x52462 /* #401 'PHPhotoLibraryChangeObserver' => 'Photos.PHPhotoLibraryChangeObserver, Xamarin.Mac' */ },
		{ NULL, 0x52562 /* #402 'PHProject' => 'Photos.PHProject, Xamarin.Mac' */ },
		{ NULL, 0x52662 /* #403 'PHProjectChangeRequest' => 'Photos.PHProjectChangeRequest, Xamarin.Mac' */ },
		{ NULL, 0x58362 /* #404 'PDFAction' => 'PdfKit.PdfAction, Xamarin.Mac' */ },
		{ NULL, 0x58462 /* #405 'PDFActionGoTo' => 'PdfKit.PdfActionGoTo, Xamarin.Mac' */ },
		{ NULL, 0x58562 /* #406 'PDFActionNamed' => 'PdfKit.PdfActionNamed, Xamarin.Mac' */ },
		{ NULL, 0x58762 /* #407 'PDFActionRemoteGoTo' => 'PdfKit.PdfActionRemoteGoTo, Xamarin.Mac' */ },
		{ NULL, 0x58862 /* #408 'PDFActionResetForm' => 'PdfKit.PdfActionResetForm, Xamarin.Mac' */ },
		{ NULL, 0x58962 /* #409 'PDFActionURL' => 'PdfKit.PdfActionUrl, Xamarin.Mac' */ },
		{ NULL, 0x58A62 /* #410 'PDFAnnotation' => 'PdfKit.PdfAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x58B62 /* #411 'PDFAnnotationButtonWidget' => 'PdfKit.PdfAnnotationButtonWidget, Xamarin.Mac' */ },
		{ NULL, 0x58C62 /* #412 'PDFAnnotationChoiceWidget' => 'PdfKit.PdfAnnotationChoiceWidget, Xamarin.Mac' */ },
		{ NULL, 0x58D62 /* #413 'PDFAnnotationCircle' => 'PdfKit.PdfAnnotationCircle, Xamarin.Mac' */ },
		{ NULL, 0x58E62 /* #414 'PDFAnnotationFreeText' => 'PdfKit.PdfAnnotationFreeText, Xamarin.Mac' */ },
		{ NULL, 0x59162 /* #415 'PDFAnnotationInk' => 'PdfKit.PdfAnnotationInk, Xamarin.Mac' */ },
		{ NULL, 0x59462 /* #416 'PDFAnnotationLine' => 'PdfKit.PdfAnnotationLine, Xamarin.Mac' */ },
		{ NULL, 0x59762 /* #417 'PDFAnnotationLink' => 'PdfKit.PdfAnnotationLink, Xamarin.Mac' */ },
		{ NULL, 0x59862 /* #418 'PDFAnnotationMarkup' => 'PdfKit.PdfAnnotationMarkup, Xamarin.Mac' */ },
		{ NULL, 0x59962 /* #419 'PDFAnnotationPopup' => 'PdfKit.PdfAnnotationPopup, Xamarin.Mac' */ },
		{ NULL, 0x59A62 /* #420 'PDFAnnotationSquare' => 'PdfKit.PdfAnnotationSquare, Xamarin.Mac' */ },
		{ NULL, 0x59B62 /* #421 'PDFAnnotationStamp' => 'PdfKit.PdfAnnotationStamp, Xamarin.Mac' */ },
		{ NULL, 0x59E62 /* #422 'PDFAnnotationText' => 'PdfKit.PdfAnnotationText, Xamarin.Mac' */ },
		{ NULL, 0x5A162 /* #423 'PDFAnnotationTextWidget' => 'PdfKit.PdfAnnotationTextWidget, Xamarin.Mac' */ },
		{ NULL, 0x5A462 /* #424 'PDFAppearanceCharacteristics' => 'PdfKit.PdfAppearanceCharacteristics, Xamarin.Mac' */ },
		{ NULL, 0x5A762 /* #425 'PDFBorder' => 'PdfKit.PdfBorder, Xamarin.Mac' */ },
		{ NULL, 0x5AA62 /* #426 'PDFDestination' => 'PdfKit.PdfDestination, Xamarin.Mac' */ },
		{ NULL, 0x5B462 /* #427 'PDFDocumentDelegate' => 'PdfKit.PdfDocumentDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5BB62 /* #428 'PDFOutline' => 'PdfKit.PdfOutline, Xamarin.Mac' */ },
		{ NULL, 0x5BC62 /* #429 'PDFPage' => 'PdfKit.PdfPage, Xamarin.Mac' */ },
		{ NULL, 0x5BE62 /* #430 'PDFSelection' => 'PdfKit.PdfSelection, Xamarin.Mac' */ },
		{ NULL, 0x5C762 /* #431 'PDFViewDelegate' => 'PdfKit.PdfViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5CF62 /* #432 'NCWidgetController' => 'NotificationCenter.NCWidgetController, Xamarin.Mac' */ },
		{ NULL, 0x5D662 /* #433 'NCWidgetListViewDelegate' => 'NotificationCenter.NCWidgetListViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5DA62 /* #434 'NCWidgetProviding' => 'NotificationCenter.NCWidgetProviding, Xamarin.Mac' */ },
		{ NULL, 0x5E062 /* #435 'NCWidgetSearchViewDelegate' => 'NotificationCenter.NCWidgetSearchViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5EC62 /* #436 'NEAppRule' => 'NetworkExtension.NEAppRule, Xamarin.Mac' */ },
		{ NULL, 0x61F62 /* #437 'NEVPNProtocol' => 'NetworkExtension.NEVpnProtocol, Xamarin.Mac' */ },
		{ NULL, 0x5ED62 /* #438 'NEDNSProxyProviderProtocol' => 'NetworkExtension.NEDnsProxyProviderProtocol, Xamarin.Mac' */ },
		{ NULL, 0x5EE62 /* #439 'NEDNSSettings' => 'NetworkExtension.NEDnsSettings, Xamarin.Mac' */ },
		{ NULL, 0x5EF62 /* #440 'NEEvaluateConnectionRule' => 'NetworkExtension.NEEvaluateConnectionRule, Xamarin.Mac' */ },
		{ NULL, 0x5F562 /* #441 'NEFilterProviderConfiguration' => 'NetworkExtension.NEFilterProviderConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x5F662 /* #442 'NEFlowMetaData' => 'NetworkExtension.NEFlowMetaData, Xamarin.Mac' */ },
		{ NULL, 0x5F762 /* #443 'NEIPv4Route' => 'NetworkExtension.NEIPv4Route, Xamarin.Mac' */ },
		{ NULL, 0x5F862 /* #444 'NEIPv4Settings' => 'NetworkExtension.NEIPv4Settings, Xamarin.Mac' */ },
		{ NULL, 0x5F962 /* #445 'NEIPv6Route' => 'NetworkExtension.NEIPv6Route, Xamarin.Mac' */ },
		{ NULL, 0x5FA62 /* #446 'NEIPv6Settings' => 'NetworkExtension.NEIPv6Settings, Xamarin.Mac' */ },
		{ NULL, 0x5FB62 /* #447 'NEOnDemandRule' => 'NetworkExtension.NEOnDemandRule, Xamarin.Mac' */ },
		{ NULL, 0x5FD62 /* #448 'NEOnDemandRuleConnect' => 'NetworkExtension.NEOnDemandRuleConnect, Xamarin.Mac' */ },
		{ NULL, 0x5FE62 /* #449 'NEOnDemandRuleDisconnect' => 'NetworkExtension.NEOnDemandRuleDisconnect, Xamarin.Mac' */ },
		{ NULL, 0x5FF62 /* #450 'NEOnDemandRuleEvaluateConnection' => 'NetworkExtension.NEOnDemandRuleEvaluateConnection, Xamarin.Mac' */ },
		{ NULL, 0x60062 /* #451 'NEOnDemandRuleIgnore' => 'NetworkExtension.NEOnDemandRuleIgnore, Xamarin.Mac' */ },
		{ NULL, 0x60262 /* #452 'NEPacket' => 'NetworkExtension.NEPacket, Xamarin.Mac' */ },
		{ NULL, 0x60A62 /* #453 'NETunnelNetworkSettings' => 'NetworkExtension.NETunnelNetworkSettings, Xamarin.Mac' */ },
		{ NULL, 0x60462 /* #454 'NEPacketTunnelNetworkSettings' => 'NetworkExtension.NEPacketTunnelNetworkSettings, Xamarin.Mac' */ },
		{ NULL, 0x60862 /* #455 'NEProxyServer' => 'NetworkExtension.NEProxyServer, Xamarin.Mac' */ },
		{ NULL, 0x60962 /* #456 'NEProxySettings' => 'NetworkExtension.NEProxySettings, Xamarin.Mac' */ },
		{ NULL, 0x60F62 /* #457 'NETunnelProviderProtocol' => 'NetworkExtension.NETunnelProviderProtocol, Xamarin.Mac' */ },
		{ NULL, 0x61262 /* #458 'NEVPNConnection' => 'NetworkExtension.NEVpnConnection, Xamarin.Mac' */ },
		{ NULL, 0x61162 /* #459 'NETunnelProviderSession' => 'NetworkExtension.NETunnelProviderSession, Xamarin.Mac' */ },
		{ NULL, 0x61B62 /* #460 'NEVPNIKEv2SecurityAssociationParameters' => 'NetworkExtension.NEVpnIke2SecurityAssociationParameters, Xamarin.Mac' */ },
		{ NULL, 0x62162 /* #461 'NEVPNProtocolIPSec' => 'NetworkExtension.NEVpnProtocolIpSec, Xamarin.Mac' */ },
		{ NULL, 0x62062 /* #462 'NEVPNProtocolIKEv2' => 'NetworkExtension.NEVpnProtocolIke2, Xamarin.Mac' */ },
		{ NULL, 0x62462 /* #463 'NWEndpoint' => 'NetworkExtension.NWEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x62362 /* #464 'NWBonjourServiceEndpoint' => 'NetworkExtension.NWBonjourServiceEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x62562 /* #465 'NWHostEndpoint' => 'NetworkExtension.NWHostEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x62662 /* #466 'NWPath' => 'NetworkExtension.NWPath, Xamarin.Mac' */ },
		{ NULL, 0x62C62 /* #467 'NWTCPConnectionAuthenticationDelegate' => 'NetworkExtension.NWTcpConnectionAuthenticationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x62E62 /* #468 'NWTLSParameters' => 'NetworkExtension.NWTlsParameters, Xamarin.Mac' */ },
		{ NULL, 0x65662 /* #469 'NLModel' => 'NaturalLanguage.NLModel, Xamarin.Mac' */ },
		{ NULL, 0x65762 /* #470 'NLModelConfiguration' => 'NaturalLanguage.NLModelConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x65E62 /* #471 'NLTokenizer' => 'NaturalLanguage.NLTokenizer, Xamarin.Mac' */ },
		{ NULL, 0x66362 /* #472 'MCAdvertiserAssistant' => 'MultipeerConnectivity.MCAdvertiserAssistant, Xamarin.Mac' */ },
		{ NULL, 0x66762 /* #473 'MCAdvertiserAssistantDelegate' => 'MultipeerConnectivity.MCAdvertiserAssistantDelegate, Xamarin.Mac' */ },
		{ NULL, 0x66862 /* #474 'MCBrowserViewController' => 'MultipeerConnectivity.MCBrowserViewController, Xamarin.Mac' */ },
		{ NULL, 0x66C62 /* #475 'MCBrowserViewControllerDelegate' => 'MultipeerConnectivity.MCBrowserViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x67062 /* #476 'MCNearbyServiceAdvertiser' => 'MultipeerConnectivity.MCNearbyServiceAdvertiser, Xamarin.Mac' */ },
		{ NULL, 0x67462 /* #477 'MCNearbyServiceAdvertiserDelegate' => 'MultipeerConnectivity.MCNearbyServiceAdvertiserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x67562 /* #478 'MCNearbyServiceBrowser' => 'MultipeerConnectivity.MCNearbyServiceBrowser, Xamarin.Mac' */ },
		{ NULL, 0x67962 /* #479 'MCNearbyServiceBrowserDelegate' => 'MultipeerConnectivity.MCNearbyServiceBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x67A62 /* #480 'MCPeerID' => 'MultipeerConnectivity.MCPeerID, Xamarin.Mac' */ },
		{ NULL, 0x67F62 /* #481 'MCSessionDelegate' => 'MultipeerConnectivity.MCSessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x68862 /* #482 'MDLAnimatedValue' => 'ModelIO.MDLAnimatedValue, Xamarin.Mac' */ },
		{ NULL, 0x68462 /* #483 'MDLAnimatedMatrix4x4' => 'ModelIO.MDLAnimatedMatrix4x4, Xamarin.Mac' */ },
		{ NULL, 0x68562 /* #484 'MDLAnimatedQuaternionArray' => 'ModelIO.MDLAnimatedQuaternionArray, Xamarin.Mac' */ },
		{ NULL, 0x68662 /* #485 'MDLAnimatedScalar' => 'ModelIO.MDLAnimatedScalar, Xamarin.Mac' */ },
		{ NULL, 0x68762 /* #486 'MDLAnimatedScalarArray' => 'ModelIO.MDLAnimatedScalarArray, Xamarin.Mac' */ },
		{ NULL, 0x68A62 /* #487 'MDLAnimatedVector2' => 'ModelIO.MDLAnimatedVector2, Xamarin.Mac' */ },
		{ NULL, 0x68B62 /* #488 'MDLAnimatedVector3' => 'ModelIO.MDLAnimatedVector3, Xamarin.Mac' */ },
		{ NULL, 0x68C62 /* #489 'MDLAnimatedVector3Array' => 'ModelIO.MDLAnimatedVector3Array, Xamarin.Mac' */ },
		{ NULL, 0x68D62 /* #490 'MDLAnimatedVector4' => 'ModelIO.MDLAnimatedVector4, Xamarin.Mac' */ },
		{ NULL, 0x68E62 /* #491 'MDLAnimationBindComponent' => 'ModelIO.MDLAnimationBindComponent, Xamarin.Mac' */ },
		{ NULL, 0x6B962 /* #492 'MDLObject' => 'ModelIO.MDLObject, Xamarin.Mac' */ },
		{ NULL, 0x69C62 /* #493 'MDLLight' => 'ModelIO.MDLLight, Xamarin.Mac' */ },
		{ NULL, 0x6C162 /* #494 'MDLPhysicallyPlausibleLight' => 'ModelIO.MDLPhysicallyPlausibleLight, Xamarin.Mac' */ },
		{ NULL, 0x68F62 /* #495 'MDLAreaLight' => 'ModelIO.MDLAreaLight, Xamarin.Mac' */ },
		{ NULL, 0x69062 /* #496 'MDLAsset' => 'ModelIO.MDLAsset, Xamarin.Mac' */ },
		{ NULL, 0x69362 /* #497 'MDLBundleAssetResolver' => 'ModelIO.MDLBundleAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x69462 /* #498 'MDLCamera' => 'ModelIO.MDLCamera, Xamarin.Mac' */ },
		{ NULL, 0x6CA62 /* #499 'MDLTexture' => 'ModelIO.MDLTexture, Xamarin.Mac' */ },
		{ NULL, 0x69562 /* #500 'MDLCheckerboardTexture' => 'ModelIO.MDLCheckerboardTexture, Xamarin.Mac' */ },
		{ NULL, 0x69662 /* #501 'MDLColorSwatchTexture' => 'ModelIO.MDLColorSwatchTexture, Xamarin.Mac' */ },
		{ NULL, 0x69D62 /* #502 'MDLLightProbe' => 'ModelIO.MDLLightProbe, Xamarin.Mac' */ },
		{ NULL, 0x6A162 /* #503 'MDLLightProbeIrradianceDataSource' => 'ModelIO.MDLLightProbeIrradianceDataSource, Xamarin.Mac' */ },
		{ NULL, 0x6A262 /* #504 'MDLMaterial' => 'ModelIO.MDLMaterial, Xamarin.Mac' */ },
		{ NULL, 0x6A362 /* #505 'MDLMaterialProperty' => 'ModelIO.MDLMaterialProperty, Xamarin.Mac' */ },
		{ NULL, 0x6A462 /* #506 'MDLMaterialPropertyConnection' => 'ModelIO.MDLMaterialPropertyConnection, Xamarin.Mac' */ },
		{ NULL, 0x6A662 /* #507 'MDLMaterialPropertyNode' => 'ModelIO.MDLMaterialPropertyNode, Xamarin.Mac' */ },
		{ NULL, 0x6A562 /* #508 'MDLMaterialPropertyGraph' => 'ModelIO.MDLMaterialPropertyGraph, Xamarin.Mac' */ },
		{ NULL, 0x6A762 /* #509 'MDLMatrix4x4Array' => 'ModelIO.MDLMatrix4x4Array, Xamarin.Mac' */ },
		{ NULL, 0x6AE62 /* #510 'MDLMeshBufferData' => 'ModelIO.MDLMeshBufferData, Xamarin.Mac' */ },
		{ NULL, 0x6AF62 /* #511 'MDLMeshBufferDataAllocator' => 'ModelIO.MDLMeshBufferDataAllocator, Xamarin.Mac' */ },
		{ NULL, 0x6B062 /* #512 'MDLMeshBufferMap' => 'ModelIO.MDLMeshBufferMap, Xamarin.Mac' */ },
		{ NULL, 0x6B462 /* #513 'MDLMeshBufferZoneDefault' => 'ModelIO.MDLMeshBufferZoneDefault, Xamarin.Mac' */ },
		{ NULL, 0x6B762 /* #514 'MDLNoiseTexture' => 'ModelIO.MDLNoiseTexture, Xamarin.Mac' */ },
		{ NULL, 0x6B862 /* #515 'MDLNormalMapTexture' => 'ModelIO.MDLNormalMapTexture, Xamarin.Mac' */ },
		{ NULL, 0x6BA62 /* #516 'MDLObjectContainer' => 'ModelIO.MDLObjectContainer, Xamarin.Mac' */ },
		{ NULL, 0x6BE62 /* #517 'MDLPackedJointAnimation' => 'ModelIO.MDLPackedJointAnimation, Xamarin.Mac' */ },
		{ NULL, 0x6BF62 /* #518 'MDLPathAssetResolver' => 'ModelIO.MDLPathAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x6C062 /* #519 'MDLPhotometricLight' => 'ModelIO.MDLPhotometricLight, Xamarin.Mac' */ },
		{ NULL, 0x6C462 /* #520 'MDLScatteringFunction' => 'ModelIO.MDLScatteringFunction, Xamarin.Mac' */ },
		{ NULL, 0x6C262 /* #521 'MDLPhysicallyPlausibleScatteringFunction' => 'ModelIO.MDLPhysicallyPlausibleScatteringFunction, Xamarin.Mac' */ },
		{ NULL, 0x6C362 /* #522 'MDLRelativeAssetResolver' => 'ModelIO.MDLRelativeAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x6C562 /* #523 'MDLSkeleton' => 'ModelIO.MDLSkeleton, Xamarin.Mac' */ },
		{ NULL, 0x6C662 /* #524 'MDLSkyCubeTexture' => 'ModelIO.MDLSkyCubeTexture, Xamarin.Mac' */ },
		{ NULL, 0x6C762 /* #525 'MDLStereoscopicCamera' => 'ModelIO.MDLStereoscopicCamera, Xamarin.Mac' */ },
		{ NULL, 0x6C862 /* #526 'MDLSubmesh' => 'ModelIO.MDLSubmesh, Xamarin.Mac' */ },
		{ NULL, 0x6C962 /* #527 'MDLSubmeshTopology' => 'ModelIO.MDLSubmeshTopology, Xamarin.Mac' */ },
		{ NULL, 0x6CB62 /* #528 'MDLTextureFilter' => 'ModelIO.MDLTextureFilter, Xamarin.Mac' */ },
		{ NULL, 0x6CC62 /* #529 'MDLTextureSampler' => 'ModelIO.MDLTextureSampler, Xamarin.Mac' */ },
		{ NULL, 0x6CD62 /* #530 'MDLTransform' => 'ModelIO.MDLTransform, Xamarin.Mac' */ },
		{ NULL, 0x6D162 /* #531 'MDLTransformMatrixOp' => 'ModelIO.MDLTransformMatrixOp, Xamarin.Mac' */ },
		{ NULL, 0x6D562 /* #532 'MDLTransformRotateOp' => 'ModelIO.MDLTransformRotateOp, Xamarin.Mac' */ },
		{ NULL, 0x6D662 /* #533 'MDLTransformRotateXOp' => 'ModelIO.MDLTransformRotateXOp, Xamarin.Mac' */ },
		{ NULL, 0x6D762 /* #534 'MDLTransformRotateYOp' => 'ModelIO.MDLTransformRotateYOp, Xamarin.Mac' */ },
		{ NULL, 0x6D862 /* #535 'MDLTransformRotateZOp' => 'ModelIO.MDLTransformRotateZOp, Xamarin.Mac' */ },
		{ NULL, 0x6D962 /* #536 'MDLTransformScaleOp' => 'ModelIO.MDLTransformScaleOp, Xamarin.Mac' */ },
		{ NULL, 0x6DA62 /* #537 'MDLTransformStack' => 'ModelIO.MDLTransformStack, Xamarin.Mac' */ },
		{ NULL, 0x6DB62 /* #538 'MDLTransformTranslateOp' => 'ModelIO.MDLTransformTranslateOp, Xamarin.Mac' */ },
		{ NULL, 0x6DC62 /* #539 'MDLURLTexture' => 'ModelIO.MDLUrlTexture, Xamarin.Mac' */ },
		{ NULL, 0x6DD62 /* #540 'MDLVertexAttribute' => 'ModelIO.MDLVertexAttribute, Xamarin.Mac' */ },
		{ NULL, 0x6DE62 /* #541 'MDLVertexAttributeData' => 'ModelIO.MDLVertexAttributeData, Xamarin.Mac' */ },
		{ NULL, 0x6E062 /* #542 'MDLVertexBufferLayout' => 'ModelIO.MDLVertexBufferLayout, Xamarin.Mac' */ },
		{ NULL, 0x6E162 /* #543 'MDLVertexDescriptor' => 'ModelIO.MDLVertexDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x6E262 /* #544 'MDLVoxelArray' => 'ModelIO.MDLVoxelArray, Xamarin.Mac' */ },
		{ NULL, 0x77562 /* #545 'MPSKernel' => 'MetalPerformanceShaders.MPSKernel, Xamarin.Mac' */ },
		{ NULL, 0x6F962 /* #546 'MPSBinaryImageKernel' => 'MetalPerformanceShaders.MPSBinaryImageKernel, Xamarin.Mac' */ },
		{ NULL, 0x71262 /* #547 'MPSCNNKernel' => 'MetalPerformanceShaders.MPSCnnKernel, Xamarin.Mac' */ },
		{ NULL, 0x6FA62 /* #548 'MPSCNNBinaryConvolution' => 'MetalPerformanceShaders.MPSCnnBinaryConvolution, Xamarin.Mac' */ },
		{ NULL, 0x79062 /* #549 'MPSNNFilterNode' => 'MetalPerformanceShaders.MPSNNFilterNode, Xamarin.Mac' */ },
		{ NULL, 0x70662 /* #550 'MPSCNNConvolutionNode' => 'MetalPerformanceShaders.MPSCnnConvolutionNode, Xamarin.Mac' */ },
		{ NULL, 0x6FB62 /* #551 'MPSCNNBinaryConvolutionNode' => 'MetalPerformanceShaders.MPSCnnBinaryConvolutionNode, Xamarin.Mac' */ },
		{ NULL, 0x6FC62 /* #552 'MPSCNNBinaryFullyConnected' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x6FD62 /* #553 'MPSCNNBinaryFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnectedNode, Xamarin.Mac' */ },
		{ NULL, 0x6FE62 /* #554 'MPSCNNBinaryKernel' => 'MetalPerformanceShaders.MPSCnnBinaryKernel, Xamarin.Mac' */ },
		{ NULL, 0x6FF62 /* #555 'MPSCNNConvolution' => 'MetalPerformanceShaders.MPSCnnConvolution, Xamarin.Mac' */ },
		{ NULL, 0x70362 /* #556 'MPSCNNConvolutionDataSource' => 'MetalPerformanceShaders.MPSCnnConvolutionDataSource, Xamarin.Mac' */ },
		{ NULL, 0x70462 /* #557 'MPSCNNConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7A262 /* #558 'MPSState' => 'MetalPerformanceShaders.MPSState, Xamarin.Mac' */ },
		{ NULL, 0x70762 /* #559 'MPSCNNConvolutionState' => 'MetalPerformanceShaders.MPSCnnConvolutionState, Xamarin.Mac' */ },
		{ NULL, 0x79962 /* #560 'MPSNNStateNode' => 'MetalPerformanceShaders.MPSNNStateNode, Xamarin.Mac' */ },
		{ NULL, 0x70862 /* #561 'MPSCNNConvolutionStateNode' => 'MetalPerformanceShaders.MPSCnnConvolutionStateNode, Xamarin.Mac' */ },
		{ NULL, 0x70962 /* #562 'MPSCNNConvolutionTranspose' => 'MetalPerformanceShaders.MPSCnnConvolutionTranspose, Xamarin.Mac' */ },
		{ NULL, 0x70A62 /* #563 'MPSCNNConvolutionTransposeNode' => 'MetalPerformanceShaders.MPSCnnConvolutionTransposeNode, Xamarin.Mac' */ },
		{ NULL, 0x70B62 /* #564 'MPSCNNCrossChannelNormalization' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalization, Xamarin.Mac' */ },
		{ NULL, 0x72F62 /* #565 'MPSCNNNormalizationNode' => 'MetalPerformanceShaders.MPSCnnNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x70C62 /* #566 'MPSCNNCrossChannelNormalizationNode' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x70D62 /* #567 'MPSCNNDepthWiseConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnDepthWiseConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x73062 /* #568 'MPSCNNPooling' => 'MetalPerformanceShaders.MPSCnnPooling, Xamarin.Mac' */ },
		{ NULL, 0x70E62 /* #569 'MPSCNNDilatedPoolingMax' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMax, Xamarin.Mac' */ },
		{ NULL, 0x70F62 /* #570 'MPSCNNDilatedPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x71062 /* #571 'MPSCNNFullyConnected' => 'MetalPerformanceShaders.MPSCnnFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x71162 /* #572 'MPSCNNFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnFullyConnectedNode, Xamarin.Mac' */ },
		{ NULL, 0x71362 /* #573 'MPSCNNLocalContrastNormalization' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalization, Xamarin.Mac' */ },
		{ NULL, 0x71462 /* #574 'MPSCNNLocalContrastNormalizationNode' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x71562 /* #575 'MPSCNNLogSoftMax' => 'MetalPerformanceShaders.MPSCnnLogSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x71662 /* #576 'MPSCNNLogSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x71762 /* #577 'MPSCNNNeuron' => 'MetalPerformanceShaders.MPSCnnNeuron, Xamarin.Mac' */ },
		{ NULL, 0x71862 /* #578 'MPSCNNNeuronAbsolute' => 'MetalPerformanceShaders.MPSCnnNeuronAbsolute, Xamarin.Mac' */ },
		{ NULL, 0x72062 /* #579 'MPSCNNNeuronNode' => 'MetalPerformanceShaders.MPSCnnNeuronNode, Xamarin.Mac' */ },
		{ NULL, 0x71962 /* #580 'MPSCNNNeuronAbsoluteNode' => 'MetalPerformanceShaders.MPSCnnNeuronAbsoluteNode, Xamarin.Mac' */ },
		{ NULL, 0x71A62 /* #581 'MPSCNNNeuronELU' => 'MetalPerformanceShaders.MPSCnnNeuronElu, Xamarin.Mac' */ },
		{ NULL, 0x71B62 /* #582 'MPSCNNNeuronELUNode' => 'MetalPerformanceShaders.MPSCnnNeuronEluNode, Xamarin.Mac' */ },
		{ NULL, 0x71C62 /* #583 'MPSCNNNeuronHardSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoid, Xamarin.Mac' */ },
		{ NULL, 0x71D62 /* #584 'MPSCNNNeuronHardSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoidNode, Xamarin.Mac' */ },
		{ NULL, 0x71E62 /* #585 'MPSCNNNeuronLinear' => 'MetalPerformanceShaders.MPSCnnNeuronLinear, Xamarin.Mac' */ },
		{ NULL, 0x71F62 /* #586 'MPSCNNNeuronLinearNode' => 'MetalPerformanceShaders.MPSCnnNeuronLinearNode, Xamarin.Mac' */ },
		{ NULL, 0x72162 /* #587 'MPSCNNNeuronPReLU' => 'MetalPerformanceShaders.MPSCnnNeuronPReLU, Xamarin.Mac' */ },
		{ NULL, 0x72262 /* #588 'MPSCNNNeuronPReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronPReLUNode, Xamarin.Mac' */ },
		{ NULL, 0x72362 /* #589 'MPSCNNNeuronReLU' => 'MetalPerformanceShaders.MPSCnnNeuronReLU, Xamarin.Mac' */ },
		{ NULL, 0x72462 /* #590 'MPSCNNNeuronReLUN' => 'MetalPerformanceShaders.MPSCnnNeuronReLun, Xamarin.Mac' */ },
		{ NULL, 0x72562 /* #591 'MPSCNNNeuronReLUNNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLunNode, Xamarin.Mac' */ },
		{ NULL, 0x72662 /* #592 'MPSCNNNeuronReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLUNode, Xamarin.Mac' */ },
		{ NULL, 0x72762 /* #593 'MPSCNNNeuronSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoid, Xamarin.Mac' */ },
		{ NULL, 0x72862 /* #594 'MPSCNNNeuronSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoidNode, Xamarin.Mac' */ },
		{ NULL, 0x72962 /* #595 'MPSCNNNeuronSoftPlus' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlus, Xamarin.Mac' */ },
		{ NULL, 0x72A62 /* #596 'MPSCNNNeuronSoftPlusNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlusNode, Xamarin.Mac' */ },
		{ NULL, 0x72B62 /* #597 'MPSCNNNeuronSoftSign' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSign, Xamarin.Mac' */ },
		{ NULL, 0x72C62 /* #598 'MPSCNNNeuronSoftSignNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSignNode, Xamarin.Mac' */ },
		{ NULL, 0x72D62 /* #599 'MPSCNNNeuronTanH' => 'MetalPerformanceShaders.MPSCnnNeuronTanH, Xamarin.Mac' */ },
		{ NULL, 0x72E62 /* #600 'MPSCNNNeuronTanHNode' => 'MetalPerformanceShaders.MPSCnnNeuronTanHNode, Xamarin.Mac' */ },
		{ NULL, 0x73162 /* #601 'MPSCNNPoolingAverage' => 'MetalPerformanceShaders.MPSCnnPoolingAverage, Xamarin.Mac' */ },
		{ NULL, 0x73762 /* #602 'MPSCNNPoolingNode' => 'MetalPerformanceShaders.MPSCnnPoolingNode, Xamarin.Mac' */ },
		{ NULL, 0x73262 /* #603 'MPSCNNPoolingAverageNode' => 'MetalPerformanceShaders.MPSCnnPoolingAverageNode, Xamarin.Mac' */ },
		{ NULL, 0x73362 /* #604 'MPSCNNPoolingL2Norm' => 'MetalPerformanceShaders.MPSCnnPoolingL2Norm, Xamarin.Mac' */ },
		{ NULL, 0x73462 /* #605 'MPSCNNPoolingL2NormNode' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormNode, Xamarin.Mac' */ },
		{ NULL, 0x73562 /* #606 'MPSCNNPoolingMax' => 'MetalPerformanceShaders.MPSCnnPoolingMax, Xamarin.Mac' */ },
		{ NULL, 0x73662 /* #607 'MPSCNNPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnPoolingMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x73862 /* #608 'MPSCNNSoftMax' => 'MetalPerformanceShaders.MPSCnnSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x73962 /* #609 'MPSCNNSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnSoftMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x73A62 /* #610 'MPSCNNSpatialNormalization' => 'MetalPerformanceShaders.MPSCnnSpatialNormalization, Xamarin.Mac' */ },
		{ NULL, 0x73B62 /* #611 'MPSCNNSpatialNormalizationNode' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x73C62 /* #612 'MPSCNNSubPixelConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnSubPixelConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x73D62 /* #613 'MPSCNNUpsampling' => 'MetalPerformanceShaders.MPSCnnUpsampling, Xamarin.Mac' */ },
		{ NULL, 0x73E62 /* #614 'MPSCNNUpsamplingBilinear' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinear, Xamarin.Mac' */ },
		{ NULL, 0x73F62 /* #615 'MPSCNNUpsamplingBilinearNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearNode, Xamarin.Mac' */ },
		{ NULL, 0x74062 /* #616 'MPSCNNUpsamplingNearest' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearest, Xamarin.Mac' */ },
		{ NULL, 0x74162 /* #617 'MPSCNNUpsamplingNearestNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestNode, Xamarin.Mac' */ },
		{ NULL, 0x79C62 /* #618 'MPSRNNDescriptor' => 'MetalPerformanceShaders.MPSRnnDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x74462 /* #619 'MPSGRUDescriptor' => 'MetalPerformanceShaders.MPSGRUDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x74762 /* #620 'MPSImage' => 'MetalPerformanceShaders.MPSImage, Xamarin.Mac' */ },
		{ NULL, 0x74D62 /* #621 'MPSImageArithmetic' => 'MetalPerformanceShaders.MPSImageArithmetic, Xamarin.Mac' */ },
		{ NULL, 0x74862 /* #622 'MPSImageAdd' => 'MetalPerformanceShaders.MPSImageAdd, Xamarin.Mac' */ },
		{ NULL, 0x7A662 /* #623 'MPSUnaryImageKernel' => 'MetalPerformanceShaders.MPSUnaryImageKernel, Xamarin.Mac' */ },
		{ NULL, 0x74B62 /* #624 'MPSImageAreaMax' => 'MetalPerformanceShaders.MPSImageAreaMax, Xamarin.Mac' */ },
		{ NULL, 0x74C62 /* #625 'MPSImageAreaMin' => 'MetalPerformanceShaders.MPSImageAreaMin, Xamarin.Mac' */ },
		{ NULL, 0x76462 /* #626 'MPSImageScale' => 'MetalPerformanceShaders.MPSImageScale, Xamarin.Mac' */ },
		{ NULL, 0x74E62 /* #627 'MPSImageBilinearScale' => 'MetalPerformanceShaders.MPSImageBilinearScale, Xamarin.Mac' */ },
		{ NULL, 0x74F62 /* #628 'MPSImageBox' => 'MetalPerformanceShaders.MPSImageBox, Xamarin.Mac' */ },
		{ NULL, 0x75062 /* #629 'MPSImageConversion' => 'MetalPerformanceShaders.MPSImageConversion, Xamarin.Mac' */ },
		{ NULL, 0x75162 /* #630 'MPSImageConvolution' => 'MetalPerformanceShaders.MPSImageConvolution, Xamarin.Mac' */ },
		{ NULL, 0x75262 /* #631 'MPSImageCopyToMatrix' => 'MetalPerformanceShaders.MPSImageCopyToMatrix, Xamarin.Mac' */ },
		{ NULL, 0x75362 /* #632 'MPSImageDescriptor' => 'MetalPerformanceShaders.MPSImageDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x75462 /* #633 'MPSImageDilate' => 'MetalPerformanceShaders.MPSImageDilate, Xamarin.Mac' */ },
		{ NULL, 0x75562 /* #634 'MPSImageDivide' => 'MetalPerformanceShaders.MPSImageDivide, Xamarin.Mac' */ },
		{ NULL, 0x75662 /* #635 'MPSImageErode' => 'MetalPerformanceShaders.MPSImageErode, Xamarin.Mac' */ },
		{ NULL, 0x75762 /* #636 'MPSImageFindKeypoints' => 'MetalPerformanceShaders.MPSImageFindKeypoints, Xamarin.Mac' */ },
		{ NULL, 0x75862 /* #637 'MPSImageGaussianBlur' => 'MetalPerformanceShaders.MPSImageGaussianBlur, Xamarin.Mac' */ },
		{ NULL, 0x76362 /* #638 'MPSImagePyramid' => 'MetalPerformanceShaders.MPSImagePyramid, Xamarin.Mac' */ },
		{ NULL, 0x75962 /* #639 'MPSImageGaussianPyramid' => 'MetalPerformanceShaders.MPSImageGaussianPyramid, Xamarin.Mac' */ },
		{ NULL, 0x75A62 /* #640 'MPSImageHistogram' => 'MetalPerformanceShaders.MPSImageHistogram, Xamarin.Mac' */ },
		{ NULL, 0x75B62 /* #641 'MPSImageHistogramEqualization' => 'MetalPerformanceShaders.MPSImageHistogramEqualization, Xamarin.Mac' */ },
		{ NULL, 0x75C62 /* #642 'MPSImageHistogramSpecification' => 'MetalPerformanceShaders.MPSImageHistogramSpecification, Xamarin.Mac' */ },
		{ NULL, 0x75D62 /* #643 'MPSImageIntegral' => 'MetalPerformanceShaders.MPSImageIntegral, Xamarin.Mac' */ },
		{ NULL, 0x75E62 /* #644 'MPSImageIntegralOfSquares' => 'MetalPerformanceShaders.MPSImageIntegralOfSquares, Xamarin.Mac' */ },
		{ NULL, 0x75F62 /* #645 'MPSImageLanczosScale' => 'MetalPerformanceShaders.MPSImageLanczosScale, Xamarin.Mac' */ },
		{ NULL, 0x76062 /* #646 'MPSImageLaplacian' => 'MetalPerformanceShaders.MPSImageLaplacian, Xamarin.Mac' */ },
		{ NULL, 0x76162 /* #647 'MPSImageMedian' => 'MetalPerformanceShaders.MPSImageMedian, Xamarin.Mac' */ },
		{ NULL, 0x76262 /* #648 'MPSImageMultiply' => 'MetalPerformanceShaders.MPSImageMultiply, Xamarin.Mac' */ },
		{ NULL, 0x76762 /* #649 'MPSImageSobel' => 'MetalPerformanceShaders.MPSImageSobel, Xamarin.Mac' */ },
		{ NULL, 0x76862 /* #650 'MPSImageStatisticsMean' => 'MetalPerformanceShaders.MPSImageStatisticsMean, Xamarin.Mac' */ },
		{ NULL, 0x76962 /* #651 'MPSImageStatisticsMeanAndVariance' => 'MetalPerformanceShaders.MPSImageStatisticsMeanAndVariance, Xamarin.Mac' */ },
		{ NULL, 0x76A62 /* #652 'MPSImageStatisticsMinAndMax' => 'MetalPerformanceShaders.MPSImageStatisticsMinAndMax, Xamarin.Mac' */ },
		{ NULL, 0x76B62 /* #653 'MPSImageSubtract' => 'MetalPerformanceShaders.MPSImageSubtract, Xamarin.Mac' */ },
		{ NULL, 0x76C62 /* #654 'MPSImageTent' => 'MetalPerformanceShaders.MPSImageTent, Xamarin.Mac' */ },
		{ NULL, 0x76D62 /* #655 'MPSImageThresholdBinary' => 'MetalPerformanceShaders.MPSImageThresholdBinary, Xamarin.Mac' */ },
		{ NULL, 0x76E62 /* #656 'MPSImageThresholdBinaryInverse' => 'MetalPerformanceShaders.MPSImageThresholdBinaryInverse, Xamarin.Mac' */ },
		{ NULL, 0x76F62 /* #657 'MPSImageThresholdToZero' => 'MetalPerformanceShaders.MPSImageThresholdToZero, Xamarin.Mac' */ },
		{ NULL, 0x77062 /* #658 'MPSImageThresholdToZeroInverse' => 'MetalPerformanceShaders.MPSImageThresholdToZeroInverse, Xamarin.Mac' */ },
		{ NULL, 0x77162 /* #659 'MPSImageThresholdTruncate' => 'MetalPerformanceShaders.MPSImageThresholdTruncate, Xamarin.Mac' */ },
		{ NULL, 0x77462 /* #660 'MPSImageTranspose' => 'MetalPerformanceShaders.MPSImageTranspose, Xamarin.Mac' */ },
		{ NULL, 0x77662 /* #661 'MPSLSTMDescriptor' => 'MetalPerformanceShaders.MPSLSTMDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x77762 /* #662 'MPSMatrix' => 'MetalPerformanceShaders.MPSMatrix, Xamarin.Mac' */ },
		{ NULL, 0x77862 /* #663 'MPSMatrixBinaryKernel' => 'MetalPerformanceShaders.MPSMatrixBinaryKernel, Xamarin.Mac' */ },
		{ NULL, 0x77962 /* #664 'MPSMatrixCopy' => 'MetalPerformanceShaders.MPSMatrixCopy, Xamarin.Mac' */ },
		{ NULL, 0x77A62 /* #665 'MPSMatrixCopyDescriptor' => 'MetalPerformanceShaders.MPSMatrixCopyDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x78862 /* #666 'MPSMatrixUnaryKernel' => 'MetalPerformanceShaders.MPSMatrixUnaryKernel, Xamarin.Mac' */ },
		{ NULL, 0x77B62 /* #667 'MPSMatrixDecompositionCholesky' => 'MetalPerformanceShaders.MPSMatrixDecompositionCholesky, Xamarin.Mac' */ },
		{ NULL, 0x77C62 /* #668 'MPSMatrixDecompositionLU' => 'MetalPerformanceShaders.MPSMatrixDecompositionLU, Xamarin.Mac' */ },
		{ NULL, 0x77D62 /* #669 'MPSMatrixDescriptor' => 'MetalPerformanceShaders.MPSMatrixDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x77E62 /* #670 'MPSMatrixFindTopK' => 'MetalPerformanceShaders.MPSMatrixFindTopK, Xamarin.Mac' */ },
		{ NULL, 0x77F62 /* #671 'MPSMatrixFullyConnected' => 'MetalPerformanceShaders.MPSMatrixFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x78362 /* #672 'MPSMatrixSoftMax' => 'MetalPerformanceShaders.MPSMatrixSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x78062 /* #673 'MPSMatrixLogSoftMax' => 'MetalPerformanceShaders.MPSMatrixLogSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x78162 /* #674 'MPSMatrixMultiplication' => 'MetalPerformanceShaders.MPSMatrixMultiplication, Xamarin.Mac' */ },
		{ NULL, 0x78262 /* #675 'MPSMatrixNeuron' => 'MetalPerformanceShaders.MPSMatrixNeuron, Xamarin.Mac' */ },
		{ NULL, 0x78462 /* #676 'MPSMatrixSolveCholesky' => 'MetalPerformanceShaders.MPSMatrixSolveCholesky, Xamarin.Mac' */ },
		{ NULL, 0x78562 /* #677 'MPSMatrixSolveLU' => 'MetalPerformanceShaders.MPSMatrixSolveLU, Xamarin.Mac' */ },
		{ NULL, 0x78662 /* #678 'MPSMatrixSolveTriangular' => 'MetalPerformanceShaders.MPSMatrixSolveTriangular, Xamarin.Mac' */ },
		{ NULL, 0x78762 /* #679 'MPSMatrixSum' => 'MetalPerformanceShaders.MPSMatrixSum, Xamarin.Mac' */ },
		{ NULL, 0x78962 /* #680 'MPSMatrixVectorMultiplication' => 'MetalPerformanceShaders.MPSMatrixVectorMultiplication, Xamarin.Mac' */ },
		{ NULL, 0x78C62 /* #681 'MPSNNBinaryArithmeticNode' => 'MetalPerformanceShaders.MPSNNBinaryArithmeticNode, Xamarin.Mac' */ },
		{ NULL, 0x78A62 /* #682 'MPSNNAdditionNode' => 'MetalPerformanceShaders.MPSNNAdditionNode, Xamarin.Mac' */ },
		{ NULL, 0x79862 /* #683 'MPSNNScaleNode' => 'MetalPerformanceShaders.MPSNNScaleNode, Xamarin.Mac' */ },
		{ NULL, 0x78B62 /* #684 'MPSNNBilinearScaleNode' => 'MetalPerformanceShaders.MPSNNBilinearScaleNode, Xamarin.Mac' */ },
		{ NULL, 0x78D62 /* #685 'MPSNNConcatenationNode' => 'MetalPerformanceShaders.MPSNNConcatenationNode, Xamarin.Mac' */ },
		{ NULL, 0x78E62 /* #686 'MPSNNDefaultPadding' => 'MetalPerformanceShaders.MPSNNDefaultPadding, Xamarin.Mac' */ },
		{ NULL, 0x78F62 /* #687 'MPSNNDivisionNode' => 'MetalPerformanceShaders.MPSNNDivisionNode, Xamarin.Mac' */ },
		{ NULL, 0x79262 /* #688 'MPSNNImageNode' => 'MetalPerformanceShaders.MPSNNImageNode, Xamarin.Mac' */ },
		{ NULL, 0x79362 /* #689 'MPSNNLanczosScaleNode' => 'MetalPerformanceShaders.MPSNNLanczosScaleNode, Xamarin.Mac' */ },
		{ NULL, 0x79462 /* #690 'MPSNNMultiplicationNode' => 'MetalPerformanceShaders.MPSNNMultiplicationNode, Xamarin.Mac' */ },
		{ NULL, 0x79A62 /* #691 'MPSNNSubtractionNode' => 'MetalPerformanceShaders.MPSNNSubtractionNode, Xamarin.Mac' */ },
		{ NULL, 0x79D62 /* #692 'MPSRNNImageInferenceLayer' => 'MetalPerformanceShaders.MPSRnnImageInferenceLayer, Xamarin.Mac' */ },
		{ NULL, 0x79E62 /* #693 'MPSRNNMatrixInferenceLayer' => 'MetalPerformanceShaders.MPSRnnMatrixInferenceLayer, Xamarin.Mac' */ },
		{ NULL, 0x79F62 /* #694 'MPSRNNRecurrentImageState' => 'MetalPerformanceShaders.MPSRnnRecurrentImageState, Xamarin.Mac' */ },
		{ NULL, 0x7A062 /* #695 'MPSRNNRecurrentMatrixState' => 'MetalPerformanceShaders.MPSRnnRecurrentMatrixState, Xamarin.Mac' */ },
		{ NULL, 0x7A162 /* #696 'MPSRNNSingleGateDescriptor' => 'MetalPerformanceShaders.MPSRnnSingleGateDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7A362 /* #697 'MPSTemporaryImage' => 'MetalPerformanceShaders.MPSTemporaryImage, Xamarin.Mac' */ },
		{ NULL, 0x7A462 /* #698 'MPSTemporaryMatrix' => 'MetalPerformanceShaders.MPSTemporaryMatrix, Xamarin.Mac' */ },
		{ NULL, 0x7A762 /* #699 'MPSVector' => 'MetalPerformanceShaders.MPSVector, Xamarin.Mac' */ },
		{ NULL, 0x7A562 /* #700 'MPSTemporaryVector' => 'MetalPerformanceShaders.MPSTemporaryVector, Xamarin.Mac' */ },
		{ NULL, 0x7A862 /* #701 'MPSVectorDescriptor' => 'MetalPerformanceShaders.MPSVectorDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7C062 /* #702 'MTKMesh' => 'MetalKit.MTKMesh, Xamarin.Mac' */ },
		{ NULL, 0x7C162 /* #703 'MTKMeshBuffer' => 'MetalKit.MTKMeshBuffer, Xamarin.Mac' */ },
		{ NULL, 0x7C262 /* #704 'MTKMeshBufferAllocator' => 'MetalKit.MTKMeshBufferAllocator, Xamarin.Mac' */ },
		{ NULL, 0x7C462 /* #705 'MTKSubmesh' => 'MetalKit.MTKSubmesh, Xamarin.Mac' */ },
		{ NULL, 0x7CD62 /* #706 'MTKView' => 'MetalKit.MTKView, Xamarin.Mac' */ },
		{ NULL, 0x7D062 /* #707 'MTKViewDelegate' => 'MetalKit.MTKViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x7D362 /* #708 'MTLArgument' => 'Metal.MTLArgument, Xamarin.Mac' */ },
		{ NULL, 0x7D662 /* #709 'MTLArgumentDescriptor' => 'Metal.MTLArgumentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87962 /* #710 'MTLType' => 'Metal.MTLType, Xamarin.Mac' */ },
		{ NULL, 0x7DB62 /* #711 'MTLArrayType' => 'Metal.MTLArrayType, Xamarin.Mac' */ },
		{ NULL, 0x7DC62 /* #712 'MTLAttribute' => 'Metal.MTLAttribute, Xamarin.Mac' */ },
		{ NULL, 0x7DD62 /* #713 'MTLAttributeDescriptor' => 'Metal.MTLAttributeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7DE62 /* #714 'MTLAttributeDescriptorArray' => 'Metal.MTLAttributeDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x7EA62 /* #715 'MTLBufferLayoutDescriptor' => 'Metal.MTLBufferLayoutDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7EB62 /* #716 'MTLBufferLayoutDescriptorArray' => 'Metal.MTLBufferLayoutDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x7EC62 /* #717 'MTLCaptureManager' => 'Metal.MTLCaptureManager, Xamarin.Mac' */ },
		{ NULL, 0x7EF62 /* #718 'Xamarin_Mac__Metal_MTLCaptureScope' => 'Metal.MTLCaptureScope, Xamarin.Mac' */ },
		{ NULL, 0x7FC62 /* #719 'MTLCompileOptions' => 'Metal.MTLCompileOptions, Xamarin.Mac' */ },
		{ NULL, 0x80062 /* #720 'MTLComputePipelineDescriptor' => 'Metal.MTLComputePipelineDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x80162 /* #721 'MTLComputePipelineReflection' => 'Metal.MTLComputePipelineReflection, Xamarin.Mac' */ },
		{ NULL, 0x80962 /* #722 'MTLDepthStencilDescriptor' => 'Metal.MTLDepthStencilDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x81262 /* #723 'MTLDrawable' => 'Metal.MTLDrawable, Xamarin.Mac' */ },
		{ NULL, 0x81B62 /* #724 'MTLFunctionConstant' => 'Metal.MTLFunctionConstant, Xamarin.Mac' */ },
		{ NULL, 0x81C62 /* #725 'MTLFunctionConstantValues' => 'Metal.MTLFunctionConstantValues, Xamarin.Mac' */ },
		{ NULL, 0x82162 /* #726 'MTLHeapDescriptor' => 'Metal.MTLHeapDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x82562 /* #727 'MTLIndirectCommandBufferDescriptor' => 'Metal.MTLIndirectCommandBufferDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x83762 /* #728 'MTLPipelineBufferDescriptor' => 'Metal.MTLPipelineBufferDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x83862 /* #729 'MTLPipelineBufferDescriptorArray' => 'Metal.MTLPipelineBufferDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x83B62 /* #730 'MTLPointerType' => 'Metal.MTLPointerType, Xamarin.Mac' */ },
		{ NULL, 0x84362 /* #731 'MTLRenderPassAttachmentDescriptor' => 'Metal.MTLRenderPassAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84462 /* #732 'MTLRenderPassColorAttachmentDescriptor' => 'Metal.MTLRenderPassColorAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84562 /* #733 'MTLRenderPassColorAttachmentDescriptorArray' => 'Metal.MTLRenderPassColorAttachmentDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x84662 /* #734 'MTLRenderPassDepthAttachmentDescriptor' => 'Metal.MTLRenderPassDepthAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84762 /* #735 'MTLRenderPassDescriptor' => 'Metal.MTLRenderPassDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84862 /* #736 'MTLRenderPassStencilAttachmentDescriptor' => 'Metal.MTLRenderPassStencilAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84962 /* #737 'MTLRenderPipelineColorAttachmentDescriptor' => 'Metal.MTLRenderPipelineColorAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84A62 /* #738 'MTLRenderPipelineColorAttachmentDescriptorArray' => 'Metal.MTLRenderPipelineColorAttachmentDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x84B62 /* #739 'MTLRenderPipelineDescriptor' => 'Metal.MTLRenderPipelineDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84E62 /* #740 'MTLRenderPipelineReflection' => 'Metal.MTLRenderPipelineReflection, Xamarin.Mac' */ },
		{ NULL, 0x85A62 /* #741 'MTLSamplerDescriptor' => 'Metal.MTLSamplerDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x86162 /* #742 'MTLSharedEventHandle' => 'Metal.MTLSharedEventHandle, Xamarin.Mac' */ },
		{ NULL, 0x86262 /* #743 'MTLSharedEventListener' => 'Metal.MTLSharedEventListener, Xamarin.Mac' */ },
		{ NULL, 0x86362 /* #744 'MTLSharedTextureHandle' => 'Metal.MTLSharedTextureHandle, Xamarin.Mac' */ },
		{ NULL, 0x86462 /* #745 'MTLStageInputOutputDescriptor' => 'Metal.MTLStageInputOutputDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x86562 /* #746 'MTLStencilDescriptor' => 'Metal.MTLStencilDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x86B62 /* #747 'MTLStructMember' => 'Metal.MTLStructMember, Xamarin.Mac' */ },
		{ NULL, 0x86C62 /* #748 'MTLStructType' => 'Metal.MTLStructType, Xamarin.Mac' */ },
		{ NULL, 0x87462 /* #749 'MTLTextureDescriptor' => 'Metal.MTLTextureDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87562 /* #750 'MTLTextureReferenceType' => 'Metal.MTLTextureReferenceType, Xamarin.Mac' */ },
		{ NULL, 0x87A62 /* #751 'MTLVertexAttribute' => 'Metal.MTLVertexAttribute, Xamarin.Mac' */ },
		{ NULL, 0x87B62 /* #752 'MTLVertexAttributeDescriptor' => 'Metal.MTLVertexAttributeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87C62 /* #753 'MTLVertexAttributeDescriptorArray' => 'Metal.MTLVertexAttributeDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x87D62 /* #754 'MTLVertexBufferLayoutDescriptor' => 'Metal.MTLVertexBufferLayoutDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87E62 /* #755 'MTLVertexBufferLayoutDescriptorArray' => 'Metal.MTLVertexBufferLayoutDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x87F62 /* #756 'MTLVertexDescriptor' => 'Metal.MTLVertexDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x8B862 /* #757 'MPRemoteCommandEvent' => 'MediaPlayer.MPRemoteCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x89D62 /* #758 'MPChangeLanguageOptionCommandEvent' => 'MediaPlayer.MPChangeLanguageOptionCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8B662 /* #759 'MPRemoteCommand' => 'MediaPlayer.MPRemoteCommand, Xamarin.Mac' */ },
		{ NULL, 0x89F62 /* #760 'MPChangePlaybackPositionCommand' => 'MediaPlayer.MPChangePlaybackPositionCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A062 /* #761 'MPChangePlaybackPositionCommandEvent' => 'MediaPlayer.MPChangePlaybackPositionCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A162 /* #762 'MPChangePlaybackRateCommand' => 'MediaPlayer.MPChangePlaybackRateCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A262 /* #763 'MPChangePlaybackRateCommandEvent' => 'MediaPlayer.MPChangePlaybackRateCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A362 /* #764 'MPChangeRepeatModeCommand' => 'MediaPlayer.MPChangeRepeatModeCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A462 /* #765 'MPChangeRepeatModeCommandEvent' => 'MediaPlayer.MPChangeRepeatModeCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A562 /* #766 'MPChangeShuffleModeCommand' => 'MediaPlayer.MPChangeShuffleModeCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A662 /* #767 'MPChangeShuffleModeCommandEvent' => 'MediaPlayer.MPChangeShuffleModeCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A762 /* #768 'MPContentItem' => 'MediaPlayer.MPContentItem, Xamarin.Mac' */ },
		{ NULL, 0x8A862 /* #769 'MPFeedbackCommand' => 'MediaPlayer.MPFeedbackCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A962 /* #770 'MPFeedbackCommandEvent' => 'MediaPlayer.MPFeedbackCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8AB62 /* #771 'MPMediaItem' => 'MediaPlayer.MPMediaItem, Xamarin.Mac' */ },
		{ NULL, 0x8AC62 /* #772 'MPMediaItemArtwork' => 'MediaPlayer.MPMediaItemArtwork, Xamarin.Mac' */ },
		{ NULL, 0x8AE62 /* #773 'MPNowPlayingInfoCenter' => 'MediaPlayer.MPNowPlayingInfoCenter, Xamarin.Mac' */ },
		{ NULL, 0x8AF62 /* #774 'MPNowPlayingInfoLanguageOption' => 'MediaPlayer.MPNowPlayingInfoLanguageOption, Xamarin.Mac' */ },
		{ NULL, 0x8B062 /* #775 'MPNowPlayingInfoLanguageOptionGroup' => 'MediaPlayer.MPNowPlayingInfoLanguageOptionGroup, Xamarin.Mac' */ },
		{ NULL, 0x8B462 /* #776 'MPRatingCommand' => 'MediaPlayer.MPRatingCommand, Xamarin.Mac' */ },
		{ NULL, 0x8B562 /* #777 'MPRatingCommandEvent' => 'MediaPlayer.MPRatingCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8B762 /* #778 'MPRemoteCommandCenter' => 'MediaPlayer.MPRemoteCommandCenter, Xamarin.Mac' */ },
		{ NULL, 0x8BB62 /* #779 'MPSeekCommandEvent' => 'MediaPlayer.MPSeekCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8BF62 /* #780 'MPSkipIntervalCommandEvent' => 'MediaPlayer.MPSkipIntervalCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8C362 /* #781 'MLMediaGroup' => 'MediaLibrary.MLMediaGroup, Xamarin.Mac' */ },
		{ NULL, 0x8C462 /* #782 'MLMediaLibrary' => 'MediaLibrary.MLMediaLibrary, Xamarin.Mac' */ },
		{ NULL, 0x8C562 /* #783 'MLMediaObject' => 'MediaLibrary.MLMediaObject, Xamarin.Mac' */ },
		{ NULL, 0x8C662 /* #784 'MLMediaSource' => 'MediaLibrary.MLMediaSource, Xamarin.Mac' */ },
		{ NULL, 0x8D462 /* #785 'MKAnnotation' => 'MapKit.MKAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x8D562 /* #786 'MKAnnotationView' => 'MapKit.MKAnnotationView, Xamarin.Mac' */ },
		{ NULL, 0x91662 /* #787 'MKShape' => 'MapKit.MKShape, Xamarin.Mac' */ },
		{ NULL, 0x8D862 /* #788 'MKCircle' => 'MapKit.MKCircle, Xamarin.Mac' */ },
		{ NULL, 0x90A62 /* #789 'MKOverlayRenderer' => 'MapKit.MKOverlayRenderer, Xamarin.Mac' */ },
		{ NULL, 0x90962 /* #790 'MKOverlayPathRenderer' => 'MapKit.MKOverlayPathRenderer, Xamarin.Mac' */ },
		{ NULL, 0x8D962 /* #791 'MKCircleRenderer' => 'MapKit.MKCircleRenderer, Xamarin.Mac' */ },
		{ NULL, 0x8DA62 /* #792 'MKClusterAnnotation' => 'MapKit.MKClusterAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x8DC62 /* #793 'MKDirectionsRequest' => 'MapKit.MKDirectionsRequest, Xamarin.Mac' */ },
		{ NULL, 0x8DD62 /* #794 'MKDirectionsResponse' => 'MapKit.MKDirectionsResponse, Xamarin.Mac' */ },
		{ NULL, 0x173162 /* #795 'NSFormatter' => 'Foundation.NSFormatter, Xamarin.Mac' */ },
		{ NULL, 0x8DF62 /* #796 'MKDistanceFormatter' => 'MapKit.MKDistanceFormatter, Xamarin.Mac' */ },
		{ NULL, 0x8E462 /* #797 'MKETAResponse' => 'MapKit.MKETAResponse, Xamarin.Mac' */ },
		{ NULL, 0x90362 /* #798 'MKMultiPoint' => 'MapKit.MKMultiPoint, Xamarin.Mac' */ },
		{ NULL, 0x91162 /* #799 'MKPolyline' => 'MapKit.MKPolyline, Xamarin.Mac' */ },
		{ NULL, 0x8E662 /* #800 'MKGeodesicPolyline' => 'MapKit.MKGeodesicPolyline, Xamarin.Mac' */ },
		{ NULL, 0x8E862 /* #801 'MKLocalSearchCompleter' => 'MapKit.MKLocalSearchCompleter, Xamarin.Mac' */ },
		{ NULL, 0x8EC62 /* #802 'MKLocalSearchCompleterDelegate' => 'MapKit.MKLocalSearchCompleterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x8ED62 /* #803 'MKLocalSearchCompletion' => 'MapKit.MKLocalSearchCompletion, Xamarin.Mac' */ },
		{ NULL, 0x8EE62 /* #804 'MKLocalSearchRequest' => 'MapKit.MKLocalSearchRequest, Xamarin.Mac' */ },
		{ NULL, 0x8EF62 /* #805 'MKLocalSearchResponse' => 'MapKit.MKLocalSearchResponse, Xamarin.Mac' */ },
		{ NULL, 0x8F062 /* #806 'MKMapCamera' => 'MapKit.MKMapCamera, Xamarin.Mac' */ },
		{ NULL, 0x8F162 /* #807 'MKMapItem' => 'MapKit.MKMapItem, Xamarin.Mac' */ },
		{ NULL, 0x8F262 /* #808 'MKMapSnapshot' => 'MapKit.MKMapSnapshot, Xamarin.Mac' */ },
		{ NULL, 0x8F362 /* #809 'MKMapSnapshotOptions' => 'MapKit.MKMapSnapshotOptions, Xamarin.Mac' */ },
		{ NULL, 0x90262 /* #810 'MKMapViewDelegate' => 'MapKit.MKMapViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x90762 /* #811 'MKOverlay' => 'MapKit.MKOverlay, Xamarin.Mac' */ },
		{ NULL, 0x90C62 /* #812 'MKPinAnnotationView' => 'MapKit.MKPinAnnotationView, Xamarin.Mac' */ },
		{ NULL, 0xCDF62 /* #813 'CLPlacemark' => 'CoreLocation.CLPlacemark, Xamarin.Mac' */ },
		{ NULL, 0x90D62 /* #814 'MKPlacemark' => 'MapKit.MKPlacemark, Xamarin.Mac' */ },
		{ NULL, 0x90E62 /* #815 'MKPointAnnotation' => 'MapKit.MKPointAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x90F62 /* #816 'MKPolygon' => 'MapKit.MKPolygon, Xamarin.Mac' */ },
		{ NULL, 0x91062 /* #817 'MKPolygonRenderer' => 'MapKit.MKPolygonRenderer, Xamarin.Mac' */ },
		{ NULL, 0x91262 /* #818 'MKPolylineRenderer' => 'MapKit.MKPolylineRenderer, Xamarin.Mac' */ },
		{ NULL, 0x91362 /* #819 'MKRoute' => 'MapKit.MKRoute, Xamarin.Mac' */ },
		{ NULL, 0x91462 /* #820 'MKRouteStep' => 'MapKit.MKRouteStep, Xamarin.Mac' */ },
		{ NULL, 0x91762 /* #821 'MKTileOverlay' => 'MapKit.MKTileOverlay, Xamarin.Mac' */ },
		{ NULL, 0x91862 /* #822 'MKTileOverlayRenderer' => 'MapKit.MKTileOverlayRenderer, Xamarin.Mac' */ },
		{ NULL, 0x91962 /* #823 'MKUserLocation' => 'MapKit.MKUserLocation, Xamarin.Mac' */ },
		{ NULL, 0x93762 /* #824 'JSContext' => 'JavaScriptCore.JSContext, Xamarin.Mac' */ },
		{ NULL, 0x93A62 /* #825 'Xamarin_Mac__JavaScriptCore_JSExport' => 'JavaScriptCore.JSExport, Xamarin.Mac' */ },
		{ NULL, 0x93B62 /* #826 'JSManagedValue' => 'JavaScriptCore.JSManagedValue, Xamarin.Mac' */ },
		{ NULL, 0x93D62 /* #827 'JSValue' => 'JavaScriptCore.JSValue, Xamarin.Mac' */ },
		{ NULL, 0x93E62 /* #828 'JSVirtualMachine' => 'JavaScriptCore.JSVirtualMachine, Xamarin.Mac' */ },
		{ NULL, 0x94362 /* #829 'ITLibAlbum' => 'iTunesLibrary.ITLibAlbum, Xamarin.Mac' */ },
		{ NULL, 0x94462 /* #830 'ITLibArtist' => 'iTunesLibrary.ITLibArtist, Xamarin.Mac' */ },
		{ NULL, 0x94562 /* #831 'ITLibArtwork' => 'iTunesLibrary.ITLibArtwork, Xamarin.Mac' */ },
		{ NULL, 0x94A62 /* #832 'ITLibMediaEntity' => 'iTunesLibrary.ITLibMediaEntity, Xamarin.Mac' */ },
		{ NULL, 0x94D62 /* #833 'ITLibMediaItem' => 'iTunesLibrary.ITLibMediaItem, Xamarin.Mac' */ },
		{ NULL, 0x95262 /* #834 'ITLibMediaItemVideoInfo' => 'iTunesLibrary.ITLibMediaItemVideoInfo, Xamarin.Mac' */ },
		{ NULL, 0x95362 /* #835 'ITLibPlaylist' => 'iTunesLibrary.ITLibPlaylist, Xamarin.Mac' */ },
		{ NULL, 0x95762 /* #836 'ITLibrary' => 'iTunesLibrary.ITLibrary, Xamarin.Mac' */ },
		{ NULL, 0x95B62 /* #837 'IOSurface' => 'IOSurface.IOSurface, Xamarin.Mac' */ },
		{ NULL, 0x97562 /* #838 'INIntentResolutionResult' => 'Intents.INIntentResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96462 /* #839 'INCallDestinationTypeResolutionResult' => 'Intents.INCallDestinationTypeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96562 /* #840 'INCallRecord' => 'Intents.INCallRecord, Xamarin.Mac' */ },
		{ NULL, 0x96862 /* #841 'INCallRecordTypeOptionsResolutionResult' => 'Intents.INCallRecordTypeOptionsResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96962 /* #842 'INCallRecordTypeResolutionResult' => 'Intents.INCallRecordTypeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96D62 /* #843 'INDateComponentsRange' => 'Intents.INDateComponentsRange, Xamarin.Mac' */ },
		{ NULL, 0x96E62 /* #844 'INDateComponentsRangeResolutionResult' => 'Intents.INDateComponentsRangeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96F62 /* #845 'INImage' => 'Intents.INImage, Xamarin.Mac' */ },
		{ NULL, 0x97062 /* #846 'INIntent' => 'Intents.INIntent, Xamarin.Mac' */ },
		{ NULL, 0x97662 /* #847 'INIntentResponse' => 'Intents.INIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x97962 /* #848 'INMessage' => 'Intents.INMessage, Xamarin.Mac' */ },
		{ NULL, 0x97C62 /* #849 'INMessageAttributeOptionsResolutionResult' => 'Intents.INMessageAttributeOptionsResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x97D62 /* #850 'INMessageAttributeResolutionResult' => 'Intents.INMessageAttributeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x97F62 /* #851 'INParameter' => 'Intents.INParameter, Xamarin.Mac' */ },
		{ NULL, 0x98062 /* #852 'INPerson' => 'Intents.INPerson, Xamarin.Mac' */ },
		{ NULL, 0x98162 /* #853 'INPersonHandle' => 'Intents.INPersonHandle, Xamarin.Mac' */ },
		{ NULL, 0x98762 /* #854 'INPersonResolutionResult' => 'Intents.INPersonResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x98962 /* #855 'INPlacemarkResolutionResult' => 'Intents.INPlacemarkResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x98B62 /* #856 'INRecurrenceRule' => 'Intents.INRecurrenceRule, Xamarin.Mac' */ },
		{ NULL, 0x98C62 /* #857 'INSearchCallHistoryIntent' => 'Intents.INSearchCallHistoryIntent, Xamarin.Mac' */ },
		{ NULL, 0x99062 /* #858 'INSearchCallHistoryIntentResponse' => 'Intents.INSearchCallHistoryIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x99262 /* #859 'INSearchForMessagesIntent' => 'Intents.INSearchForMessagesIntent, Xamarin.Mac' */ },
		{ NULL, 0x99662 /* #860 'INSearchForMessagesIntentResponse' => 'Intents.INSearchForMessagesIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x99862 /* #861 'INSendMessageIntent' => 'Intents.INSendMessageIntent, Xamarin.Mac' */ },
		{ NULL, 0x99C62 /* #862 'INSendMessageIntentResponse' => 'Intents.INSendMessageIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x99E62 /* #863 'INSendMessageRecipientResolutionResult' => 'Intents.INSendMessageRecipientResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x9A462 /* #864 'INSpeakableString' => 'Intents.INSpeakableString, Xamarin.Mac' */ },
		{ NULL, 0x9A562 /* #865 'INSpeakableStringResolutionResult' => 'Intents.INSpeakableStringResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x9A662 /* #866 'INStartAudioCallIntent' => 'Intents.INStartAudioCallIntent, Xamarin.Mac' */ },
		{ NULL, 0x9AA62 /* #867 'INStartAudioCallIntentResponse' => 'Intents.INStartAudioCallIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x9AC62 /* #868 'INStartVideoCallIntent' => 'Intents.INStartVideoCallIntent, Xamarin.Mac' */ },
		{ NULL, 0x9B062 /* #869 'INStartVideoCallIntentResponse' => 'Intents.INStartVideoCallIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x9B262 /* #870 'INStringResolutionResult' => 'Intents.INStringResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x9BA62 /* #871 'IKCameraDeviceViewDelegate' => 'ImageKit.IKCameraDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9C062 /* #872 'IKDeviceBrowserViewDelegate' => 'ImageKit.IKDeviceBrowserViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9C262 /* #873 'IKFilterBrowserView' => 'ImageKit.IKFilterBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x9C562 /* #874 'IKFilterCustomUIProvider' => 'ImageKit.IKFilterCustomUIProvider, Xamarin.Mac' */ },
		{ NULL, 0x9C662 /* #875 'IKFilterUIView' => 'ImageKit.IKFilterUIView, Xamarin.Mac' */ },
		{ NULL, 0x9C762 /* #876 'IKImageBrowserCell' => 'ImageKit.IKImageBrowserCell, Xamarin.Mac' */ },
		{ NULL, 0x9CB62 /* #877 'IKImageBrowserDataSource' => 'ImageKit.IKImageBrowserDataSource, Xamarin.Mac' */ },
		{ NULL, 0x9CF62 /* #878 'IKImageBrowserDelegate' => 'ImageKit.IKImageBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9D362 /* #879 'IKImageBrowserItem' => 'ImageKit.IKImageBrowserItem, Xamarin.Mac' */ },
		{ NULL, 0x9D862 /* #880 'IKImageEditPanel' => 'ImageKit.IKImageEditPanel, Xamarin.Mac' */ },
		{ NULL, 0x9DC62 /* #881 'IKImageEditPanelDataSource' => 'ImageKit.IKImageEditPanelDataSource, Xamarin.Mac' */ },
		{ NULL, 0x9DD62 /* #882 'IKImageView' => 'ImageKit.IKImageView, Xamarin.Mac' */ },
		{ NULL, 0x9E062 /* #883 'IKPictureTaker' => 'ImageKit.IKPictureTaker, Xamarin.Mac' */ },
		{ NULL, 0x9E562 /* #884 'IKSaveOptionsDelegate' => 'ImageKit.IKSaveOptionsDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9ED62 /* #885 'IKScannerDeviceViewDelegate' => 'ImageKit.IKScannerDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9EE62 /* #886 'IKSlideshow' => 'ImageKit.IKSlideshow, Xamarin.Mac' */ },
		{ NULL, 0x9F262 /* #887 'IKSlideshowDataSource' => 'ImageKit.IKSlideshowDataSource, Xamarin.Mac' */ },
		{ NULL, 0xA1962 /* #888 'GLKBaseEffect' => 'GLKit.GLKBaseEffect, Xamarin.Mac' */ },
		{ NULL, 0xA1A62 /* #889 'GLKEffectProperty' => 'GLKit.GLKEffectProperty, Xamarin.Mac' */ },
		{ NULL, 0xA1B62 /* #890 'GLKEffectPropertyFog' => 'GLKit.GLKEffectPropertyFog, Xamarin.Mac' */ },
		{ NULL, 0xA1C62 /* #891 'GLKEffectPropertyLight' => 'GLKit.GLKEffectPropertyLight, Xamarin.Mac' */ },
		{ NULL, 0xA1D62 /* #892 'GLKEffectPropertyMaterial' => 'GLKit.GLKEffectPropertyMaterial, Xamarin.Mac' */ },
		{ NULL, 0xA1E62 /* #893 'GLKEffectPropertyTexture' => 'GLKit.GLKEffectPropertyTexture, Xamarin.Mac' */ },
		{ NULL, 0xA1F62 /* #894 'GLKEffectPropertyTransform' => 'GLKit.GLKEffectPropertyTransform, Xamarin.Mac' */ },
		{ NULL, 0xA2062 /* #895 'GLKMesh' => 'GLKit.GLKMesh, Xamarin.Mac' */ },
		{ NULL, 0xA2162 /* #896 'GLKMeshBuffer' => 'GLKit.GLKMeshBuffer, Xamarin.Mac' */ },
		{ NULL, 0xA2262 /* #897 'GLKMeshBufferAllocator' => 'GLKit.GLKMeshBufferAllocator, Xamarin.Mac' */ },
		{ NULL, 0xA2662 /* #898 'GLKNamedEffect' => 'GLKit.GLKNamedEffect, Xamarin.Mac' */ },
		{ NULL, 0xA2762 /* #899 'GLKReflectionMapEffect' => 'GLKit.GLKReflectionMapEffect, Xamarin.Mac' */ },
		{ NULL, 0xA2862 /* #900 'GLKSkyboxEffect' => 'GLKit.GLKSkyboxEffect, Xamarin.Mac' */ },
		{ NULL, 0xA2962 /* #901 'GLKSubmesh' => 'GLKit.GLKSubmesh, Xamarin.Mac' */ },
		{ NULL, 0xA2A62 /* #902 'GLKTextureInfo' => 'GLKit.GLKTextureInfo, Xamarin.Mac' */ },
		{ NULL, 0xA4862 /* #903 'GKComponent' => 'GameplayKit.GKComponent, Xamarin.Mac' */ },
		{ NULL, 0xA3B62 /* #904 'GKAgent' => 'GameplayKit.GKAgent, Xamarin.Mac' */ },
		{ NULL, 0xA3C62 /* #905 'GKAgent2D' => 'GameplayKit.GKAgent2D, Xamarin.Mac' */ },
		{ NULL, 0xA3D62 /* #906 'GKAgent3D' => 'GameplayKit.GKAgent3D, Xamarin.Mac' */ },
		{ NULL, 0xA4162 /* #907 'GKAgentDelegate' => 'GameplayKit.GKAgentDelegate, Xamarin.Mac' */ },
		{ NULL, 0xA7662 /* #908 'GKRandomSource' => 'GameplayKit.GKRandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA4262 /* #909 'GKARC4RandomSource' => 'GameplayKit.GKARC4RandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA4362 /* #910 'GKBehavior' => 'GameplayKit.GKBehavior, Xamarin.Mac' */ },
		{ NULL, 0xA6862 /* #911 'GKNoiseSource' => 'GameplayKit.GKNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4762 /* #912 'GKCoherentNoiseSource' => 'GameplayKit.GKCoherentNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4462 /* #913 'GKBillowNoiseSource' => 'GameplayKit.GKBillowNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4562 /* #914 'GKCheckerboardNoiseSource' => 'GameplayKit.GKCheckerboardNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA6A62 /* #915 'GKObstacle' => 'GameplayKit.GKObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA4662 /* #916 'GKCircleObstacle' => 'GameplayKit.GKCircleObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA4962 /* #917 'GKComponentSystem' => 'GameplayKit.GKComponentSystem`1, Xamarin.Mac' */ },
		{ NULL, 0xA4A62 /* #918 'GKCompositeBehavior' => 'GameplayKit.GKCompositeBehavior, Xamarin.Mac' */ },
		{ NULL, 0xA4B62 /* #919 'GKConstantNoiseSource' => 'GameplayKit.GKConstantNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4C62 /* #920 'GKCylindersNoiseSource' => 'GameplayKit.GKCylindersNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4D62 /* #921 'GKDecisionNode' => 'GameplayKit.GKDecisionNode, Xamarin.Mac' */ },
		{ NULL, 0xA4E62 /* #922 'GKDecisionTree' => 'GameplayKit.GKDecisionTree, Xamarin.Mac' */ },
		{ NULL, 0xA4F62 /* #923 'GKEntity' => 'GameplayKit.GKEntity, Xamarin.Mac' */ },
		{ NULL, 0xA7562 /* #924 'GKRandomDistribution' => 'GameplayKit.GKRandomDistribution, Xamarin.Mac' */ },
		{ NULL, 0xA5862 /* #925 'GKGaussianDistribution' => 'GameplayKit.GKGaussianDistribution, Xamarin.Mac' */ },
		{ NULL, 0xA5962 /* #926 'GKGoal' => 'GameplayKit.GKGoal, Xamarin.Mac' */ },
		{ NULL, 0xA5A62 /* #927 'GKGraph' => 'GameplayKit.GKGraph, Xamarin.Mac' */ },
		{ NULL, 0xA5B62 /* #928 'GKGraphNode' => 'GameplayKit.GKGraphNode, Xamarin.Mac' */ },
		{ NULL, 0xA5C62 /* #929 'GKGraphNode2D' => 'GameplayKit.GKGraphNode2D, Xamarin.Mac' */ },
		{ NULL, 0xA5D62 /* #930 'GKGraphNode3D' => 'GameplayKit.GKGraphNode3D, Xamarin.Mac' */ },
		{ NULL, 0xA5E62 /* #931 'GKGridGraph' => 'GameplayKit.GKGridGraph, Xamarin.Mac' */ },
		{ NULL, 0xA5F62 /* #932 'GKGridGraphNode' => 'GameplayKit.GKGridGraphNode, Xamarin.Mac' */ },
		{ NULL, 0xA6062 /* #933 'GKLinearCongruentialRandomSource' => 'GameplayKit.GKLinearCongruentialRandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA6162 /* #934 'GKMersenneTwisterRandomSource' => 'GameplayKit.GKMersenneTwisterRandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA6262 /* #935 'GKMeshGraph' => 'GameplayKit.GKMeshGraph`1, Xamarin.Mac' */ },
		{ NULL, 0xA6462 /* #936 'GKMinmaxStrategist' => 'GameplayKit.GKMinMaxStrategist, Xamarin.Mac' */ },
		{ NULL, 0xA6562 /* #937 'GKMonteCarloStrategist' => 'GameplayKit.GKMonteCarloStrategist, Xamarin.Mac' */ },
		{ NULL, 0xA6662 /* #938 'GKNoise' => 'GameplayKit.GKNoise, Xamarin.Mac' */ },
		{ NULL, 0xA6762 /* #939 'GKNoiseMap' => 'GameplayKit.GKNoiseMap, Xamarin.Mac' */ },
		{ NULL, 0xA7A62 /* #940 'GKRule' => 'GameplayKit.GKRule, Xamarin.Mac' */ },
		{ NULL, 0xA6962 /* #941 'GKNSPredicateRule' => 'GameplayKit.GKNSPredicateRule, Xamarin.Mac' */ },
		{ NULL, 0xA6B62 /* #942 'GKObstacleGraph' => 'GameplayKit.GKObstacleGraph, Xamarin.Mac' */ },
		{ NULL, 0xA6C62 /* #943 'GKOctree' => 'GameplayKit.GKOctree`1, Xamarin.Mac' */ },
		{ NULL, 0xA6D62 /* #944 'GKOctreeNode' => 'GameplayKit.GKOctreeNode, Xamarin.Mac' */ },
		{ NULL, 0xA6E62 /* #945 'GKPath' => 'GameplayKit.GKPath, Xamarin.Mac' */ },
		{ NULL, 0xA6F62 /* #946 'GKPerlinNoiseSource' => 'GameplayKit.GKPerlinNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA7062 /* #947 'GKPolygonObstacle' => 'GameplayKit.GKPolygonObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA7162 /* #948 'GKQuadtree' => 'GameplayKit.GKQuadTree, Xamarin.Mac' */ },
		{ NULL, 0xA7262 /* #949 'GKQuadtreeNode' => 'GameplayKit.GKQuadTreeNode, Xamarin.Mac' */ },
		{ NULL, 0xA7762 /* #950 'GKRidgedNoiseSource' => 'GameplayKit.GKRidgedNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA7862 /* #951 'GKRTree' => 'GameplayKit.GKRTree`1, Xamarin.Mac' */ },
		{ NULL, 0xA7B62 /* #952 'GKRuleSystem' => 'GameplayKit.GKRuleSystem, Xamarin.Mac' */ },
		{ NULL, 0xA7C62 /* #953 'GKScene' => 'GameplayKit.GKScene, Xamarin.Mac' */ },
		{ NULL, 0xA7F62 /* #954 'GKSCNNodeComponent' => 'GameplayKit.GKSCNNodeComponent, Xamarin.Mac' */ },
		{ NULL, 0xA8062 /* #955 'GKShuffledDistribution' => 'GameplayKit.GKShuffledDistribution, Xamarin.Mac' */ },
		{ NULL, 0xA8162 /* #956 'GKSKNodeComponent' => 'GameplayKit.GKSKNodeComponent, Xamarin.Mac' */ },
		{ NULL, 0xA8262 /* #957 'GKSphereObstacle' => 'GameplayKit.GKSphereObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA8362 /* #958 'GKSpheresNoiseSource' => 'GameplayKit.GKSpheresNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA8462 /* #959 'GKState' => 'GameplayKit.GKState, Xamarin.Mac' */ },
		{ NULL, 0xA8562 /* #960 'GKStateMachine' => 'GameplayKit.GKStateMachine, Xamarin.Mac' */ },
		{ NULL, 0xA8862 /* #961 'GKVoronoiNoiseSource' => 'GameplayKit.GKVoronoiNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA9B62 /* #962 'GKChallenge' => 'GameKit.GKChallenge, Xamarin.Mac' */ },
		{ NULL, 0xA9362 /* #963 'GKAchievementChallenge' => 'GameKit.GKAchievementChallenge, Xamarin.Mac' */ },
		{ NULL, 0xA9862 /* #964 'GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xA9A62 /* #965 'GKBasePlayer' => 'GameKit.GKBasePlayer, Xamarin.Mac' */ },
		{ NULL, 0xAA062 /* #966 'GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAA462 /* #967 'GKChallengeListener' => 'GameKit.GKChallengeListener, Xamarin.Mac' */ },
		{ NULL, 0xAA662 /* #968 'GKChallengesViewController' => 'GameKit.GKChallengesViewController, Xamarin.Mac' */ },
		{ NULL, 0xAA962 /* #969 'GKChallengesViewControllerDelegate' => 'GameKit.GKChallengesViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAAA62 /* #970 'GKCloudPlayer' => 'GameKit.GKCloudPlayer, Xamarin.Mac' */ },
		{ NULL, 0xAAC62 /* #971 'GKDialogController' => 'GameKit.GKDialogController, Xamarin.Mac' */ },
		{ NULL, 0xAB262 /* #972 'GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAB562 /* #973 'GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xABE62 /* #974 'GKInvite' => 'GameKit.GKInvite, Xamarin.Mac' */ },
		{ NULL, 0xAC362 /* #975 'GKInviteEventListener' => 'GameKit.GKInviteEventListener, Xamarin.Mac' */ },
		{ NULL, 0xACD62 /* #976 'GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAD262 /* #977 'GKLocalPlayerListener' => 'GameKit.GKLocalPlayerListener, Xamarin.Mac' */ },
		{ NULL, 0xADE62 /* #978 'GKMatchDelegate' => 'GameKit.GKMatchDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAE962 /* #979 'GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAEA62 /* #980 'GKMatchRequest' => 'GameKit.GKMatchRequest, Xamarin.Mac' */ },
		{ NULL, 0xAF662 /* #981 'GKSavedGameListener' => 'GameKit.GKSavedGameListener, Xamarin.Mac' */ },
		{ NULL, 0xAF862 /* #982 'GKScoreChallenge' => 'GameKit.GKScoreChallenge, Xamarin.Mac' */ },
		{ NULL, 0xAFA62 /* #983 'GKSession' => 'GameKit.GKSession, Xamarin.Mac' */ },
		{ NULL, 0xAFE62 /* #984 'GKSessionDelegate' => 'GameKit.GKSessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB0162 /* #985 'GKTurnBasedEventHandler' => 'GameKit.GKTurnBasedEventHandler, Xamarin.Mac' */ },
		{ NULL, 0xB0562 /* #986 'GKTurnBasedEventHandlerDelegate' => 'GameKit.GKTurnBasedEventHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB0962 /* #987 'GKTurnBasedEventListener' => 'GameKit.GKTurnBasedEventListener, Xamarin.Mac' */ },
		{ NULL, 0xB0B62 /* #988 'GKTurnBasedExchangeReply' => 'GameKit.GKTurnBasedExchangeReply, Xamarin.Mac' */ },
		{ NULL, 0xB0E62 /* #989 'GKTurnBasedMatchmakerViewController' => 'GameKit.GKTurnBasedMatchmakerViewController, Xamarin.Mac' */ },
		{ NULL, 0xB1162 /* #990 'GKTurnBasedMatchmakerViewControllerDelegate' => 'GameKit.GKTurnBasedMatchmakerViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB1462 /* #991 'GKTurnBasedParticipant' => 'GameKit.GKTurnBasedParticipant, Xamarin.Mac' */ },
		{ NULL, 0xB1862 /* #992 'GKVoiceChat' => 'GameKit.GKVoiceChat, Xamarin.Mac' */ },
		{ NULL, 0xB3462 /* #993 'GCControllerElement' => 'GameController.GCControllerElement, Xamarin.Mac' */ },
		{ NULL, 0xB3162 /* #994 'GCControllerAxisInput' => 'GameController.GCControllerAxisInput, Xamarin.Mac' */ },
		{ NULL, 0xB3262 /* #995 'GCControllerButtonInput' => 'GameController.GCControllerButtonInput, Xamarin.Mac' */ },
		{ NULL, 0xB3362 /* #996 'GCControllerDirectionPad' => 'GameController.GCControllerDirectionPad, Xamarin.Mac' */ },
		{ NULL, 0xB3562 /* #997 'GCEventViewController' => 'GameController.GCEventViewController, Xamarin.Mac' */ },
		{ NULL, 0xB3662 /* #998 'GCExtendedGamepad' => 'GameController.GCExtendedGamepad, Xamarin.Mac' */ },
		{ NULL, 0xB3762 /* #999 'GCExtendedGamepadSnapshot' => 'GameController.GCExtendedGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0xB3862 /* #1000 'GCGamepad' => 'GameController.GCGamepad, Xamarin.Mac' */ },
		{ NULL, 0xB3962 /* #1001 'GCGamepadSnapshot' => 'GameController.GCGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0xB3A62 /* #1002 'GCMicroGamepad' => 'GameController.GCMicroGamepad, Xamarin.Mac' */ },
		{ NULL, 0xB3B62 /* #1003 'GCMicroGamepadSnapshot' => 'GameController.GCMicroGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0xB3C62 /* #1004 'GCMotion' => 'GameController.GCMotion, Xamarin.Mac' */ },
		{ NULL, 0xB5262 /* #1005 'EAAccessoryDelegate' => 'ExternalAccessory.EAAccessoryDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB5662 /* #1006 'EASession' => 'ExternalAccessory.EASession, Xamarin.Mac' */ },
		{ NULL, 0xB6962 /* #1007 'EKObject' => 'EventKit.EKObject, Xamarin.Mac' */ },
		{ NULL, 0xB5862 /* #1008 'EKAlarm' => 'EventKit.EKAlarm, Xamarin.Mac' */ },
		{ NULL, 0xB5C62 /* #1009 'EKCalendar' => 'EventKit.EKCalendar, Xamarin.Mac' */ },
		{ NULL, 0xB5E62 /* #1010 'EKCalendarItem' => 'EventKit.EKCalendarItem, Xamarin.Mac' */ },
		{ NULL, 0xB6562 /* #1011 'EKEvent' => 'EventKit.EKEvent, Xamarin.Mac' */ },
		{ NULL, 0xB6A62 /* #1012 'EKParticipant' => 'EventKit.EKParticipant, Xamarin.Mac' */ },
		{ NULL, 0xB6F62 /* #1013 'EKRecurrenceDayOfWeek' => 'EventKit.EKRecurrenceDayOfWeek, Xamarin.Mac' */ },
		{ NULL, 0xB7062 /* #1014 'EKRecurrenceEnd' => 'EventKit.EKRecurrenceEnd, Xamarin.Mac' */ },
		{ NULL, 0xB7262 /* #1015 'EKRecurrenceRule' => 'EventKit.EKRecurrenceRule, Xamarin.Mac' */ },
		{ NULL, 0xB7362 /* #1016 'EKReminder' => 'EventKit.EKReminder, Xamarin.Mac' */ },
		{ NULL, 0xB7562 /* #1017 'EKSource' => 'EventKit.EKSource, Xamarin.Mac' */ },
		{ NULL, 0xB7862 /* #1018 'EKStructuredLocation' => 'EventKit.EKStructuredLocation, Xamarin.Mac' */ },
		{ NULL, 0xB7B62 /* #1019 'CW8021XProfile' => 'CoreWlan.CW8021XProfile, Xamarin.Mac' */ },
		{ NULL, 0xB7C62 /* #1020 'CWChannel' => 'CoreWlan.CWChannel, Xamarin.Mac' */ },
		{ NULL, 0xB7D62 /* #1021 'CWConfiguration' => 'CoreWlan.CWConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xB8162 /* #1022 'CWEventDelegate' => 'CoreWlan.CWEventDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB8362 /* #1023 'CWMutableConfiguration' => 'CoreWlan.CWMutableConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xB8662 /* #1024 'CWNetworkProfile' => 'CoreWlan.CWNetworkProfile, Xamarin.Mac' */ },
		{ NULL, 0xB8462 /* #1025 'CWMutableNetworkProfile' => 'CoreWlan.CWMutableNetworkProfile, Xamarin.Mac' */ },
		{ NULL, 0xB8562 /* #1026 'CWNetwork' => 'CoreWlan.CWNetwork, Xamarin.Mac' */ },
		{ NULL, 0xB8762 /* #1027 'CWWiFiClient' => 'CoreWlan.CWWiFiClient, Xamarin.Mac' */ },
		{ NULL, 0xB8862 /* #1028 'CWWirelessProfile' => 'CoreWlan.CWWirelessProfile, Xamarin.Mac' */ },
		{ NULL, 0xC3462 /* #1029 'CSCustomAttributeKey' => 'CoreSpotlight.CSCustomAttributeKey, Xamarin.Mac' */ },
		{ NULL, 0xC3762 /* #1030 'CSIndexExtensionRequestHandler' => 'CoreSpotlight.CSIndexExtensionRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0x17CA62 /* #1031 'NSString' => 'Foundation.NSString, Xamarin.Mac' */ },
		{ NULL, 0xC3862 /* #1032 'CSLocalizedString' => 'CoreSpotlight.CSLocalizedString, Xamarin.Mac' */ },
		{ NULL, 0xC3A62 /* #1033 'CSPerson' => 'CoreSpotlight.CSPerson, Xamarin.Mac' */ },
		{ NULL, 0xC4062 /* #1034 'CSSearchableIndexDelegate' => 'CoreSpotlight.CSSearchableIndexDelegate, Xamarin.Mac' */ },
		{ NULL, 0xC4162 /* #1035 'CSSearchableItem' => 'CoreSpotlight.CSSearchableItem, Xamarin.Mac' */ },
		{ NULL, 0xC4262 /* #1036 'CSSearchableItemAttributeSet' => 'CoreSpotlight.CSSearchableItemAttributeSet, Xamarin.Mac' */ },
		{ NULL, 0xC4362 /* #1037 'CSSearchQuery' => 'CoreSpotlight.CSSearchQuery, Xamarin.Mac' */ },
		{ NULL, 0xC5562 /* #1038 'MLArrayBatchProvider' => 'CoreML.MLArrayBatchProvider, Xamarin.Mac' */ },
		{ NULL, 0xC5F62 /* #1039 'Xamarin_Mac__CoreML_MLCustomModel' => 'CoreML.MLCustomModel, Xamarin.Mac' */ },
		{ NULL, 0xC6062 /* #1040 'MLDictionaryConstraint' => 'CoreML.MLDictionaryConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC6162 /* #1041 'MLDictionaryFeatureProvider' => 'CoreML.MLDictionaryFeatureProvider, Xamarin.Mac' */ },
		{ NULL, 0xC6262 /* #1042 'MLFeatureDescription' => 'CoreML.MLFeatureDescription, Xamarin.Mac' */ },
		{ NULL, 0xC6662 /* #1043 'MLFeatureValue' => 'CoreML.MLFeatureValue, Xamarin.Mac' */ },
		{ NULL, 0xC6762 /* #1044 'MLImageConstraint' => 'CoreML.MLImageConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC6862 /* #1045 'MLImageSize' => 'CoreML.MLImageSize, Xamarin.Mac' */ },
		{ NULL, 0xC6962 /* #1046 'MLImageSizeConstraint' => 'CoreML.MLImageSizeConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC6B62 /* #1047 'MLModel' => 'CoreML.MLModel, Xamarin.Mac' */ },
		{ NULL, 0xC6C62 /* #1048 'MLModelConfiguration' => 'CoreML.MLModelConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xC6D62 /* #1049 'MLModelDescription' => 'CoreML.MLModelDescription, Xamarin.Mac' */ },
		{ NULL, 0xC7362 /* #1050 'MLMultiArrayConstraint' => 'CoreML.MLMultiArrayConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC7562 /* #1051 'MLMultiArrayShapeConstraint' => 'CoreML.MLMultiArrayShapeConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC7762 /* #1052 'MLPredictionOptions' => 'CoreML.MLPredictionOptions, Xamarin.Mac' */ },
		{ NULL, 0xC7862 /* #1053 'MLSequence' => 'CoreML.MLSequence, Xamarin.Mac' */ },
		{ NULL, 0xC7962 /* #1054 'MLSequenceConstraint' => 'CoreML.MLSequenceConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC7A62 /* #1055 'MIDICIProfile' => 'CoreMidi.MidiCIProfile, Xamarin.Mac' */ },
		{ NULL, 0xC7B62 /* #1056 'MIDICIProfileState' => 'CoreMidi.MidiCIProfileState, Xamarin.Mac' */ },
		{ NULL, 0xC7C62 /* #1057 'MIDICISession' => 'CoreMidi.MidiCISession, Xamarin.Mac' */ },
		{ NULL, 0xCE162 /* #1058 'CLRegion' => 'CoreLocation.CLRegion, Xamarin.Mac' */ },
		{ NULL, 0xCCF62 /* #1059 'CLCircularRegion' => 'CoreLocation.CLCircularRegion, Xamarin.Mac' */ },
		{ NULL, 0xCD162 /* #1060 'CLHeading' => 'CoreLocation.CLHeading, Xamarin.Mac' */ },
		{ NULL, 0xCD262 /* #1061 'CLLocation' => 'CoreLocation.CLLocation, Xamarin.Mac' */ },
		{ NULL, 0xCDE62 /* #1062 'CLLocationManagerDelegate' => 'CoreLocation.CLLocationManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD5362 /* #1063 'CIFilter' => 'CoreImage.CIFilter, Xamarin.Mac' */ },
		{ NULL, 0xCEA62 /* #1064 'CoreImage_CIAccordionFoldTransition' => 'CoreImage.CIAccordionFoldTransition, Xamarin.Mac' */ },
		{ NULL, 0xD2762 /* #1065 'CoreImage_CICompositingFilter' => 'CoreImage.CICompositingFilter, Xamarin.Mac' */ },
		{ NULL, 0xCEB62 /* #1066 'CoreImage_CIAdditionCompositing' => 'CoreImage.CIAdditionCompositing, Xamarin.Mac' */ },
		{ NULL, 0xCED62 /* #1067 'CoreImage_CIAffineFilter' => 'CoreImage.CIAffineFilter, Xamarin.Mac' */ },
		{ NULL, 0xCEC62 /* #1068 'CoreImage_CIAffineClamp' => 'CoreImage.CIAffineClamp, Xamarin.Mac' */ },
		{ NULL, 0xCEE62 /* #1069 'CoreImage_CIAffineTile' => 'CoreImage.CIAffineTile, Xamarin.Mac' */ },
		{ NULL, 0xCEF62 /* #1070 'CoreImage_CIAffineTransform' => 'CoreImage.CIAffineTransform, Xamarin.Mac' */ },
		{ NULL, 0xCF062 /* #1071 'CoreImage_CIAreaAverage' => 'CoreImage.CIAreaAverage, Xamarin.Mac' */ },
		{ NULL, 0xCF162 /* #1072 'CoreImage_CIAreaHistogram' => 'CoreImage.CIAreaHistogram, Xamarin.Mac' */ },
		{ NULL, 0xDC962 /* #1073 'CoreImage_CIReductionFilter' => 'CoreImage.CIReductionFilter, Xamarin.Mac' */ },
		{ NULL, 0xCF262 /* #1074 'CoreImage_CIAreaMaximum' => 'CoreImage.CIAreaMaximum, Xamarin.Mac' */ },
		{ NULL, 0xCF362 /* #1075 'CoreImage_CIAreaMaximumAlpha' => 'CoreImage.CIAreaMaximumAlpha, Xamarin.Mac' */ },
		{ NULL, 0xCF462 /* #1076 'CoreImage_CIAreaMinimum' => 'CoreImage.CIAreaMinimum, Xamarin.Mac' */ },
		{ NULL, 0xCF562 /* #1077 'CoreImage_CIAreaMinimumAlpha' => 'CoreImage.CIAreaMinimumAlpha, Xamarin.Mac' */ },
		{ NULL, 0xCF662 /* #1078 'CoreImage_CIAreaMinMax' => 'CoreImage.CIAreaMinMax, Xamarin.Mac' */ },
		{ NULL, 0xCF762 /* #1079 'CoreImage_CIAreaMinMaxRed' => 'CoreImage.CIAreaMinMaxRed, Xamarin.Mac' */ },
		{ NULL, 0xD7562 /* #1080 'CoreImage_CIImageGenerator' => 'CoreImage.CIImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCF862 /* #1081 'CoreImage_CIAttributedTextImageGenerator' => 'CoreImage.CIAttributedTextImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCFB62 /* #1082 'CIBarcodeDescriptor' => 'CoreImage.CIBarcodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xCF962 /* #1083 'CIAztecCodeDescriptor' => 'CoreImage.CIAztecCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xD1262 /* #1084 'CoreImage_CICodeGenerator' => 'CoreImage.CICodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCFA62 /* #1085 'CoreImage_CIAztecCodeGenerator' => 'CoreImage.CIAztecCodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCFC62 /* #1086 'CoreImage_CIBarcodeGenerator' => 'CoreImage.CIBarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDF162 /* #1087 'CoreImage_CITransitionFilter' => 'CoreImage.CITransitionFilter, Xamarin.Mac' */ },
		{ NULL, 0xCFD62 /* #1088 'CoreImage_CIBarsSwipeTransition' => 'CoreImage.CIBarsSwipeTransition, Xamarin.Mac' */ },
		{ NULL, 0xCFE62 /* #1089 'CoreImage_CIBicubicScaleTransform' => 'CoreImage.CIBicubicScaleTransform, Xamarin.Mac' */ },
		{ NULL, 0xCFF62 /* #1090 'CoreImage_CIBlendFilter' => 'CoreImage.CIBlendFilter, Xamarin.Mac' */ },
		{ NULL, 0xD8662 /* #1091 'CIKernel' => 'CoreImage.CIKernel, Xamarin.Mac' */ },
		{ NULL, 0xD1F62 /* #1092 'CIColorKernel' => 'CoreImage.CIColorKernel, Xamarin.Mac' */ },
		{ NULL, 0xD0062 /* #1093 'CIBlendKernel' => 'CoreImage.CIBlendKernel, Xamarin.Mac' */ },
		{ NULL, 0xD0362 /* #1094 'CoreImage_CIBlendWithMask' => 'CoreImage.CIBlendWithMask, Xamarin.Mac' */ },
		{ NULL, 0xD0162 /* #1095 'CoreImage_CIBlendWithAlphaMask' => 'CoreImage.CIBlendWithAlphaMask, Xamarin.Mac' */ },
		{ NULL, 0xD0262 /* #1096 'CoreImage_CIBlendWithBlueMask' => 'CoreImage.CIBlendWithBlueMask, Xamarin.Mac' */ },
		{ NULL, 0xD0462 /* #1097 'CoreImage_CIBlendWithRedMask' => 'CoreImage.CIBlendWithRedMask, Xamarin.Mac' */ },
		{ NULL, 0xD0562 /* #1098 'CoreImage_CIBloom' => 'CoreImage.CIBloom, Xamarin.Mac' */ },
		{ NULL, 0xD8C62 /* #1099 'CoreImage_CILinearBlur' => 'CoreImage.CILinearBlur, Xamarin.Mac' */ },
		{ NULL, 0xD0662 /* #1100 'CoreImage_CIBokehBlur' => 'CoreImage.CIBokehBlur, Xamarin.Mac' */ },
		{ NULL, 0xD0762 /* #1101 'CoreImage_CIBoxBlur' => 'CoreImage.CIBoxBlur, Xamarin.Mac' */ },
		{ NULL, 0xD4462 /* #1102 'CoreImage_CIDistortionFilter' => 'CoreImage.CIDistortionFilter, Xamarin.Mac' */ },
		{ NULL, 0xD0862 /* #1103 'CoreImage_CIBumpDistortion' => 'CoreImage.CIBumpDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD0962 /* #1104 'CoreImage_CIBumpDistortionLinear' => 'CoreImage.CIBumpDistortionLinear, Xamarin.Mac' */ },
		{ NULL, 0xD0A62 /* #1105 'CoreImage_CICameraCalibrationLensCorrection' => 'CoreImage.CICameraCalibrationLensCorrection, Xamarin.Mac' */ },
		{ NULL, 0xD0B62 /* #1106 'CoreImage_CICheckerboardGenerator' => 'CoreImage.CICheckerboardGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD0C62 /* #1107 'CoreImage_CICircleSplashDistortion' => 'CoreImage.CICircleSplashDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDD462 /* #1108 'CoreImage_CIScreenFilter' => 'CoreImage.CIScreenFilter, Xamarin.Mac' */ },
		{ NULL, 0xD0D62 /* #1109 'CoreImage_CICircularScreen' => 'CoreImage.CICircularScreen, Xamarin.Mac' */ },
		{ NULL, 0xD0E62 /* #1110 'CoreImage_CICircularWrap' => 'CoreImage.CICircularWrap, Xamarin.Mac' */ },
		{ NULL, 0xD0F62 /* #1111 'CoreImage_CIClamp' => 'CoreImage.CIClamp, Xamarin.Mac' */ },
		{ NULL, 0xD1062 /* #1112 'CoreImage_CICmykHalftone' => 'CoreImage.CICmykHalftone, Xamarin.Mac' */ },
		{ NULL, 0xD1162 /* #1113 'CoreImage_CICode128BarcodeGenerator' => 'CoreImage.CICode128BarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD1362 /* #1114 'CIColor' => 'CoreImage.CIColor, Xamarin.Mac' */ },
		{ NULL, 0xD1462 /* #1115 'CoreImage_CIColorBlendMode' => 'CoreImage.CIColorBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD1562 /* #1116 'CoreImage_CIColorBurnBlendMode' => 'CoreImage.CIColorBurnBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD1662 /* #1117 'CoreImage_CIColorClamp' => 'CoreImage.CIColorClamp, Xamarin.Mac' */ },
		{ NULL, 0xD1762 /* #1118 'CoreImage_CIColorControls' => 'CoreImage.CIColorControls, Xamarin.Mac' */ },
		{ NULL, 0xD1862 /* #1119 'CoreImage_CIColorCrossPolynomial' => 'CoreImage.CIColorCrossPolynomial, Xamarin.Mac' */ },
		{ NULL, 0xD1962 /* #1120 'CoreImage_CIColorCube' => 'CoreImage.CIColorCube, Xamarin.Mac' */ },
		{ NULL, 0xD1A62 /* #1121 'CoreImage_CIColorCubesMixedWithMask' => 'CoreImage.CIColorCubesMixedWithMask, Xamarin.Mac' */ },
		{ NULL, 0xD1B62 /* #1122 'CoreImage_CIColorCubeWithColorSpace' => 'CoreImage.CIColorCubeWithColorSpace, Xamarin.Mac' */ },
		{ NULL, 0xD1C62 /* #1123 'CoreImage_CIColorCurves' => 'CoreImage.CIColorCurves, Xamarin.Mac' */ },
		{ NULL, 0xD1D62 /* #1124 'CoreImage_CIColorDodgeBlendMode' => 'CoreImage.CIColorDodgeBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD1E62 /* #1125 'CoreImage_CIColorInvert' => 'CoreImage.CIColorInvert, Xamarin.Mac' */ },
		{ NULL, 0xD2062 /* #1126 'CoreImage_CIColorMap' => 'CoreImage.CIColorMap, Xamarin.Mac' */ },
		{ NULL, 0xD2162 /* #1127 'CoreImage_CIColorMatrix' => 'CoreImage.CIColorMatrix, Xamarin.Mac' */ },
		{ NULL, 0xD2262 /* #1128 'CoreImage_CIColorMonochrome' => 'CoreImage.CIColorMonochrome, Xamarin.Mac' */ },
		{ NULL, 0xD2362 /* #1129 'CoreImage_CIColorPolynomial' => 'CoreImage.CIColorPolynomial, Xamarin.Mac' */ },
		{ NULL, 0xD2462 /* #1130 'CoreImage_CIColorPosterize' => 'CoreImage.CIColorPosterize, Xamarin.Mac' */ },
		{ NULL, 0xD2562 /* #1131 'CoreImage_CIColumnAverage' => 'CoreImage.CIColumnAverage, Xamarin.Mac' */ },
		{ NULL, 0xD2662 /* #1132 'CoreImage_CIComicEffect' => 'CoreImage.CIComicEffect, Xamarin.Mac' */ },
		{ NULL, 0xD2862 /* #1133 'CoreImage_CIConstantColorGenerator' => 'CoreImage.CIConstantColorGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD2962 /* #1134 'CIContext' => 'CoreImage.CIContext, Xamarin.Mac' */ },
		{ NULL, 0xD3262 /* #1135 'CoreImage_CIConvolutionCore' => 'CoreImage.CIConvolutionCore, Xamarin.Mac' */ },
		{ NULL, 0xD2D62 /* #1136 'CoreImage_CIConvolution3X3' => 'CoreImage.CIConvolution3X3, Xamarin.Mac' */ },
		{ NULL, 0xD2E62 /* #1137 'CoreImage_CIConvolution5X5' => 'CoreImage.CIConvolution5X5, Xamarin.Mac' */ },
		{ NULL, 0xD2F62 /* #1138 'CoreImage_CIConvolution7X7' => 'CoreImage.CIConvolution7X7, Xamarin.Mac' */ },
		{ NULL, 0xD3062 /* #1139 'CoreImage_CIConvolution9Horizontal' => 'CoreImage.CIConvolution9Horizontal, Xamarin.Mac' */ },
		{ NULL, 0xD3162 /* #1140 'CoreImage_CIConvolution9Vertical' => 'CoreImage.CIConvolution9Vertical, Xamarin.Mac' */ },
		{ NULL, 0xD3362 /* #1141 'CoreImage_CICopyMachineTransition' => 'CoreImage.CICopyMachineTransition, Xamarin.Mac' */ },
		{ NULL, 0xD3462 /* #1142 'CoreImage_CICoreMLModelFilter' => 'CoreImage.CICoreMLModelFilter, Xamarin.Mac' */ },
		{ NULL, 0xD3562 /* #1143 'CoreImage_CICrop' => 'CoreImage.CICrop, Xamarin.Mac' */ },
		{ NULL, 0xD3662 /* #1144 'CoreImage_CICrystallize' => 'CoreImage.CICrystallize, Xamarin.Mac' */ },
		{ NULL, 0xD3762 /* #1145 'CoreImage_CIDarkenBlendMode' => 'CoreImage.CIDarkenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD3862 /* #1146 'CIDataMatrixCodeDescriptor' => 'CoreImage.CIDataMatrixCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xD3962 /* #1147 'CoreImage_CIDepthBlurEffect' => 'CoreImage.CIDepthBlurEffect, Xamarin.Mac' */ },
		{ NULL, 0xD3A62 /* #1148 'CoreImage_CIDepthDisparityConverter' => 'CoreImage.CIDepthDisparityConverter, Xamarin.Mac' */ },
		{ NULL, 0xD3B62 /* #1149 'CoreImage_CIDepthOfField' => 'CoreImage.CIDepthOfField, Xamarin.Mac' */ },
		{ NULL, 0xD3C62 /* #1150 'CoreImage_CIDepthToDisparity' => 'CoreImage.CIDepthToDisparity, Xamarin.Mac' */ },
		{ NULL, 0xD3D62 /* #1151 'CIDetector' => 'CoreImage.CIDetector, Xamarin.Mac' */ },
		{ NULL, 0xD3E62 /* #1152 'CoreImage_CIDifferenceBlendMode' => 'CoreImage.CIDifferenceBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD3F62 /* #1153 'CoreImage_CIDiscBlur' => 'CoreImage.CIDiscBlur, Xamarin.Mac' */ },
		{ NULL, 0xD4062 /* #1154 'CoreImage_CIDisintegrateWithMaskTransition' => 'CoreImage.CIDisintegrateWithMaskTransition, Xamarin.Mac' */ },
		{ NULL, 0xD4162 /* #1155 'CoreImage_CIDisparityToDepth' => 'CoreImage.CIDisparityToDepth, Xamarin.Mac' */ },
		{ NULL, 0xD4262 /* #1156 'CoreImage_CIDisplacementDistortion' => 'CoreImage.CIDisplacementDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD4362 /* #1157 'CoreImage_CIDissolveTransition' => 'CoreImage.CIDissolveTransition, Xamarin.Mac' */ },
		{ NULL, 0xD4562 /* #1158 'CoreImage_CIDither' => 'CoreImage.CIDither, Xamarin.Mac' */ },
		{ NULL, 0xD4662 /* #1159 'CoreImage_CIDivideBlendMode' => 'CoreImage.CIDivideBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD4762 /* #1160 'CoreImage_CIDotScreen' => 'CoreImage.CIDotScreen, Xamarin.Mac' */ },
		{ NULL, 0xD4862 /* #1161 'CoreImage_CIDroste' => 'CoreImage.CIDroste, Xamarin.Mac' */ },
		{ NULL, 0xD4962 /* #1162 'CoreImage_CIEdgePreserveUpsampleFilter' => 'CoreImage.CIEdgePreserveUpsampleFilter, Xamarin.Mac' */ },
		{ NULL, 0xD4A62 /* #1163 'CoreImage_CIEdges' => 'CoreImage.CIEdges, Xamarin.Mac' */ },
		{ NULL, 0xD4B62 /* #1164 'CoreImage_CIEdgeWork' => 'CoreImage.CIEdgeWork, Xamarin.Mac' */ },
		{ NULL, 0xDEE62 /* #1165 'CoreImage_CITileFilter' => 'CoreImage.CITileFilter, Xamarin.Mac' */ },
		{ NULL, 0xD4C62 /* #1166 'CoreImage_CIEightfoldReflectedTile' => 'CoreImage.CIEightfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xD4D62 /* #1167 'CoreImage_CIExclusionBlendMode' => 'CoreImage.CIExclusionBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD4E62 /* #1168 'CoreImage_CIExposureAdjust' => 'CoreImage.CIExposureAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD4F62 /* #1169 'CoreImage_CIFaceBalance' => 'CoreImage.CIFaceBalance, Xamarin.Mac' */ },
		{ NULL, 0xD5262 /* #1170 'CIFeature' => 'CoreImage.CIFeature, Xamarin.Mac' */ },
		{ NULL, 0xD5062 /* #1171 'CIFaceFeature' => 'CoreImage.CIFaceFeature, Xamarin.Mac' */ },
		{ NULL, 0xD5162 /* #1172 'CoreImage_CIFalseColor' => 'CoreImage.CIFalseColor, Xamarin.Mac' */ },
		{ NULL, 0xD5962 /* #1173 'CIFilterGenerator' => 'CoreImage.CIFilterGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD5C62 /* #1174 'CIFilterShape' => 'CoreImage.CIFilterShape, Xamarin.Mac' */ },
		{ NULL, 0xD5D62 /* #1175 'CoreImage_CIFlashTransition' => 'CoreImage.CIFlashTransition, Xamarin.Mac' */ },
		{ NULL, 0xD5E62 /* #1176 'CoreImage_CIFourfoldReflectedTile' => 'CoreImage.CIFourfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xD5F62 /* #1177 'CoreImage_CIFourfoldRotatedTile' => 'CoreImage.CIFourfoldRotatedTile, Xamarin.Mac' */ },
		{ NULL, 0xD6062 /* #1178 'CoreImage_CIFourfoldTranslatedTile' => 'CoreImage.CIFourfoldTranslatedTile, Xamarin.Mac' */ },
		{ NULL, 0xD6162 /* #1179 'CoreImage_CIGammaAdjust' => 'CoreImage.CIGammaAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD6262 /* #1180 'CoreImage_CIGaussianBlur' => 'CoreImage.CIGaussianBlur, Xamarin.Mac' */ },
		{ NULL, 0xD6362 /* #1181 'CoreImage_CIGaussianGradient' => 'CoreImage.CIGaussianGradient, Xamarin.Mac' */ },
		{ NULL, 0xD6462 /* #1182 'CoreImage_CIGlassDistortion' => 'CoreImage.CIGlassDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD6562 /* #1183 'CoreImage_CIGlassLozenge' => 'CoreImage.CIGlassLozenge, Xamarin.Mac' */ },
		{ NULL, 0xD6662 /* #1184 'CoreImage_CIGlideReflectedTile' => 'CoreImage.CIGlideReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xD6762 /* #1185 'CoreImage_CIGloom' => 'CoreImage.CIGloom, Xamarin.Mac' */ },
		{ NULL, 0xD6862 /* #1186 'CoreImage_CIGuidedFilter' => 'CoreImage.CIGuidedFilter, Xamarin.Mac' */ },
		{ NULL, 0xD6962 /* #1187 'CoreImage_CIHardLightBlendMode' => 'CoreImage.CIHardLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD6A62 /* #1188 'CoreImage_CIHatchedScreen' => 'CoreImage.CIHatchedScreen, Xamarin.Mac' */ },
		{ NULL, 0xD6B62 /* #1189 'CoreImage_CIHeightFieldFromMask' => 'CoreImage.CIHeightFieldFromMask, Xamarin.Mac' */ },
		{ NULL, 0xD6C62 /* #1190 'CoreImage_CIHexagonalPixellate' => 'CoreImage.CIHexagonalPixellate, Xamarin.Mac' */ },
		{ NULL, 0xD6D62 /* #1191 'CoreImage_CIHighlightShadowAdjust' => 'CoreImage.CIHighlightShadowAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD6E62 /* #1192 'CoreImage_CIHistogramDisplayFilter' => 'CoreImage.CIHistogramDisplayFilter, Xamarin.Mac' */ },
		{ NULL, 0xD6F62 /* #1193 'CoreImage_CIHoleDistortion' => 'CoreImage.CIHoleDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD7062 /* #1194 'CoreImage_CIHueAdjust' => 'CoreImage.CIHueAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD7162 /* #1195 'CoreImage_CIHueBlendMode' => 'CoreImage.CIHueBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD7262 /* #1196 'CoreImage_CIHueSaturationValueGradient' => 'CoreImage.CIHueSaturationValueGradient, Xamarin.Mac' */ },
		{ NULL, 0xD7362 /* #1197 'CIImage' => 'CoreImage.CIImage, Xamarin.Mac' */ },
		{ NULL, 0xD7462 /* #1198 'CIImageAccumulator' => 'CoreImage.CIImageAccumulator, Xamarin.Mac' */ },
		{ NULL, 0xD7B62 /* #1199 'CIImageProcessorKernel' => 'CoreImage.CIImageProcessorKernel, Xamarin.Mac' */ },
		{ NULL, 0xD8562 /* #1200 'CoreImage_CIKaleidoscope' => 'CoreImage.CIKaleidoscope, Xamarin.Mac' */ },
		{ NULL, 0xD8762 /* #1201 'CoreImage_CILabDeltaE' => 'CoreImage.CILabDeltaE, Xamarin.Mac' */ },
		{ NULL, 0xD8862 /* #1202 'CoreImage_CILanczosScaleTransform' => 'CoreImage.CILanczosScaleTransform, Xamarin.Mac' */ },
		{ NULL, 0xD8962 /* #1203 'CoreImage_CILenticularHaloGenerator' => 'CoreImage.CILenticularHaloGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD8A62 /* #1204 'CoreImage_CILightenBlendMode' => 'CoreImage.CILightenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD8B62 /* #1205 'CoreImage_CILightTunnel' => 'CoreImage.CILightTunnel, Xamarin.Mac' */ },
		{ NULL, 0xD8D62 /* #1206 'CoreImage_CILinearBurnBlendMode' => 'CoreImage.CILinearBurnBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD8E62 /* #1207 'CoreImage_CILinearDodgeBlendMode' => 'CoreImage.CILinearDodgeBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD8F62 /* #1208 'CoreImage_CILinearGradient' => 'CoreImage.CILinearGradient, Xamarin.Mac' */ },
		{ NULL, 0xD9062 /* #1209 'CoreImage_CILinearToSRGBToneCurve' => 'CoreImage.CILinearToSRGBToneCurve, Xamarin.Mac' */ },
		{ NULL, 0xD9162 /* #1210 'CoreImage_CILineOverlay' => 'CoreImage.CILineOverlay, Xamarin.Mac' */ },
		{ NULL, 0xD9262 /* #1211 'CoreImage_CILineScreen' => 'CoreImage.CILineScreen, Xamarin.Mac' */ },
		{ NULL, 0xD9362 /* #1212 'CoreImage_CILuminosityBlendMode' => 'CoreImage.CILuminosityBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD9462 /* #1213 'CoreImage_CIMaskedVariableBlur' => 'CoreImage.CIMaskedVariableBlur, Xamarin.Mac' */ },
		{ NULL, 0xD9562 /* #1214 'CoreImage_CIMaskToAlpha' => 'CoreImage.CIMaskToAlpha, Xamarin.Mac' */ },
		{ NULL, 0xD9662 /* #1215 'CoreImage_CIMaximumComponent' => 'CoreImage.CIMaximumComponent, Xamarin.Mac' */ },
		{ NULL, 0xD9762 /* #1216 'CoreImage_CIMaximumCompositing' => 'CoreImage.CIMaximumCompositing, Xamarin.Mac' */ },
		{ NULL, 0xD9862 /* #1217 'CoreImage_CIMedianFilter' => 'CoreImage.CIMedianFilter, Xamarin.Mac' */ },
		{ NULL, 0xD9962 /* #1218 'CoreImage_CIMeshGenerator' => 'CoreImage.CIMeshGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD9A62 /* #1219 'CoreImage_CIMinimumComponent' => 'CoreImage.CIMinimumComponent, Xamarin.Mac' */ },
		{ NULL, 0xD9B62 /* #1220 'CoreImage_CIMinimumCompositing' => 'CoreImage.CIMinimumCompositing, Xamarin.Mac' */ },
		{ NULL, 0xD9C62 /* #1221 'CoreImage_CIMix' => 'CoreImage.CIMix, Xamarin.Mac' */ },
		{ NULL, 0xD9D62 /* #1222 'CoreImage_CIModTransition' => 'CoreImage.CIModTransition, Xamarin.Mac' */ },
		{ NULL, 0xD9E62 /* #1223 'CoreImage_CIMorphology' => 'CoreImage.CIMorphology, Xamarin.Mac' */ },
		{ NULL, 0xD9F62 /* #1224 'CoreImage_CIMorphologyGradient' => 'CoreImage.CIMorphologyGradient, Xamarin.Mac' */ },
		{ NULL, 0xDA062 /* #1225 'CoreImage_CIMorphologyMaximum' => 'CoreImage.CIMorphologyMaximum, Xamarin.Mac' */ },
		{ NULL, 0xDA162 /* #1226 'CoreImage_CIMorphologyMinimum' => 'CoreImage.CIMorphologyMinimum, Xamarin.Mac' */ },
		{ NULL, 0xDA262 /* #1227 'CoreImage_CIMotionBlur' => 'CoreImage.CIMotionBlur, Xamarin.Mac' */ },
		{ NULL, 0xDA362 /* #1228 'CoreImage_CIMultiplyBlendMode' => 'CoreImage.CIMultiplyBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDA462 /* #1229 'CoreImage_CIMultiplyCompositing' => 'CoreImage.CIMultiplyCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDA562 /* #1230 'CoreImage_CINinePartStretched' => 'CoreImage.CINinePartStretched, Xamarin.Mac' */ },
		{ NULL, 0xDA662 /* #1231 'CoreImage_CINinePartTiled' => 'CoreImage.CINinePartTiled, Xamarin.Mac' */ },
		{ NULL, 0xDA762 /* #1232 'CoreImage_CINoiseReduction' => 'CoreImage.CINoiseReduction, Xamarin.Mac' */ },
		{ NULL, 0xDA862 /* #1233 'CoreImage_CIOpTile' => 'CoreImage.CIOpTile, Xamarin.Mac' */ },
		{ NULL, 0xDA962 /* #1234 'CoreImage_CIOverlayBlendMode' => 'CoreImage.CIOverlayBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDAA62 /* #1235 'CoreImage_CIPageCurlTransition' => 'CoreImage.CIPageCurlTransition, Xamarin.Mac' */ },
		{ NULL, 0xDAB62 /* #1236 'CoreImage_CIPageCurlWithShadowTransition' => 'CoreImage.CIPageCurlWithShadowTransition, Xamarin.Mac' */ },
		{ NULL, 0xDAC62 /* #1237 'CoreImage_CIParallelogramTile' => 'CoreImage.CIParallelogramTile, Xamarin.Mac' */ },
		{ NULL, 0xDAD62 /* #1238 'CoreImage_CIPdf417BarcodeGenerator' => 'CoreImage.CIPdf417BarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDAE62 /* #1239 'CIPDF417CodeDescriptor' => 'CoreImage.CIPdf417CodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xDB162 /* #1240 'CoreImage_CIPerspectiveTransform' => 'CoreImage.CIPerspectiveTransform, Xamarin.Mac' */ },
		{ NULL, 0xDAF62 /* #1241 'CoreImage_CIPerspectiveCorrection' => 'CoreImage.CIPerspectiveCorrection, Xamarin.Mac' */ },
		{ NULL, 0xDB062 /* #1242 'CoreImage_CIPerspectiveTile' => 'CoreImage.CIPerspectiveTile, Xamarin.Mac' */ },
		{ NULL, 0xDB262 /* #1243 'CoreImage_CIPerspectiveTransformWithExtent' => 'CoreImage.CIPerspectiveTransformWithExtent, Xamarin.Mac' */ },
		{ NULL, 0xDB362 /* #1244 'CoreImage_CIPhotoEffect' => 'CoreImage.CIPhotoEffect, Xamarin.Mac' */ },
		{ NULL, 0xDB462 /* #1245 'CoreImage_CIPhotoEffectChrome' => 'CoreImage.CIPhotoEffectChrome, Xamarin.Mac' */ },
		{ NULL, 0xDB562 /* #1246 'CoreImage_CIPhotoEffectFade' => 'CoreImage.CIPhotoEffectFade, Xamarin.Mac' */ },
		{ NULL, 0xDB662 /* #1247 'CoreImage_CIPhotoEffectInstant' => 'CoreImage.CIPhotoEffectInstant, Xamarin.Mac' */ },
		{ NULL, 0xDB762 /* #1248 'CoreImage_CIPhotoEffectMono' => 'CoreImage.CIPhotoEffectMono, Xamarin.Mac' */ },
		{ NULL, 0xDB862 /* #1249 'CoreImage_CIPhotoEffectNoir' => 'CoreImage.CIPhotoEffectNoir, Xamarin.Mac' */ },
		{ NULL, 0xDB962 /* #1250 'CoreImage_CIPhotoEffectProcess' => 'CoreImage.CIPhotoEffectProcess, Xamarin.Mac' */ },
		{ NULL, 0xDBA62 /* #1251 'CoreImage_CIPhotoEffectTonal' => 'CoreImage.CIPhotoEffectTonal, Xamarin.Mac' */ },
		{ NULL, 0xDBB62 /* #1252 'CoreImage_CIPhotoEffectTransfer' => 'CoreImage.CIPhotoEffectTransfer, Xamarin.Mac' */ },
		{ NULL, 0xDBC62 /* #1253 'CoreImage_CIPinchDistortion' => 'CoreImage.CIPinchDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDBD62 /* #1254 'CoreImage_CIPinLightBlendMode' => 'CoreImage.CIPinLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDBE62 /* #1255 'CoreImage_CIPixellate' => 'CoreImage.CIPixellate, Xamarin.Mac' */ },
		{ NULL, 0xDBF62 /* #1256 'CIPlugIn' => 'CoreImage.CIPlugIn, Xamarin.Mac' */ },
		{ NULL, 0xDC062 /* #1257 'CoreImage_CIPointillize' => 'CoreImage.CIPointillize, Xamarin.Mac' */ },
		{ NULL, 0xDC162 /* #1258 'CIQRCodeDescriptor' => 'CoreImage.CIQRCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xDC262 /* #1259 'CIQRCodeFeature' => 'CoreImage.CIQRCodeFeature, Xamarin.Mac' */ },
		{ NULL, 0xDC362 /* #1260 'CoreImage_CIQRCodeGenerator' => 'CoreImage.CIQRCodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDC462 /* #1261 'CoreImage_CIRadialGradient' => 'CoreImage.CIRadialGradient, Xamarin.Mac' */ },
		{ NULL, 0xDC562 /* #1262 'CoreImage_CIRandomGenerator' => 'CoreImage.CIRandomGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDC862 /* #1263 'CIRectangleFeature' => 'CoreImage.CIRectangleFeature, Xamarin.Mac' */ },
		{ NULL, 0xDCA62 /* #1264 'CIRenderDestination' => 'CoreImage.CIRenderDestination, Xamarin.Mac' */ },
		{ NULL, 0xDCB62 /* #1265 'CIRenderInfo' => 'CoreImage.CIRenderInfo, Xamarin.Mac' */ },
		{ NULL, 0xDCC62 /* #1266 'CIRenderTask' => 'CoreImage.CIRenderTask, Xamarin.Mac' */ },
		{ NULL, 0xDCD62 /* #1267 'CoreImage_CIRippleTransition' => 'CoreImage.CIRippleTransition, Xamarin.Mac' */ },
		{ NULL, 0xDCE62 /* #1268 'CoreImage_CIRowAverage' => 'CoreImage.CIRowAverage, Xamarin.Mac' */ },
		{ NULL, 0xDCF62 /* #1269 'CoreImage_CISaliencyMapFilter' => 'CoreImage.CISaliencyMapFilter, Xamarin.Mac' */ },
		{ NULL, 0xDD062 /* #1270 'CoreImage_CISampleNearest' => 'CoreImage.CISampleNearest, Xamarin.Mac' */ },
		{ NULL, 0xDD162 /* #1271 'CISampler' => 'CoreImage.CISampler, Xamarin.Mac' */ },
		{ NULL, 0xDD262 /* #1272 'CoreImage_CISaturationBlendMode' => 'CoreImage.CISaturationBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDD362 /* #1273 'CoreImage_CIScreenBlendMode' => 'CoreImage.CIScreenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDD562 /* #1274 'CoreImage_CISepiaTone' => 'CoreImage.CISepiaTone, Xamarin.Mac' */ },
		{ NULL, 0xDD662 /* #1275 'CoreImage_CIShadedMaterial' => 'CoreImage.CIShadedMaterial, Xamarin.Mac' */ },
		{ NULL, 0xDD762 /* #1276 'CoreImage_CISharpenLuminance' => 'CoreImage.CISharpenLuminance, Xamarin.Mac' */ },
		{ NULL, 0xDD862 /* #1277 'CoreImage_CISixfoldReflectedTile' => 'CoreImage.CISixfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xDD962 /* #1278 'CoreImage_CISixfoldRotatedTile' => 'CoreImage.CISixfoldRotatedTile, Xamarin.Mac' */ },
		{ NULL, 0xDDA62 /* #1279 'CoreImage_CISmoothLinearGradient' => 'CoreImage.CISmoothLinearGradient, Xamarin.Mac' */ },
		{ NULL, 0xDDB62 /* #1280 'CoreImage_CISoftLightBlendMode' => 'CoreImage.CISoftLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDDC62 /* #1281 'CoreImage_CISourceAtopCompositing' => 'CoreImage.CISourceAtopCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDDD62 /* #1282 'CoreImage_CISourceInCompositing' => 'CoreImage.CISourceInCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDDE62 /* #1283 'CoreImage_CISourceOutCompositing' => 'CoreImage.CISourceOutCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDDF62 /* #1284 'CoreImage_CISourceOverCompositing' => 'CoreImage.CISourceOverCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDE062 /* #1285 'CoreImage_CISpotColor' => 'CoreImage.CISpotColor, Xamarin.Mac' */ },
		{ NULL, 0xDE162 /* #1286 'CoreImage_CISpotLight' => 'CoreImage.CISpotLight, Xamarin.Mac' */ },
		{ NULL, 0xDE262 /* #1287 'CoreImage_CISRGBToneCurveToLinear' => 'CoreImage.CISRGBToneCurveToLinear, Xamarin.Mac' */ },
		{ NULL, 0xDE362 /* #1288 'CoreImage_CIStarShineGenerator' => 'CoreImage.CIStarShineGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDE462 /* #1289 'CoreImage_CIStraightenFilter' => 'CoreImage.CIStraightenFilter, Xamarin.Mac' */ },
		{ NULL, 0xDE562 /* #1290 'CoreImage_CIStretchCrop' => 'CoreImage.CIStretchCrop, Xamarin.Mac' */ },
		{ NULL, 0xDE662 /* #1291 'CoreImage_CIStripesGenerator' => 'CoreImage.CIStripesGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDE762 /* #1292 'CoreImage_CISubtractBlendMode' => 'CoreImage.CISubtractBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDE862 /* #1293 'CoreImage_CISunbeamsGenerator' => 'CoreImage.CISunbeamsGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDE962 /* #1294 'CoreImage_CISwipeTransition' => 'CoreImage.CISwipeTransition, Xamarin.Mac' */ },
		{ NULL, 0xDEA62 /* #1295 'CoreImage_CITemperatureAndTint' => 'CoreImage.CITemperatureAndTint, Xamarin.Mac' */ },
		{ NULL, 0xDEB62 /* #1296 'CITextFeature' => 'CoreImage.CITextFeature, Xamarin.Mac' */ },
		{ NULL, 0xDEC62 /* #1297 'CoreImage_CITextImageGenerator' => 'CoreImage.CITextImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDED62 /* #1298 'CoreImage_CIThermal' => 'CoreImage.CIThermal, Xamarin.Mac' */ },
		{ NULL, 0xDEF62 /* #1299 'CoreImage_CIToneCurve' => 'CoreImage.CIToneCurve, Xamarin.Mac' */ },
		{ NULL, 0xDF062 /* #1300 'CoreImage_CITorusLensDistortion' => 'CoreImage.CITorusLensDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDF262 /* #1301 'CoreImage_CITriangleKaleidoscope' => 'CoreImage.CITriangleKaleidoscope, Xamarin.Mac' */ },
		{ NULL, 0xDF362 /* #1302 'CoreImage_CITriangleTile' => 'CoreImage.CITriangleTile, Xamarin.Mac' */ },
		{ NULL, 0xDF462 /* #1303 'CoreImage_CITwelvefoldReflectedTile' => 'CoreImage.CITwelvefoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xDF562 /* #1304 'CoreImage_CITwirlDistortion' => 'CoreImage.CITwirlDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDF762 /* #1305 'CoreImage_CIUnsharpMask' => 'CoreImage.CIUnsharpMask, Xamarin.Mac' */ },
		{ NULL, 0xDF862 /* #1306 'CIVector' => 'CoreImage.CIVector, Xamarin.Mac' */ },
		{ NULL, 0xDF962 /* #1307 'CoreImage_CIVibrance' => 'CoreImage.CIVibrance, Xamarin.Mac' */ },
		{ NULL, 0xDFA62 /* #1308 'CoreImage_CIVignette' => 'CoreImage.CIVignette, Xamarin.Mac' */ },
		{ NULL, 0xDFB62 /* #1309 'CoreImage_CIVignetteEffect' => 'CoreImage.CIVignetteEffect, Xamarin.Mac' */ },
		{ NULL, 0xDFC62 /* #1310 'CoreImage_CIVortexDistortion' => 'CoreImage.CIVortexDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDFD62 /* #1311 'CIWarpKernel' => 'CoreImage.CIWarpKernel, Xamarin.Mac' */ },
		{ NULL, 0xDFE62 /* #1312 'CoreImage_CIWhitePointAdjust' => 'CoreImage.CIWhitePointAdjust, Xamarin.Mac' */ },
		{ NULL, 0xDFF62 /* #1313 'CoreImage_CIXRay' => 'CoreImage.CIXRay, Xamarin.Mac' */ },
		{ NULL, 0xE0062 /* #1314 'CoreImage_CIZoomBlur' => 'CoreImage.CIZoomBlur, Xamarin.Mac' */ },
		{ NULL, 0xE0562 /* #1315 'CoreImage_CICMYKHalftone' => 'CoreImage.CICMYKHalftone, Xamarin.Mac' */ },
		{ NULL, 0xEE962 /* #1316 'NSPersistentStoreRequest' => 'CoreData.NSPersistentStoreRequest, Xamarin.Mac' */ },
		{ NULL, 0xEB362 /* #1317 'NSAsynchronousFetchRequest' => 'CoreData.NSAsynchronousFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0xEEB62 /* #1318 'NSPersistentStoreResult' => 'CoreData.NSPersistentStoreResult, Xamarin.Mac' */ },
		{ NULL, 0xEE662 /* #1319 'NSPersistentStoreAsynchronousResult' => 'CoreData.NSPersistentStoreAsynchronousResult, Xamarin.Mac' */ },
		{ NULL, 0xEB462 /* #1320 'NSAsynchronousFetchResult' => 'CoreData.NSAsynchronousFetchResult, Xamarin.Mac' */ },
		{ NULL, 0xEE562 /* #1321 'NSPersistentStore' => 'CoreData.NSPersistentStore, Xamarin.Mac' */ },
		{ NULL, 0xEB562 /* #1322 'NSAtomicStore' => 'CoreData.NSAtomicStore, Xamarin.Mac' */ },
		{ NULL, 0xEB662 /* #1323 'NSAtomicStoreCacheNode' => 'CoreData.NSAtomicStoreCacheNode, Xamarin.Mac' */ },
		{ NULL, 0xEED62 /* #1324 'NSPropertyDescription' => 'CoreData.NSPropertyDescription, Xamarin.Mac' */ },
		{ NULL, 0xEB762 /* #1325 'NSAttributeDescription' => 'CoreData.NSAttributeDescription, Xamarin.Mac' */ },
		{ NULL, 0xEB962 /* #1326 'NSBatchDeleteRequest' => 'CoreData.NSBatchDeleteRequest, Xamarin.Mac' */ },
		{ NULL, 0xEBB62 /* #1327 'NSBatchDeleteResult' => 'CoreData.NSBatchDeleteResult, Xamarin.Mac' */ },
		{ NULL, 0xEBC62 /* #1328 'NSBatchUpdateRequest' => 'CoreData.NSBatchUpdateRequest, Xamarin.Mac' */ },
		{ NULL, 0xEBE62 /* #1329 'NSBatchUpdateResult' => 'CoreData.NSBatchUpdateResult, Xamarin.Mac' */ },
		{ NULL, 0xEBF62 /* #1330 'NSConstraintConflict' => 'CoreData.NSConstraintConflict, Xamarin.Mac' */ },
		{ NULL, 0xEC062 /* #1331 'NSCoreDataCoreSpotlightDelegate' => 'CoreData.NSCoreDataCoreSpotlightDelegate, Xamarin.Mac' */ },
		{ NULL, 0xEC262 /* #1332 'NSEntityDescription' => 'CoreData.NSEntityDescription, Xamarin.Mac' */ },
		{ NULL, 0xEC362 /* #1333 'NSEntityMapping' => 'CoreData.NSEntityMapping, Xamarin.Mac' */ },
		{ NULL, 0xEC562 /* #1334 'NSEntityMigrationPolicy' => 'CoreData.NSEntityMigrationPolicy, Xamarin.Mac' */ },
		{ NULL, 0xEC662 /* #1335 'NSExpressionDescription' => 'CoreData.NSExpressionDescription, Xamarin.Mac' */ },
		{ NULL, 0xEC762 /* #1336 'NSFetchedPropertyDescription' => 'CoreData.NSFetchedPropertyDescription, Xamarin.Mac' */ },
		{ NULL, 0xEC962 /* #1337 'NSFetchIndexDescription' => 'CoreData.NSFetchIndexDescription, Xamarin.Mac' */ },
		{ NULL, 0xECA62 /* #1338 'NSFetchIndexElementDescription' => 'CoreData.NSFetchIndexElementDescription, Xamarin.Mac' */ },
		{ NULL, 0xECC62 /* #1339 'NSFetchRequest' => 'CoreData.NSFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0x171B62 /* #1340 'NSExpression' => 'Foundation.NSExpression, Xamarin.Mac' */ },
		{ NULL, 0xECD62 /* #1341 'NSFetchRequestExpression' => 'CoreData.NSFetchRequestExpression, Xamarin.Mac' */ },
		{ NULL, 0xED162 /* #1342 'NSIncrementalStore' => 'CoreData.NSIncrementalStore, Xamarin.Mac' */ },
		{ NULL, 0xED262 /* #1343 'NSIncrementalStoreNode' => 'CoreData.NSIncrementalStoreNode, Xamarin.Mac' */ },
		{ NULL, 0xED362 /* #1344 'NSManagedObject' => 'CoreData.NSManagedObject, Xamarin.Mac' */ },
		{ NULL, 0xED662 /* #1345 'NSManagedObjectID' => 'CoreData.NSManagedObjectID, Xamarin.Mac' */ },
		{ NULL, 0xED762 /* #1346 'NSManagedObjectModel' => 'CoreData.NSManagedObjectModel, Xamarin.Mac' */ },
		{ NULL, 0xED862 /* #1347 'NSMappingModel' => 'CoreData.NSMappingModel, Xamarin.Mac' */ },
		{ NULL, 0xED962 /* #1348 'NSMergeConflict' => 'CoreData.NSMergeConflict, Xamarin.Mac' */ },
		{ NULL, 0xEDA62 /* #1349 'NSMergePolicy' => 'CoreData.NSMergePolicy, Xamarin.Mac' */ },
		{ NULL, 0xEDC62 /* #1350 'NSMigrationManager' => 'CoreData.NSMigrationManager, Xamarin.Mac' */ },
		{ NULL, 0xEDE62 /* #1351 'NSPersistentHistoryChange' => 'CoreData.NSPersistentHistoryChange, Xamarin.Mac' */ },
		{ NULL, 0xEDF62 /* #1352 'NSPersistentHistoryChangeRequest' => 'CoreData.NSPersistentHistoryChangeRequest, Xamarin.Mac' */ },
		{ NULL, 0xEE162 /* #1353 'NSPersistentHistoryResult' => 'CoreData.NSPersistentHistoryResult, Xamarin.Mac' */ },
		{ NULL, 0xEE362 /* #1354 'NSPersistentHistoryToken' => 'CoreData.NSPersistentHistoryToken, Xamarin.Mac' */ },
		{ NULL, 0xEE462 /* #1355 'NSPersistentHistoryTransaction' => 'CoreData.NSPersistentHistoryTransaction, Xamarin.Mac' */ },
		{ NULL, 0xEE862 /* #1356 'NSPersistentStoreDescription' => 'CoreData.NSPersistentStoreDescription, Xamarin.Mac' */ },
		{ NULL, 0xEEE62 /* #1357 'NSPropertyMapping' => 'CoreData.NSPropertyMapping, Xamarin.Mac' */ },
		{ NULL, 0xEEF62 /* #1358 'NSQueryGenerationToken' => 'CoreData.NSQueryGenerationToken, Xamarin.Mac' */ },
		{ NULL, 0xEF062 /* #1359 'NSRelationshipDescription' => 'CoreData.NSRelationshipDescription, Xamarin.Mac' */ },
		{ NULL, 0xEF162 /* #1360 'NSSaveChangesRequest' => 'CoreData.NSSaveChangesRequest, Xamarin.Mac' */ },
		{ NULL, 0xEFF62 /* #1361 'CBATTRequest' => 'CoreBluetooth.CBATTRequest, Xamarin.Mac' */ },
		{ NULL, 0xF0062 /* #1362 'CBAttribute' => 'CoreBluetooth.CBAttribute, Xamarin.Mac' */ },
		{ NULL, 0xF1B62 /* #1363 'CBPeer' => 'CoreBluetooth.CBPeer, Xamarin.Mac' */ },
		{ NULL, 0xF0262 /* #1364 'CBCentral' => 'CoreBluetooth.CBCentral, Xamarin.Mac' */ },
		{ NULL, 0xF0D62 /* #1365 'CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF0F62 /* #1366 'CBCharacteristic' => 'CoreBluetooth.CBCharacteristic, Xamarin.Mac' */ },
		{ NULL, 0xF1262 /* #1367 'CBDescriptor' => 'CoreBluetooth.CBDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xF1562 /* #1368 'CBL2CAPChannel' => 'CoreBluetooth.CBL2CapChannel, Xamarin.Mac' */ },
		{ NULL, 0xF1662 /* #1369 'CBManager' => 'CoreBluetooth.CBManager, Xamarin.Mac' */ },
		{ NULL, 0xF1862 /* #1370 'CBMutableCharacteristic' => 'CoreBluetooth.CBMutableCharacteristic, Xamarin.Mac' */ },
		{ NULL, 0xF1962 /* #1371 'CBMutableDescriptor' => 'CoreBluetooth.CBMutableDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xF3662 /* #1372 'CBService' => 'CoreBluetooth.CBService, Xamarin.Mac' */ },
		{ NULL, 0xF1A62 /* #1373 'CBMutableService' => 'CoreBluetooth.CBMutableService, Xamarin.Mac' */ },
		{ NULL, 0xF2662 /* #1374 'CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheralDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF3362 /* #1375 'CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF3762 /* #1376 'CBUUID' => 'CoreBluetooth.CBUUID, Xamarin.Mac' */ },
		{ NULL, 0xF3E62 /* #1377 'AUAudioUnitViewConfiguration' => 'CoreAudioKit.AUAudioUnitViewConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xF4262 /* #1378 'AUGenericView' => 'CoreAudioKit.AUGenericView, Xamarin.Mac' */ },
		{ NULL, 0xF4462 /* #1379 'AUPannerView' => 'CoreAudioKit.AUPannerView, Xamarin.Mac' */ },
		{ NULL, 0xF4562 /* #1380 'AUViewController' => 'CoreAudioKit.AUViewController, Xamarin.Mac' */ },
		{ NULL, 0x150662 /* #1381 'NSWindowController' => 'AppKit.NSWindowController, Xamarin.Mac' */ },
		{ NULL, 0xF4662 /* #1382 'CABTLEMIDIWindowController' => 'CoreAudioKit.CABtleMidiWindowController, Xamarin.Mac' */ },
		{ NULL, 0xF4762 /* #1383 'CAInterDeviceAudioViewController' => 'CoreAudioKit.CAInterDeviceAudioViewController, Xamarin.Mac' */ },
		{ NULL, 0xF4862 /* #1384 'CANetworkBrowserWindowController' => 'CoreAudioKit.CANetworkBrowserWindowController, Xamarin.Mac' */ },
		{ NULL, 0xF4B62 /* #1385 'CAAction' => 'CoreAnimation.CAAction, Xamarin.Mac' */ },
		{ NULL, 0xF5062 /* #1386 'CAAnimationDelegate' => 'CoreAnimation.CAAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF4C62 /* #1387 'CAAnimation' => 'CoreAnimation.CAAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF5162 /* #1388 'CAAnimationGroup' => 'CoreAnimation.CAAnimationGroup, Xamarin.Mac' */ },
		{ NULL, 0xF6C62 /* #1389 'CAPropertyAnimation' => 'CoreAnimation.CAPropertyAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF5262 /* #1390 'CABasicAnimation' => 'CoreAnimation.CABasicAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF5362 /* #1391 'CAConstraint' => 'CoreAnimation.CAConstraint, Xamarin.Mac' */ },
		{ NULL, 0xF5462 /* #1392 'CAConstraintLayoutManager' => 'CoreAnimation.CAConstraintLayoutManager, Xamarin.Mac' */ },
		{ NULL, 0xF5762 /* #1393 'CAEmitterBehavior' => 'CoreAnimation.CAEmitterBehavior, Xamarin.Mac' */ },
		{ NULL, 0xF5862 /* #1394 'CAEmitterCell' => 'CoreAnimation.CAEmitterCell, Xamarin.Mac' */ },
		{ NULL, 0xF5962 /* #1395 'CAEmitterLayer' => 'CoreAnimation.CAEmitterLayer, Xamarin.Mac' */ },
		{ NULL, 0xF5B62 /* #1396 'CAGradientLayer' => 'CoreAnimation.CAGradientLayer, Xamarin.Mac' */ },
		{ NULL, 0xF5E62 /* #1397 'CAKeyframeAnimation' => 'CoreAnimation.CAKeyFrameAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF6362 /* #1398 'CALayerDelegate' => 'CoreAnimation.CALayerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF6662 /* #1399 'CAMediaTiming' => 'CoreAnimation.CAMediaTiming, Xamarin.Mac' */ },
		{ NULL, 0xF6762 /* #1400 'CAMediaTimingFunction' => 'CoreAnimation.CAMediaTimingFunction, Xamarin.Mac' */ },
		{ NULL, 0xF6A62 /* #1401 'CAMetalLayer' => 'CoreAnimation.CAMetalLayer, Xamarin.Mac' */ },
		{ NULL, 0xF6D62 /* #1402 'CARenderer' => 'CoreAnimation.CARenderer, Xamarin.Mac' */ },
		{ NULL, 0xF7062 /* #1403 'CAReplicatorLayer' => 'CoreAnimation.CAReplicatorLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7362 /* #1404 'CAScrollLayer' => 'CoreAnimation.CAScrollLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7462 /* #1405 'CAShapeLayer' => 'CoreAnimation.CAShapeLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7562 /* #1406 'CASpringAnimation' => 'CoreAnimation.CASpringAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF7662 /* #1407 'CATextLayer' => 'CoreAnimation.CATextLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7B62 /* #1408 'CATiledLayer' => 'CoreAnimation.CATiledLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7C62 /* #1409 'CATransaction' => 'CoreAnimation.CATransaction, Xamarin.Mac' */ },
		{ NULL, 0xF7D62 /* #1410 'CATransformLayer' => 'CoreAnimation.CATransformLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7E62 /* #1411 'CATransition' => 'CoreAnimation.CATransition, Xamarin.Mac' */ },
		{ NULL, 0xF7F62 /* #1412 'CAValueFunction' => 'CoreAnimation.CAValueFunction, Xamarin.Mac' */ },
		{ NULL, 0xF8662 /* #1413 'CNContactPicker' => 'ContactsUI.CNContactPicker, Xamarin.Mac' */ },
		{ NULL, 0xF8A62 /* #1414 'CNContactPickerDelegate' => 'ContactsUI.CNContactPickerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF8B62 /* #1415 'CNContactViewController' => 'ContactsUI.CNContactViewController, Xamarin.Mac' */ },
		{ NULL, 0xF8F62 /* #1416 'CNContactFetchRequest' => 'Contacts.CNContactFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0xF9062 /* #1417 'CNContactFormatter' => 'Contacts.CNContactFormatter, Xamarin.Mac' */ },
		{ NULL, 0xF9362 /* #1418 'CNContactProperty' => 'Contacts.CNContactProperty, Xamarin.Mac' */ },
		{ NULL, 0xF9462 /* #1419 'CNContactRelation' => 'Contacts.CNContactRelation, Xamarin.Mac' */ },
		{ NULL, 0xF9762 /* #1420 'CNContactsUserDefaults' => 'Contacts.CNContactsUserDefaults, Xamarin.Mac' */ },
		{ NULL, 0xF9962 /* #1421 'CNContactVCardSerialization' => 'Contacts.CNContactVCardSerialization, Xamarin.Mac' */ },
		{ NULL, 0xF9A62 /* #1422 'CNContainer' => 'Contacts.CNContainer, Xamarin.Mac' */ },
		{ NULL, 0xFA262 /* #1423 'CNGroup' => 'Contacts.CNGroup, Xamarin.Mac' */ },
		{ NULL, 0xFA562 /* #1424 'CNInstantMessageAddress' => 'Contacts.CNInstantMessageAddress, Xamarin.Mac' */ },
		{ NULL, 0xFAB62 /* #1425 'CNLabeledValue' => 'Contacts.CNLabeledValue`1, Xamarin.Mac' */ },
		{ NULL, 0xF8D62 /* #1426 'CNContact' => 'Contacts.CNContact, Xamarin.Mac' */ },
		{ NULL, 0xFAE62 /* #1427 'CNMutableContact' => 'Contacts.CNMutableContact, Xamarin.Mac' */ },
		{ NULL, 0xFAF62 /* #1428 'CNMutableGroup' => 'Contacts.CNMutableGroup, Xamarin.Mac' */ },
		{ NULL, 0xFB262 /* #1429 'CNPostalAddress' => 'Contacts.CNPostalAddress, Xamarin.Mac' */ },
		{ NULL, 0xFB062 /* #1430 'CNMutablePostalAddress' => 'Contacts.CNMutablePostalAddress, Xamarin.Mac' */ },
		{ NULL, 0xFB162 /* #1431 'CNPhoneNumber' => 'Contacts.CNPhoneNumber, Xamarin.Mac' */ },
		{ NULL, 0xFB362 /* #1432 'CNPostalAddressFormatter' => 'Contacts.CNPostalAddressFormatter, Xamarin.Mac' */ },
		{ NULL, 0xFB862 /* #1433 'CNSaveRequest' => 'Contacts.CNSaveRequest, Xamarin.Mac' */ },
		{ NULL, 0xFB962 /* #1434 'CNSocialProfile' => 'Contacts.CNSocialProfile, Xamarin.Mac' */ },
		{ NULL, 0x179662 /* #1435 'NSOperation' => 'Foundation.NSOperation, Xamarin.Mac' */ },
		{ NULL, 0xFED62 /* #1436 'CKOperation' => 'CloudKit.CKOperation, Xamarin.Mac' */ },
		{ NULL, 0xFC462 /* #1437 'CKAcceptSharesOperation' => 'CloudKit.CKAcceptSharesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFC862 /* #1438 'CKAsset' => 'CloudKit.CKAsset, Xamarin.Mac' */ },
		{ NULL, 0xFE962 /* #1439 'CKNotification' => 'CloudKit.CKNotification, Xamarin.Mac' */ },
		{ NULL, 0xFCB62 /* #1440 'CKDatabaseNotification' => 'CloudKit.CKDatabaseNotification, Xamarin.Mac' */ },
		{ NULL, 0xFCC62 /* #1441 'CKDatabaseOperation' => 'CloudKit.CKDatabaseOperation, Xamarin.Mac' */ },
		{ NULL, 0x100E62 /* #1442 'CKSubscription' => 'CloudKit.CKSubscription, Xamarin.Mac' */ },
		{ NULL, 0xFCE62 /* #1443 'CKDatabaseSubscription' => 'CloudKit.CKDatabaseSubscription, Xamarin.Mac' */ },
		{ NULL, 0xFCF62 /* #1444 'CKDiscoverAllContactsOperation' => 'CloudKit.CKDiscoverAllContactsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD062 /* #1445 'CKDiscoverAllUserIdentitiesOperation' => 'CloudKit.CKDiscoverAllUserIdentitiesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD162 /* #1446 'CKDiscoveredUserInfo' => 'CloudKit.CKDiscoveredUserInfo, Xamarin.Mac' */ },
		{ NULL, 0xFD262 /* #1447 'CKDiscoverUserIdentitiesOperation' => 'CloudKit.CKDiscoverUserIdentitiesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD362 /* #1448 'CKDiscoverUserInfosOperation' => 'CloudKit.CKDiscoverUserInfosOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD762 /* #1449 'CKFetchDatabaseChangesOperation' => 'CloudKit.CKFetchDatabaseChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD862 /* #1450 'CKFetchNotificationChangesOperation' => 'CloudKit.CKFetchNotificationChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD962 /* #1451 'CKFetchRecordChangesOperation' => 'CloudKit.CKFetchRecordChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDA62 /* #1452 'CKFetchRecordsOperation' => 'CloudKit.CKFetchRecordsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDB62 /* #1453 'CKFetchRecordZoneChangesConfiguration' => 'CloudKit.CKFetchRecordZoneChangesConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xFDC62 /* #1454 'CKFetchRecordZoneChangesOperation' => 'CloudKit.CKFetchRecordZoneChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDD62 /* #1455 'CKFetchRecordZoneChangesOptions' => 'CloudKit.CKFetchRecordZoneChangesOptions, Xamarin.Mac' */ },
		{ NULL, 0xFDE62 /* #1456 'CKFetchRecordZonesOperation' => 'CloudKit.CKFetchRecordZonesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDF62 /* #1457 'CKFetchShareMetadataOperation' => 'CloudKit.CKFetchShareMetadataOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE062 /* #1458 'CKFetchShareParticipantsOperation' => 'CloudKit.CKFetchShareParticipantsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE162 /* #1459 'CKFetchSubscriptionsOperation' => 'CloudKit.CKFetchSubscriptionsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE262 /* #1460 'CKFetchWebAuthTokenOperation' => 'CloudKit.CKFetchWebAuthTokenOperation, Xamarin.Mac' */ },
		{ NULL, 0x17C262 /* #1461 'NSSortDescriptor' => 'Foundation.NSSortDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xFE362 /* #1462 'CKLocationSortDescriptor' => 'CloudKit.CKLocationSortDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xFE462 /* #1463 'CKMarkNotificationsReadOperation' => 'CloudKit.CKMarkNotificationsReadOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE562 /* #1464 'CKModifyBadgeOperation' => 'CloudKit.CKModifyBadgeOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE662 /* #1465 'CKModifyRecordsOperation' => 'CloudKit.CKModifyRecordsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE762 /* #1466 'CKModifyRecordZonesOperation' => 'CloudKit.CKModifyRecordZonesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE862 /* #1467 'CKModifySubscriptionsOperation' => 'CloudKit.CKModifySubscriptionsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFEA62 /* #1468 'CKNotificationID' => 'CloudKit.CKNotificationID, Xamarin.Mac' */ },
		{ NULL, 0xFEB62 /* #1469 'CKNotificationInfo' => 'CloudKit.CKNotificationInfo, Xamarin.Mac' */ },
		{ NULL, 0xFEE62 /* #1470 'CKOperationConfiguration' => 'CloudKit.CKOperationConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xFEF62 /* #1471 'CKOperationGroup' => 'CloudKit.CKOperationGroup, Xamarin.Mac' */ },
		{ NULL, 0xFF162 /* #1472 'CKQuery' => 'CloudKit.CKQuery, Xamarin.Mac' */ },
		{ NULL, 0xFF262 /* #1473 'CKQueryCursor' => 'CloudKit.CKQueryCursor, Xamarin.Mac' */ },
		{ NULL, 0xFF362 /* #1474 'CKQueryNotification' => 'CloudKit.CKQueryNotification, Xamarin.Mac' */ },
		{ NULL, 0xFF562 /* #1475 'CKQueryOperation' => 'CloudKit.CKQueryOperation, Xamarin.Mac' */ },
		{ NULL, 0xFF662 /* #1476 'CKQuerySubscription' => 'CloudKit.CKQuerySubscription, Xamarin.Mac' */ },
		{ NULL, 0xFF862 /* #1477 'CKRecord' => 'CloudKit.CKRecord, Xamarin.Mac' */ },
		{ NULL, 0xFF962 /* #1478 'CKRecordID' => 'CloudKit.CKRecordID, Xamarin.Mac' */ },
		{ NULL, 0xFFD62 /* #1479 'CKRecordValue' => 'CloudKit.CKRecordValue, Xamarin.Mac' */ },
		{ NULL, 0xFFE62 /* #1480 'CKRecordZone' => 'CloudKit.CKRecordZone, Xamarin.Mac' */ },
		{ NULL, 0x100062 /* #1481 'CKRecordZoneID' => 'CloudKit.CKRecordZoneID, Xamarin.Mac' */ },
		{ NULL, 0x100162 /* #1482 'CKRecordZoneNotification' => 'CloudKit.CKRecordZoneNotification, Xamarin.Mac' */ },
		{ NULL, 0x100262 /* #1483 'CKRecordZoneSubscription' => 'CloudKit.CKRecordZoneSubscription, Xamarin.Mac' */ },
		{ NULL, 0x100362 /* #1484 'CKReference' => 'CloudKit.CKReference, Xamarin.Mac' */ },
		{ NULL, 0x100562 /* #1485 'CKServerChangeToken' => 'CloudKit.CKServerChangeToken, Xamarin.Mac' */ },
		{ NULL, 0x100662 /* #1486 'CKShare' => 'CloudKit.CKShare, Xamarin.Mac' */ },
		{ NULL, 0x100862 /* #1487 'CKShareMetadata' => 'CloudKit.CKShareMetadata, Xamarin.Mac' */ },
		{ NULL, 0x100962 /* #1488 'CKShareParticipant' => 'CloudKit.CKShareParticipant, Xamarin.Mac' */ },
		{ NULL, 0x101162 /* #1489 'CKUserIdentity' => 'CloudKit.CKUserIdentity, Xamarin.Mac' */ },
		{ NULL, 0x101262 /* #1490 'CKUserIdentityLookupInfo' => 'CloudKit.CKUserIdentityLookupInfo, Xamarin.Mac' */ },
		{ NULL, 0x102462 /* #1491 'BCChatAction' => 'BusinessChat.BCChatAction, Xamarin.Mac' */ },
		{ NULL, 0x130362 /* #1492 'NSControl' => 'AppKit.NSControl, Xamarin.Mac' */ },
		{ NULL, 0x102562 /* #1493 'BCChatButton' => 'BusinessChat.BCChatButton, Xamarin.Mac' */ },
		{ NULL, 0x102962 /* #1494 'AVCaptureView' => 'AVKit.AVCaptureView, Xamarin.Mac' */ },
		{ NULL, 0x102D62 /* #1495 'AVCaptureViewDelegate' => 'AVKit.AVCaptureViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x103062 /* #1496 'AVPlayerView' => 'AVKit.AVPlayerView, Xamarin.Mac' */ },
		{ NULL, 0x103462 /* #1497 'AVAssetCache' => 'AVFoundation.AVAssetCache, Xamarin.Mac' */ },
		{ NULL, 0x103A62 /* #1498 'AVAssetImageGenerator' => 'AVFoundation.AVAssetImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0x103C62 /* #1499 'AVAssetReader' => 'AVFoundation.AVAssetReader, Xamarin.Mac' */ },
		{ NULL, 0x103E62 /* #1500 'AVAssetReaderOutput' => 'AVFoundation.AVAssetReaderOutput, Xamarin.Mac' */ },
		{ NULL, 0x103D62 /* #1501 'AVAssetReaderAudioMixOutput' => 'AVFoundation.AVAssetReaderAudioMixOutput, Xamarin.Mac' */ },
		{ NULL, 0x103F62 /* #1502 'AVAssetReaderOutputMetadataAdaptor' => 'AVFoundation.AVAssetReaderOutputMetadataAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x104062 /* #1503 'AVAssetReaderSampleReferenceOutput' => 'AVFoundation.AVAssetReaderSampleReferenceOutput, Xamarin.Mac' */ },
		{ NULL, 0x104262 /* #1504 'AVAssetReaderTrackOutput' => 'AVFoundation.AVAssetReaderTrackOutput, Xamarin.Mac' */ },
		{ NULL, 0x104362 /* #1505 'AVAssetReaderVideoCompositionOutput' => 'AVFoundation.AVAssetReaderVideoCompositionOutput, Xamarin.Mac' */ },
		{ NULL, 0x104562 /* #1506 'AVAssetResourceLoader' => 'AVFoundation.AVAssetResourceLoader, Xamarin.Mac' */ },
		{ NULL, 0x104962 /* #1507 'AVAssetResourceLoaderDelegate' => 'AVFoundation.AVAssetResourceLoaderDelegate, Xamarin.Mac' */ },
		{ NULL, 0x104A62 /* #1508 'AVAssetResourceLoadingContentInformationRequest' => 'AVFoundation.AVAssetResourceLoadingContentInformationRequest, Xamarin.Mac' */ },
		{ NULL, 0x104B62 /* #1509 'AVAssetResourceLoadingDataRequest' => 'AVFoundation.AVAssetResourceLoadingDataRequest, Xamarin.Mac' */ },
		{ NULL, 0x104C62 /* #1510 'AVAssetResourceLoadingRequest' => 'AVFoundation.AVAssetResourceLoadingRequest, Xamarin.Mac' */ },
		{ NULL, 0x104D62 /* #1511 'AVAssetResourceLoadingRequestor' => 'AVFoundation.AVAssetResourceLoadingRequestor, Xamarin.Mac' */ },
		{ NULL, 0x104E62 /* #1512 'AVAssetResourceRenewalRequest' => 'AVFoundation.AVAssetResourceRenewalRequest, Xamarin.Mac' */ },
		{ NULL, 0x105062 /* #1513 'AVAssetTrackGroup' => 'AVFoundation.AVAssetTrackGroup, Xamarin.Mac' */ },
		{ NULL, 0x105162 /* #1514 'AVAssetTrackSegment' => 'AVFoundation.AVAssetTrackSegment, Xamarin.Mac' */ },
		{ NULL, 0x105462 /* #1515 'AVAssetWriterInput' => 'AVFoundation.AVAssetWriterInput, Xamarin.Mac' */ },
		{ NULL, 0x112562 /* #1516 'AVMediaSelectionGroup' => 'AVFoundation.AVMediaSelectionGroup, Xamarin.Mac' */ },
		{ NULL, 0x105562 /* #1517 'AVAssetWriterInputGroup' => 'AVFoundation.AVAssetWriterInputGroup, Xamarin.Mac' */ },
		{ NULL, 0x105862 /* #1518 'AVAssetWriterInputMetadataAdaptor' => 'AVFoundation.AVAssetWriterInputMetadataAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x105962 /* #1519 'AVAssetWriterInputPassDescription' => 'AVFoundation.AVAssetWriterInputPassDescription, Xamarin.Mac' */ },
		{ NULL, 0x105A62 /* #1520 'AVAssetWriterInputPixelBufferAdaptor' => 'AVFoundation.AVAssetWriterInputPixelBufferAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x105C62 /* #1521 'AVAsynchronousCIImageFilteringRequest' => 'AVFoundation.AVAsynchronousCIImageFilteringRequest, Xamarin.Mac' */ },
		{ NULL, 0x105F62 /* #1522 'AVAsynchronousKeyValueLoading' => 'AVFoundation.AVAsynchronousKeyValueLoading, Xamarin.Mac' */ },
		{ NULL, 0x106062 /* #1523 'AVAsynchronousVideoCompositionRequest' => 'AVFoundation.AVAsynchronousVideoCompositionRequest, Xamarin.Mac' */ },
		{ NULL, 0x106362 /* #1524 'AVAudio3DMixing' => 'AVFoundation.AVAudio3DMixing, Xamarin.Mac' */ },
		{ NULL, 0x106662 /* #1525 'AVAudioBuffer' => 'AVFoundation.AVAudioBuffer, Xamarin.Mac' */ },
		{ NULL, 0x106762 /* #1526 'AVAudioChannelLayout' => 'AVFoundation.AVAudioChannelLayout, Xamarin.Mac' */ },
		{ NULL, 0x106962 /* #1527 'AVAudioCompressedBuffer' => 'AVFoundation.AVAudioCompressedBuffer, Xamarin.Mac' */ },
		{ NULL, 0x106A62 /* #1528 'AVAudioConnectionPoint' => 'AVFoundation.AVAudioConnectionPoint, Xamarin.Mac' */ },
		{ NULL, 0x106B62 /* #1529 'AVAudioConverter' => 'AVFoundation.AVAudioConverter, Xamarin.Mac' */ },
		{ NULL, 0x107462 /* #1530 'AVAudioEnvironmentDistanceAttenuationParameters' => 'AVFoundation.AVAudioEnvironmentDistanceAttenuationParameters, Xamarin.Mac' */ },
		{ NULL, 0x108262 /* #1531 'AVAudioNode' => 'AVFoundation.AVAudioNode, Xamarin.Mac' */ },
		{ NULL, 0x107562 /* #1532 'AVAudioEnvironmentNode' => 'AVFoundation.AVAudioEnvironmentNode, Xamarin.Mac' */ },
		{ NULL, 0x107662 /* #1533 'AVAudioEnvironmentReverbParameters' => 'AVFoundation.AVAudioEnvironmentReverbParameters, Xamarin.Mac' */ },
		{ NULL, 0x107762 /* #1534 'AVAudioFile' => 'AVFoundation.AVAudioFile, Xamarin.Mac' */ },
		{ NULL, 0x107862 /* #1535 'AVAudioFormat' => 'AVFoundation.AVAudioFormat, Xamarin.Mac' */ },
		{ NULL, 0x107A62 /* #1536 'AVAudioIONode' => 'AVFoundation.AVAudioIONode, Xamarin.Mac' */ },
		{ NULL, 0x107962 /* #1537 'AVAudioInputNode' => 'AVFoundation.AVAudioInputNode, Xamarin.Mac' */ },
		{ NULL, 0x107B62 /* #1538 'AVAudioMix' => 'AVFoundation.AVAudioMix, Xamarin.Mac' */ },
		{ NULL, 0x107C62 /* #1539 'AVAudioMixerNode' => 'AVFoundation.AVAudioMixerNode, Xamarin.Mac' */ },
		{ NULL, 0x108062 /* #1540 'AVAudioMixingDestination' => 'AVFoundation.AVAudioMixingDestination, Xamarin.Mac' */ },
		{ NULL, 0x108162 /* #1541 'AVAudioMixInputParameters' => 'AVFoundation.AVAudioMixInputParameters, Xamarin.Mac' */ },
		{ NULL, 0x108362 /* #1542 'AVAudioOutputNode' => 'AVFoundation.AVAudioOutputNode, Xamarin.Mac' */ },
		{ NULL, 0x108462 /* #1543 'AVAudioPCMBuffer' => 'AVFoundation.AVAudioPcmBuffer, Xamarin.Mac' */ },
		{ NULL, 0x108562 /* #1544 'AVAudioPlayer' => 'AVFoundation.AVAudioPlayer, Xamarin.Mac' */ },
		{ NULL, 0x108962 /* #1545 'AVAudioPlayerDelegate' => 'AVFoundation.AVAudioPlayerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x108E62 /* #1546 'AVAudioRecorder' => 'AVFoundation.AVAudioRecorder, Xamarin.Mac' */ },
		{ NULL, 0x109262 /* #1547 'AVAudioRecorderDelegate' => 'AVFoundation.AVAudioRecorderDelegate, Xamarin.Mac' */ },
		{ NULL, 0x109362 /* #1548 'AVAudioSequencer' => 'AVFoundation.AVAudioSequencer, Xamarin.Mac' */ },
		{ NULL, 0x10A362 /* #1549 'AVAudioStereoMixing' => 'AVFoundation.AVAudioStereoMixing, Xamarin.Mac' */ },
		{ NULL, 0x10A462 /* #1550 'AVAudioTime' => 'AVFoundation.AVAudioTime, Xamarin.Mac' */ },
		{ NULL, 0x10A862 /* #1551 'AVAudioUnitComponentManager' => 'AVFoundation.AVAudioUnitComponentManager, Xamarin.Mac' */ },
		{ NULL, 0x10A662 /* #1552 'AVAudioUnit' => 'AVFoundation.AVAudioUnit, Xamarin.Mac' */ },
		{ NULL, 0x10AC62 /* #1553 'AVAudioUnitEffect' => 'AVFoundation.AVAudioUnitEffect, Xamarin.Mac' */ },
		{ NULL, 0x10A962 /* #1554 'AVAudioUnitDelay' => 'AVFoundation.AVAudioUnitDelay, Xamarin.Mac' */ },
		{ NULL, 0x10AA62 /* #1555 'AVAudioUnitDistortion' => 'AVFoundation.AVAudioUnitDistortion, Xamarin.Mac' */ },
		{ NULL, 0x10AD62 /* #1556 'AVAudioUnitEQ' => 'AVFoundation.AVAudioUnitEQ, Xamarin.Mac' */ },
		{ NULL, 0x10AE62 /* #1557 'AVAudioUnitEQFilterParameters' => 'AVFoundation.AVAudioUnitEQFilterParameters, Xamarin.Mac' */ },
		{ NULL, 0x10B062 /* #1558 'AVAudioUnitGenerator' => 'AVFoundation.AVAudioUnitGenerator, Xamarin.Mac' */ },
		{ NULL, 0x10B262 /* #1559 'AVAudioUnitMIDIInstrument' => 'AVFoundation.AVAudioUnitMidiInstrument, Xamarin.Mac' */ },
		{ NULL, 0x10B362 /* #1560 'AVAudioUnitReverb' => 'AVFoundation.AVAudioUnitReverb, Xamarin.Mac' */ },
		{ NULL, 0x10B562 /* #1561 'AVAudioUnitSampler' => 'AVFoundation.AVAudioUnitSampler, Xamarin.Mac' */ },
		{ NULL, 0x10B662 /* #1562 'AVAudioUnitTimeEffect' => 'AVFoundation.AVAudioUnitTimeEffect, Xamarin.Mac' */ },
		{ NULL, 0x10B762 /* #1563 'AVAudioUnitTimePitch' => 'AVFoundation.AVAudioUnitTimePitch, Xamarin.Mac' */ },
		{ NULL, 0x10B962 /* #1564 'AVAudioUnitVarispeed' => 'AVFoundation.AVAudioUnitVarispeed, Xamarin.Mac' */ },
		{ NULL, 0x10BC62 /* #1565 'AVCameraCalibrationData' => 'AVFoundation.AVCameraCalibrationData, Xamarin.Mac' */ },
		{ NULL, 0x10BD62 /* #1566 'AVCaptureAudioChannel' => 'AVFoundation.AVCaptureAudioChannel, Xamarin.Mac' */ },
		{ NULL, 0x10DE62 /* #1567 'AVCaptureOutput' => 'AVFoundation.AVCaptureOutput, Xamarin.Mac' */ },
		{ NULL, 0x10BE62 /* #1568 'AVCaptureAudioDataOutput' => 'AVFoundation.AVCaptureAudioDataOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C262 /* #1569 'AVCaptureAudioDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate, Xamarin.Mac' */ },
		{ NULL, 0x10CF62 /* #1570 'AVCaptureFileOutput' => 'AVFoundation.AVCaptureFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C362 /* #1571 'AVCaptureAudioFileOutput' => 'AVFoundation.AVCaptureAudioFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C462 /* #1572 'AVCaptureAudioPreviewOutput' => 'AVFoundation.AVCaptureAudioPreviewOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C762 /* #1573 'AVCaptureConnection' => 'AVFoundation.AVCaptureConnection, Xamarin.Mac' */ },
		{ NULL, 0x10C962 /* #1574 'AVCaptureDeviceFormat' => 'AVFoundation.AVCaptureDeviceFormat, Xamarin.Mac' */ },
		{ NULL, 0x10DA62 /* #1575 'AVCaptureInput' => 'AVFoundation.AVCaptureInput, Xamarin.Mac' */ },
		{ NULL, 0x10CA62 /* #1576 'AVCaptureDeviceInput' => 'AVFoundation.AVCaptureDeviceInput, Xamarin.Mac' */ },
		{ NULL, 0x10CB62 /* #1577 'AVCaptureDeviceInputSource' => 'AVFoundation.AVCaptureDeviceInputSource, Xamarin.Mac' */ },
		{ NULL, 0x10D362 /* #1578 'AVCaptureFileOutputDelegate' => 'AVFoundation.AVCaptureFileOutputDelegate, Xamarin.Mac' */ },
		{ NULL, 0x10D762 /* #1579 'AVCaptureFileOutputRecordingDelegate' => 'AVFoundation.AVCaptureFileOutputRecordingDelegate, Xamarin.Mac' */ },
		{ NULL, 0x10DB62 /* #1580 'AVCaptureInputPort' => 'AVFoundation.AVCaptureInputPort, Xamarin.Mac' */ },
		{ NULL, 0x10DD62 /* #1581 'AVCaptureMovieFileOutput' => 'AVFoundation.AVCaptureMovieFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x10E062 /* #1582 'AVCaptureScreenInput' => 'AVFoundation.AVCaptureScreenInput, Xamarin.Mac' */ },
		{ NULL, 0x10E362 /* #1583 'AVCaptureSynchronizedData' => 'AVFoundation.AVCaptureSynchronizedData, Xamarin.Mac' */ },
		{ NULL, 0x10E462 /* #1584 'AVCaptureSynchronizedDataCollection' => 'AVFoundation.AVCaptureSynchronizedDataCollection, Xamarin.Mac' */ },
		{ NULL, 0x10E662 /* #1585 'AVCaptureVideoDataOutput' => 'AVFoundation.AVCaptureVideoDataOutput, Xamarin.Mac' */ },
		{ NULL, 0x10EA62 /* #1586 'AVCaptureVideoDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate, Xamarin.Mac' */ },
		{ NULL, 0x103362 /* #1587 'AVAsset' => 'AVFoundation.AVAsset, Xamarin.Mac' */ },
		{ NULL, 0x10F362 /* #1588 'AVComposition' => 'AVFoundation.AVComposition, Xamarin.Mac' */ },
		{ NULL, 0x104F62 /* #1589 'AVAssetTrack' => 'AVFoundation.AVAssetTrack, Xamarin.Mac' */ },
		{ NULL, 0x10F562 /* #1590 'AVCompositionTrack' => 'AVFoundation.AVCompositionTrack, Xamarin.Mac' */ },
		{ NULL, 0x10F662 /* #1591 'AVCompositionTrackSegment' => 'AVFoundation.AVCompositionTrackSegment, Xamarin.Mac' */ },
		{ NULL, 0x110162 /* #1592 'AVContentKeyResponse' => 'AVFoundation.AVContentKeyResponse, Xamarin.Mac' */ },
		{ NULL, 0x110262 /* #1593 'AVContentKeySession' => 'AVFoundation.AVContentKeySession, Xamarin.Mac' */ },
		{ NULL, 0x110762 /* #1594 'AVContentKeySessionDelegate' => 'AVFoundation.AVContentKeySessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x112F62 /* #1595 'AVMetadataGroup' => 'AVFoundation.AVMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x110A62 /* #1596 'AVDateRangeMetadataGroup' => 'AVFoundation.AVDateRangeMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x110B62 /* #1597 'AVDepthData' => 'AVFoundation.AVDepthData, Xamarin.Mac' */ },
		{ NULL, 0x119462 /* #1598 'AVURLAsset' => 'AVFoundation.AVUrlAsset, Xamarin.Mac' */ },
		{ NULL, 0x111362 /* #1599 'AVFragmentedAsset' => 'AVFoundation.AVFragmentedAsset, Xamarin.Mac' */ },
		{ NULL, 0x111562 /* #1600 'AVFragmentedAssetMinder' => 'AVFoundation.AVFragmentedAssetMinder, Xamarin.Mac' */ },
		{ NULL, 0x111662 /* #1601 'AVFragmentedAssetTrack' => 'AVFoundation.AVFragmentedAssetTrack, Xamarin.Mac' */ },
		{ NULL, 0x111962 /* #1602 'AVFragmentedMovieMinder' => 'AVFoundation.AVFragmentedMovieMinder, Xamarin.Mac' */ },
		{ NULL, 0x111E62 /* #1603 'AVFrameRateRange' => 'AVFoundation.AVFrameRateRange, Xamarin.Mac' */ },
		{ NULL, 0x112362 /* #1604 'AVMediaDataStorage' => 'AVFoundation.AVMediaDataStorage, Xamarin.Mac' */ },
		{ NULL, 0x112462 /* #1605 'AVMediaSelection' => 'AVFoundation.AVMediaSelection, Xamarin.Mac' */ },
		{ NULL, 0x112662 /* #1606 'AVMediaSelectionOption' => 'AVFoundation.AVMediaSelectionOption, Xamarin.Mac' */ },
		{ NULL, 0x113362 /* #1607 'AVMetadataObject' => 'AVFoundation.AVMetadataObject, Xamarin.Mac' */ },
		{ NULL, 0x112C62 /* #1608 'AVMetadataFaceObject' => 'AVFoundation.AVMetadataFaceObject, Xamarin.Mac' */ },
		{ NULL, 0x113162 /* #1609 'AVMetadataItemFilter' => 'AVFoundation.AVMetadataItemFilter, Xamarin.Mac' */ },
		{ NULL, 0x113262 /* #1610 'AVMetadataItemValueRequest' => 'AVFoundation.AVMetadataItemValueRequest, Xamarin.Mac' */ },
		{ NULL, 0x113662 /* #1611 'AVMovie' => 'AVFoundation.AVMovie, Xamarin.Mac' */ },
		{ NULL, 0x113962 /* #1612 'AVMovieTrack' => 'AVFoundation.AVMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x113C62 /* #1613 'AVMusicTrack' => 'AVFoundation.AVMusicTrack, Xamarin.Mac' */ },
		{ NULL, 0x113E62 /* #1614 'AVMutableAudioMix' => 'AVFoundation.AVMutableAudioMix, Xamarin.Mac' */ },
		{ NULL, 0x113F62 /* #1615 'AVMutableAudioMixInputParameters' => 'AVFoundation.AVMutableAudioMixInputParameters, Xamarin.Mac' */ },
		{ NULL, 0x114062 /* #1616 'AVMutableComposition' => 'AVFoundation.AVMutableComposition, Xamarin.Mac' */ },
		{ NULL, 0x114262 /* #1617 'AVMutableCompositionTrack' => 'AVFoundation.AVMutableCompositionTrack, Xamarin.Mac' */ },
		{ NULL, 0x114362 /* #1618 'AVMutableDateRangeMetadataGroup' => 'AVFoundation.AVMutableDateRangeMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x114462 /* #1619 'AVMutableMediaSelection' => 'AVFoundation.AVMutableMediaSelection, Xamarin.Mac' */ },
		{ NULL, 0x113062 /* #1620 'AVMetadataItem' => 'AVFoundation.AVMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x114562 /* #1621 'AVMutableMetadataItem' => 'AVFoundation.AVMutableMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x114662 /* #1622 'AVMutableMovie' => 'AVFoundation.AVMutableMovie, Xamarin.Mac' */ },
		{ NULL, 0x114A62 /* #1623 'AVMutableMovieTrack' => 'AVFoundation.AVMutableMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x119362 /* #1624 'AVTimedMetadataGroup' => 'AVFoundation.AVTimedMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x114D62 /* #1625 'AVMutableTimedMetadataGroup' => 'AVFoundation.AVMutableTimedMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x119F62 /* #1626 'AVVideoComposition' => 'AVFoundation.AVVideoComposition, Xamarin.Mac' */ },
		{ NULL, 0x114E62 /* #1627 'AVMutableVideoComposition' => 'AVFoundation.AVMutableVideoComposition, Xamarin.Mac' */ },
		{ NULL, 0x11A162 /* #1628 'AVVideoCompositionInstruction' => 'AVFoundation.AVVideoCompositionInstruction, Xamarin.Mac' */ },
		{ NULL, 0x114F62 /* #1629 'AVMutableVideoCompositionInstruction' => 'AVFoundation.AVMutableVideoCompositionInstruction, Xamarin.Mac' */ },
		{ NULL, 0x11A262 /* #1630 'AVVideoCompositionLayerInstruction' => 'AVFoundation.AVVideoCompositionLayerInstruction, Xamarin.Mac' */ },
		{ NULL, 0x115062 /* #1631 'AVMutableVideoCompositionLayerInstruction' => 'AVFoundation.AVMutableVideoCompositionLayerInstruction, Xamarin.Mac' */ },
		{ NULL, 0x115162 /* #1632 'AVOutputSettingsAssistant' => 'AVFoundation.AVOutputSettingsAssistant, Xamarin.Mac' */ },
		{ NULL, 0x10FC62 /* #1633 'AVContentKeyRequest' => 'AVFoundation.AVContentKeyRequest, Xamarin.Mac' */ },
		{ NULL, 0x115262 /* #1634 'AVPersistableContentKeyRequest' => 'AVFoundation.AVPersistableContentKeyRequest, Xamarin.Mac' */ },
		{ NULL, 0x115962 /* #1635 'AVPlayerItemAccessLog' => 'AVFoundation.AVPlayerItemAccessLog, Xamarin.Mac' */ },
		{ NULL, 0x115A62 /* #1636 'AVPlayerItemAccessLogEvent' => 'AVFoundation.AVPlayerItemAccessLogEvent, Xamarin.Mac' */ },
		{ NULL, 0x115B62 /* #1637 'AVPlayerItemErrorLog' => 'AVFoundation.AVPlayerItemErrorLog, Xamarin.Mac' */ },
		{ NULL, 0x115C62 /* #1638 'AVPlayerItemErrorLogEvent' => 'AVFoundation.AVPlayerItemErrorLogEvent, Xamarin.Mac' */ },
		{ NULL, 0x116C62 /* #1639 'AVPlayerItemOutput' => 'AVFoundation.AVPlayerItemOutput, Xamarin.Mac' */ },
		{ NULL, 0x115D62 /* #1640 'AVPlayerItemLegibleOutput' => 'AVFoundation.AVPlayerItemLegibleOutput, Xamarin.Mac' */ },
		{ NULL, 0x117462 /* #1641 'AVPlayerItemOutputPushDelegate' => 'AVFoundation.AVPlayerItemOutputPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x116162 /* #1642 'AVPlayerItemLegibleOutputPushDelegate' => 'AVFoundation.AVPlayerItemLegibleOutputPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x116262 /* #1643 'AVPlayerItemMediaDataCollector' => 'AVFoundation.AVPlayerItemMediaDataCollector, Xamarin.Mac' */ },
		{ NULL, 0x116362 /* #1644 'AVPlayerItemMetadataCollector' => 'AVFoundation.AVPlayerItemMetadataCollector, Xamarin.Mac' */ },
		{ NULL, 0x116662 /* #1645 'AVPlayerItemMetadataCollectorPushDelegate' => 'AVFoundation.AVPlayerItemMetadataCollectorPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x116762 /* #1646 'AVPlayerItemMetadataOutput' => 'AVFoundation.AVPlayerItemMetadataOutput, Xamarin.Mac' */ },
		{ NULL, 0x116B62 /* #1647 'AVPlayerItemMetadataOutputPushDelegate' => 'AVFoundation.AVPlayerItemMetadataOutputPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x117062 /* #1648 'AVPlayerItemOutputPullDelegate' => 'AVFoundation.AVPlayerItemOutputPullDelegate, Xamarin.Mac' */ },
		{ NULL, 0x117662 /* #1649 'AVPlayerItemTrack' => 'AVFoundation.AVPlayerItemTrack, Xamarin.Mac' */ },
		{ NULL, 0x117A62 /* #1650 'AVPlayerLayer' => 'AVFoundation.AVPlayerLayer, Xamarin.Mac' */ },
		{ NULL, 0x117B62 /* #1651 'AVPlayerLooper' => 'AVFoundation.AVPlayerLooper, Xamarin.Mac' */ },
		{ NULL, 0x117D62 /* #1652 'AVPlayerMediaSelectionCriteria' => 'AVFoundation.AVPlayerMediaSelectionCriteria, Xamarin.Mac' */ },
		{ NULL, 0x118062 /* #1653 'AVPortraitEffectsMatte' => 'AVFoundation.AVPortraitEffectsMatte, Xamarin.Mac' */ },
		{ NULL, 0x115562 /* #1654 'AVPlayer' => 'AVFoundation.AVPlayer, Xamarin.Mac' */ },
		{ NULL, 0x118462 /* #1655 'AVQueuePlayer' => 'AVFoundation.AVQueuePlayer, Xamarin.Mac' */ },
		{ NULL, 0x118A62 /* #1656 'AVSampleBufferRequest' => 'AVFoundation.AVSampleBufferRequest, Xamarin.Mac' */ },
		{ NULL, 0x118D62 /* #1657 'AVSampleCursor' => 'AVFoundation.AVSampleCursor, Xamarin.Mac' */ },
		{ NULL, 0x119162 /* #1658 'AVSynchronizedLayer' => 'AVFoundation.AVSynchronizedLayer, Xamarin.Mac' */ },
		{ NULL, 0x119262 /* #1659 'AVTextStyleRule' => 'AVFoundation.AVTextStyleRule, Xamarin.Mac' */ },
		{ NULL, 0x119E62 /* #1660 'AVVideoCompositing' => 'AVFoundation.AVVideoCompositing, Xamarin.Mac' */ },
		{ NULL, 0x11A062 /* #1661 'AVVideoCompositionCoreAnimationTool' => 'AVFoundation.AVVideoCompositionCoreAnimationTool, Xamarin.Mac' */ },
		{ NULL, 0x11A362 /* #1662 'AVVideoCompositionRenderContext' => 'AVFoundation.AVVideoCompositionRenderContext, Xamarin.Mac' */ },
		{ NULL, 0x11A762 /* #1663 'AVVideoCompositionValidationHandling' => 'AVFoundation.AVVideoCompositionValidationHandling, Xamarin.Mac' */ },
		{ NULL, 0x11B962 /* #1664 'AVFoundation_AVCaptureDataOutputSynchronizer' => 'AVFoundation.AVCaptureDataOutputSynchronizer, Xamarin.Mac' */ },
		{ NULL, 0x11BB62 /* #1665 'AVFoundation_AVCaptureDataOutputSynchronizerDelegate' => 'AVFoundation.AVCaptureDataOutputSynchronizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11BF62 /* #1666 'AVFoundation_InternalAVAudioPlayerDelegate' => 'AVFoundation.InternalAVAudioPlayerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11C062 /* #1667 'AVFoundation_InternalAVAudioRecorderDelegate' => 'AVFoundation.InternalAVAudioRecorderDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11DE62 /* #1668 'AUAudioUnitBus' => 'AudioUnit.AUAudioUnitBus, Xamarin.Mac' */ },
		{ NULL, 0x11DF62 /* #1669 'AUAudioUnitBusArray' => 'AudioUnit.AUAudioUnitBusArray, Xamarin.Mac' */ },
		{ NULL, 0x11E262 /* #1670 'AUAudioUnitPreset' => 'AudioUnit.AUAudioUnitPreset, Xamarin.Mac' */ },
		{ NULL, 0x11E562 /* #1671 'AUParameterNode' => 'AudioUnit.AUParameterNode, Xamarin.Mac' */ },
		{ NULL, 0x11E362 /* #1672 'AUParameter' => 'AudioUnit.AUParameter, Xamarin.Mac' */ },
		{ NULL, 0x11E462 /* #1673 'AUParameterGroup' => 'AudioUnit.AUParameterGroup, Xamarin.Mac' */ },
		{ NULL, 0x11E662 /* #1674 'AUParameterTree' => 'AudioUnit.AUParameterTree, Xamarin.Mac' */ },
		{ NULL, 0x125462 /* #1675 'NSAccessibilityCustomAction' => 'AppKit.NSAccessibilityCustomAction, Xamarin.Mac' */ },
		{ NULL, 0x125562 /* #1676 'NSAccessibilityCustomRotor' => 'AppKit.NSAccessibilityCustomRotor, Xamarin.Mac' */ },
		{ NULL, 0x125662 /* #1677 'NSAccessibilityCustomRotorItemResult' => 'AppKit.NSAccessibilityCustomRotorItemResult, Xamarin.Mac' */ },
		{ NULL, 0x125962 /* #1678 'NSAccessibilityCustomRotorItemSearchDelegate' => 'AppKit.NSAccessibilityCustomRotorItemSearchDelegate, Xamarin.Mac' */ },
		{ NULL, 0x125A62 /* #1679 'NSAccessibilityCustomRotorSearchParameters' => 'AppKit.NSAccessibilityCustomRotorSearchParameters, Xamarin.Mac' */ },
		{ NULL, 0x12C062 /* #1680 'NSCell' => 'AppKit.NSCell, Xamarin.Mac' */ },
		{ NULL, 0x128762 /* #1681 'NSActionCell' => 'AppKit.NSActionCell, Xamarin.Mac' */ },
		{ NULL, 0x128C62 /* #1682 'NSAlertDelegate' => 'AppKit.NSAlertDelegate, Xamarin.Mac' */ },
		{ NULL, 0x128D62 /* #1683 'NSAlignmentFeedbackFilter' => 'AppKit.NSAlignmentFeedbackFilter, Xamarin.Mac' */ },
		{ NULL, 0x129062 /* #1684 'NSAlignmentFeedbackToken' => 'AppKit.NSAlignmentFeedbackToken, Xamarin.Mac' */ },
		{ NULL, 0x129362 /* #1685 'NSAnimationContext' => 'AppKit.NSAnimationContext, Xamarin.Mac' */ },
		{ NULL, 0x129762 /* #1686 'NSAnimationDelegate' => 'AppKit.NSAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x129862 /* #1687 'NSAppearance' => 'AppKit.NSAppearance, Xamarin.Mac' */ },
		{ NULL, 0x129C62 /* #1688 'NSAppearanceCustomization' => 'AppKit.NSAppearanceCustomization, Xamarin.Mac' */ },
		{ NULL, 0x12AB62 /* #1689 'NSApplicationDelegate' => 'AppKit.NSApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130562 /* #1690 'NSController' => 'AppKit.NSController, Xamarin.Mac' */ },
		{ NULL, 0x139462 /* #1691 'NSObjectController' => 'AppKit.NSObjectController, Xamarin.Mac' */ },
		{ NULL, 0x12AC62 /* #1692 'NSArrayController' => 'AppKit.NSArrayController, Xamarin.Mac' */ },
		{ NULL, 0x14EC62 /* #1693 'NSTypesetter' => 'AppKit.NSTypesetter, Xamarin.Mac' */ },
		{ NULL, 0x12AD62 /* #1694 'NSATSTypesetter' => 'AppKit.NSATSTypesetter, Xamarin.Mac' */ },
		{ NULL, 0x12AF62 /* #1695 'NSBezierPath' => 'AppKit.NSBezierPath, Xamarin.Mac' */ },
		{ NULL, 0x136A62 /* #1696 'NSImageRep' => 'AppKit.NSImageRep, Xamarin.Mac' */ },
		{ NULL, 0x12B062 /* #1697 'NSBitmapImageRep' => 'AppKit.NSBitmapImageRep, Xamarin.Mac' */ },
		{ NULL, 0x12B162 /* #1698 'NSBox' => 'AppKit.NSBox, Xamarin.Mac' */ },
		{ NULL, 0x12B362 /* #1699 'NSBrowserCell' => 'AppKit.NSBrowserCell, Xamarin.Mac' */ },
		{ NULL, 0x12B762 /* #1700 'NSBrowserDelegate' => 'AppKit.NSBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12B862 /* #1701 'NSButton' => 'AppKit.NSButton, Xamarin.Mac' */ },
		{ NULL, 0x12B962 /* #1702 'NSButtonCell' => 'AppKit.NSButtonCell, Xamarin.Mac' */ },
		{ NULL, 0x12BA62 /* #1703 'NSCachedImageRep' => 'AppKit.NSCachedImageRep, Xamarin.Mac' */ },
		{ NULL, 0x14E462 /* #1704 'NSTouchBarItem' => 'AppKit.NSTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x12BB62 /* #1705 'NSCandidateListTouchBarItem' => 'AppKit.NSCandidateListTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x12BF62 /* #1706 'NSCandidateListTouchBarItemDelegate' => 'AppKit.NSCandidateListTouchBarItemDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12C162 /* #1707 'NSCIImageRep' => 'AppKit.NSCIImageRep, Xamarin.Mac' */ },
		{ NULL, 0x12C362 /* #1708 'NSClipView' => 'AppKit.NSClipView, Xamarin.Mac' */ },
		{ NULL, 0x142D62 /* #1709 'NSSharingServiceDelegate' => 'AppKit.NSSharingServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12C762 /* #1710 'NSCloudSharingServiceDelegate' => 'AppKit.NSCloudSharingServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12CC62 /* #1711 'NSCollectionView' => 'AppKit.NSCollectionView, Xamarin.Mac' */ },
		{ NULL, 0x12D062 /* #1712 'NSCollectionViewDataSource' => 'AppKit.NSCollectionViewDataSource, Xamarin.Mac' */ },
		{ NULL, 0x12D462 /* #1713 'NSCollectionViewDelegate' => 'AppKit.NSCollectionViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12D862 /* #1714 'NSCollectionViewDelegateFlowLayout' => 'AppKit.NSCollectionViewDelegateFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x12DC62 /* #1715 'NSCollectionViewElement' => 'AppKit.NSCollectionViewElement, Xamarin.Mac' */ },
		{ NULL, 0x12E162 /* #1716 'NSCollectionViewLayout' => 'AppKit.NSCollectionViewLayout, Xamarin.Mac' */ },
		{ NULL, 0x12DD62 /* #1717 'NSCollectionViewFlowLayout' => 'AppKit.NSCollectionViewFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x12E362 /* #1718 'NSCollectionViewLayoutInvalidationContext' => 'AppKit.NSCollectionViewLayoutInvalidationContext, Xamarin.Mac' */ },
		{ NULL, 0x12DE62 /* #1719 'NSCollectionViewFlowLayoutInvalidationContext' => 'AppKit.NSCollectionViewFlowLayoutInvalidationContext, Xamarin.Mac' */ },
		{ NULL, 0x12DF62 /* #1720 'NSCollectionViewGridLayout' => 'AppKit.NSCollectionViewGridLayout, Xamarin.Mac' */ },
		{ NULL, 0x12E062 /* #1721 'NSCollectionViewItem' => 'AppKit.NSCollectionViewItem, Xamarin.Mac' */ },
		{ NULL, 0x12E262 /* #1722 'NSCollectionViewLayoutAttributes' => 'AppKit.NSCollectionViewLayoutAttributes, Xamarin.Mac' */ },
		{ NULL, 0x12EA62 /* #1723 'NSCollectionViewTransitionLayout' => 'AppKit.NSCollectionViewTransitionLayout, Xamarin.Mac' */ },
		{ NULL, 0x12EB62 /* #1724 'NSCollectionViewUpdateItem' => 'AppKit.NSCollectionViewUpdateItem, Xamarin.Mac' */ },
		{ NULL, 0x12EF62 /* #1725 'NSColorList' => 'AppKit.NSColorList, Xamarin.Mac' */ },
		{ NULL, 0x12F162 /* #1726 'NSColorPicker' => 'AppKit.NSColorPicker, Xamarin.Mac' */ },
		{ NULL, 0x12F262 /* #1727 'NSColorPickerTouchBarItem' => 'AppKit.NSColorPickerTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x12F362 /* #1728 'NSColorSpace' => 'AppKit.NSColorSpace, Xamarin.Mac' */ },
		{ NULL, 0x12F462 /* #1729 'NSColorWell' => 'AppKit.NSColorWell, Xamarin.Mac' */ },
		{ NULL, 0x149D62 /* #1730 'NSTextFieldCell' => 'AppKit.NSTextFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x12F662 /* #1731 'NSComboBoxCell' => 'AppKit.NSComboBoxCell, Xamarin.Mac' */ },
		{ NULL, 0x12FA62 /* #1732 'NSComboBoxCellDataSource' => 'AppKit.NSComboBoxCellDataSource, Xamarin.Mac' */ },
		{ NULL, 0x12FE62 /* #1733 'NSComboBoxDataSource' => 'AppKit.NSComboBoxDataSource, Xamarin.Mac' */ },
		{ NULL, 0x14A162 /* #1734 'NSTextFieldDelegate' => 'AppKit.NSTextFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130262 /* #1735 'NSComboBoxDelegate' => 'AppKit.NSComboBoxDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130962 /* #1736 'NSControlTextEditingDelegate' => 'AppKit.NSControlTextEditingDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130A62 /* #1737 'NSCursor' => 'AppKit.NSCursor, Xamarin.Mac' */ },
		{ NULL, 0x130B62 /* #1738 'NSCustomImageRep' => 'AppKit.NSCustomImageRep, Xamarin.Mac' */ },
		{ NULL, 0x130C62 /* #1739 'NSCustomTouchBarItem' => 'AppKit.NSCustomTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x130D62 /* #1740 'NSDataAsset' => 'AppKit.NSDataAsset, Xamarin.Mac' */ },
		{ NULL, 0x131462 /* #1741 'NSDatePickerCellDelegate' => 'AppKit.NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x131562 /* #1742 'NSDictionaryController' => 'AppKit.NSDictionaryController, Xamarin.Mac' */ },
		{ NULL, 0x131662 /* #1743 'NSDictionaryControllerKeyValuePair' => 'AppKit.NSDictionaryControllerKeyValuePair, Xamarin.Mac' */ },
		{ NULL, 0x131762 /* #1744 'NSDockTile' => 'AppKit.NSDockTile, Xamarin.Mac' */ },
		{ NULL, 0x131A62 /* #1745 'NSDockTilePlugIn' => 'AppKit.NSDockTilePlugIn, Xamarin.Mac' */ },
		{ NULL, 0x131C62 /* #1746 'NSDocumentController' => 'AppKit.NSDocumentController, Xamarin.Mac' */ },
		{ NULL, 0x132062 /* #1747 'NSDraggingDestination' => 'AppKit.NSDraggingDestination, Xamarin.Mac' */ },
		{ NULL, 0x132162 /* #1748 'NSDraggingImageComponent' => 'AppKit.NSDraggingImageComponent, Xamarin.Mac' */ },
		{ NULL, 0x132662 /* #1749 'NSDraggingItem' => 'AppKit.NSDraggingItem, Xamarin.Mac' */ },
		{ NULL, 0x132762 /* #1750 'NSDraggingSession' => 'AppKit.NSDraggingSession, Xamarin.Mac' */ },
		{ NULL, 0x132B62 /* #1751 'NSDraggingSource' => 'AppKit.NSDraggingSource, Xamarin.Mac' */ },
		{ NULL, 0x133062 /* #1752 'NSDrawerDelegate' => 'AppKit.NSDrawerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x133662 /* #1753 'NSEPSImageRep' => 'AppKit.NSEPSImageRep, Xamarin.Mac' */ },
		{ NULL, 0x133962 /* #1754 'NSFilePromiseProvider' => 'AppKit.NSFilePromiseProvider, Xamarin.Mac' */ },
		{ NULL, 0x133D62 /* #1755 'NSFilePromiseReceiver' => 'AppKit.NSFilePromiseReceiver, Xamarin.Mac' */ },
		{ NULL, 0x133F62 /* #1756 'NSFontAssetRequest' => 'AppKit.NSFontAssetRequest, Xamarin.Mac' */ },
		{ NULL, 0x134462 /* #1757 'NSFontDescriptor' => 'AppKit.NSFontDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x134562 /* #1758 'NSFontManager' => 'AppKit.NSFontManager, Xamarin.Mac' */ },
		{ NULL, 0x134662 /* #1759 'NSFontPanel' => 'AppKit.NSFontPanel, Xamarin.Mac' */ },
		{ NULL, 0x137D62 /* #1760 'NSMatrix' => 'AppKit.NSMatrix, Xamarin.Mac' */ },
		{ NULL, 0x134862 /* #1761 'NSForm' => 'AppKit.NSForm, Xamarin.Mac' */ },
		{ NULL, 0x134962 /* #1762 'NSFormCell' => 'AppKit.NSFormCell, Xamarin.Mac' */ },
		{ NULL, 0x134F62 /* #1763 'NSGestureRecognizerDelegate' => 'AppKit.NSGestureRecognizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x135062 /* #1764 'NSGlyphGenerator' => 'AppKit.NSGlyphGenerator, Xamarin.Mac' */ },
		{ NULL, 0x135162 /* #1765 'NSGlyphInfo' => 'AppKit.NSGlyphInfo, Xamarin.Mac' */ },
		{ NULL, 0x135362 /* #1766 'NSGraphicsContext' => 'AppKit.NSGraphicsContext, Xamarin.Mac' */ },
		{ NULL, 0x135462 /* #1767 'NSGridCell' => 'AppKit.NSGridCell, Xamarin.Mac' */ },
		{ NULL, 0x135562 /* #1768 'NSGridColumn' => 'AppKit.NSGridColumn, Xamarin.Mac' */ },
		{ NULL, 0x135662 /* #1769 'NSGridRow' => 'AppKit.NSGridRow, Xamarin.Mac' */ },
		{ NULL, 0x135762 /* #1770 'NSGridView' => 'AppKit.NSGridView, Xamarin.Mac' */ },
		{ NULL, 0x135862 /* #1771 'NSGroupTouchBarItem' => 'AppKit.NSGroupTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x135962 /* #1772 'NSHapticFeedbackManager' => 'AppKit.NSHapticFeedbackManager, Xamarin.Mac' */ },
		{ NULL, 0x135C62 /* #1773 'NSHapticFeedbackPerformer' => 'AppKit.NSHapticFeedbackPerformer, Xamarin.Mac' */ },
		{ NULL, 0x136262 /* #1774 'NSImageCell' => 'AppKit.NSImageCell, Xamarin.Mac' */ },
		{ NULL, 0x136662 /* #1775 'NSImageDelegate' => 'AppKit.NSImageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x136B62 /* #1776 'NSImageView' => 'AppKit.NSImageView, Xamarin.Mac' */ },
		{ NULL, 0x136F62 /* #1777 'NSLayoutAnchor' => 'AppKit.NSLayoutAnchor`1, Xamarin.Mac' */ },
		{ NULL, 0x137062 /* #1778 'NSLayoutConstraint' => 'AppKit.NSLayoutConstraint, Xamarin.Mac' */ },
		{ NULL, 0x137162 /* #1779 'NSLayoutDimension' => 'AppKit.NSLayoutDimension, Xamarin.Mac' */ },
		{ NULL, 0x137262 /* #1780 'NSLayoutGuide' => 'AppKit.NSLayoutGuide, Xamarin.Mac' */ },
		{ NULL, 0x137362 /* #1781 'NSLayoutManager' => 'AppKit.NSLayoutManager, Xamarin.Mac' */ },
		{ NULL, 0x137762 /* #1782 'NSLayoutManagerDelegate' => 'AppKit.NSLayoutManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x137862 /* #1783 'NSLayoutXAxisAnchor' => 'AppKit.NSLayoutXAxisAnchor, Xamarin.Mac' */ },
		{ NULL, 0x137962 /* #1784 'NSLayoutYAxisAnchor' => 'AppKit.NSLayoutYAxisAnchor, Xamarin.Mac' */ },
		{ NULL, 0x137A62 /* #1785 'NSLevelIndicator' => 'AppKit.NSLevelIndicator, Xamarin.Mac' */ },
		{ NULL, 0x137B62 /* #1786 'NSLevelIndicatorCell' => 'AppKit.NSLevelIndicatorCell, Xamarin.Mac' */ },
		{ NULL, 0x138062 /* #1787 'NSMatrixDelegate' => 'AppKit.NSMatrixDelegate, Xamarin.Mac' */ },
		{ NULL, 0x138562 /* #1788 'NSMenuDelegate' => 'AppKit.NSMenuDelegate, Xamarin.Mac' */ },
		{ NULL, 0x138762 /* #1789 'NSMenuItemCell' => 'AppKit.NSMenuItemCell, Xamarin.Mac' */ },
		{ NULL, 0x138C62 /* #1790 'NSMenuView' => 'AppKit.NSMenuView, Xamarin.Mac' */ },
		{ NULL, 0x134362 /* #1791 'NSFontCollection' => 'AppKit.NSFontCollection, Xamarin.Mac' */ },
		{ NULL, 0x138E62 /* #1792 'NSMutableFontCollection' => 'AppKit.NSMutableFontCollection, Xamarin.Mac' */ },
		{ NULL, 0x13B262 /* #1793 'NSParagraphStyle' => 'AppKit.NSParagraphStyle, Xamarin.Mac' */ },
		{ NULL, 0x138F62 /* #1794 'NSMutableParagraphStyle' => 'AppKit.NSMutableParagraphStyle, Xamarin.Mac' */ },
		{ NULL, 0x139062 /* #1795 'NSNib' => 'AppKit.NSNib, Xamarin.Mac' */ },
		{ NULL, 0x139562 /* #1796 'NSOpenGLContext' => 'AppKit.NSOpenGLContext, Xamarin.Mac' */ },
		{ NULL, 0x139662 /* #1797 'NSOpenGLLayer' => 'AppKit.NSOpenGLLayer, Xamarin.Mac' */ },
		{ NULL, 0x139762 /* #1798 'NSOpenGLPixelBuffer' => 'AppKit.NSOpenGLPixelBuffer, Xamarin.Mac' */ },
		{ NULL, 0x139862 /* #1799 'NSOpenGLPixelFormat' => 'AppKit.NSOpenGLPixelFormat, Xamarin.Mac' */ },
		{ NULL, 0x139962 /* #1800 'NSOpenGLView' => 'AppKit.NSOpenGLView, Xamarin.Mac' */ },
		{ NULL, 0x13F762 /* #1801 'NSSavePanel' => 'AppKit.NSSavePanel, Xamarin.Mac' */ },
		{ NULL, 0x139A62 /* #1802 'NSOpenPanel' => 'AppKit.NSOpenPanel, Xamarin.Mac' */ },
		{ NULL, 0x139E62 /* #1803 'NSOpenSavePanelDelegate' => 'AppKit.NSOpenSavePanelDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13A362 /* #1804 'NSOutlineViewDataSource' => 'AppKit.NSOutlineViewDataSource, Xamarin.Mac' */ },
		{ NULL, 0x13A762 /* #1805 'NSOutlineViewDelegate' => 'AppKit.NSOutlineViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13AE62 /* #1806 'NSPageControllerDelegate' => 'AppKit.NSPageControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13AF62 /* #1807 'NSPageLayout' => 'AppKit.NSPageLayout, Xamarin.Mac' */ },
		{ NULL, 0x13B362 /* #1808 'NSPasteboard' => 'AppKit.NSPasteboard, Xamarin.Mac' */ },
		{ NULL, 0x13B462 /* #1809 'NSPasteboardItem' => 'AppKit.NSPasteboardItem, Xamarin.Mac' */ },
		{ NULL, 0x13B762 /* #1810 'NSPasteboardItemDataProvider' => 'AppKit.NSPasteboardItemDataProvider, Xamarin.Mac' */ },
		{ NULL, 0x13BA62 /* #1811 'NSPasteboardReading' => 'AppKit.NSPasteboardReading, Xamarin.Mac' */ },
		{ NULL, 0x13C162 /* #1812 'NSPasteboardWriting' => 'AppKit.NSPasteboardWriting, Xamarin.Mac' */ },
		{ NULL, 0x13C862 /* #1813 'NSPathCellDelegate' => 'AppKit.NSPathCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13C962 /* #1814 'NSPathComponentCell' => 'AppKit.NSPathComponentCell, Xamarin.Mac' */ },
		{ NULL, 0x13CA62 /* #1815 'NSPathControl' => 'AppKit.NSPathControl, Xamarin.Mac' */ },
		{ NULL, 0x13CE62 /* #1816 'NSPathControlDelegate' => 'AppKit.NSPathControlDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13CF62 /* #1817 'NSPathControlItem' => 'AppKit.NSPathControlItem, Xamarin.Mac' */ },
		{ NULL, 0x13D062 /* #1818 'NSPDFImageRep' => 'AppKit.NSPdfImageRep, Xamarin.Mac' */ },
		{ NULL, 0x13D562 /* #1819 'NSPopoverDelegate' => 'AppKit.NSPopoverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13D662 /* #1820 'NSPopoverTouchBarItem' => 'AppKit.NSPopoverTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x13EC62 /* #1821 'NSRuleEditor' => 'AppKit.NSRuleEditor, Xamarin.Mac' */ },
		{ NULL, 0x13D962 /* #1822 'NSPredicateEditor' => 'AppKit.NSPredicateEditor, Xamarin.Mac' */ },
		{ NULL, 0x13DC62 /* #1823 'NSPressureConfiguration' => 'AppKit.NSPressureConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x13DD62 /* #1824 'NSPrinter' => 'AppKit.NSPrinter, Xamarin.Mac' */ },
		{ NULL, 0x13DE62 /* #1825 'NSPrintInfo' => 'AppKit.NSPrintInfo, Xamarin.Mac' */ },
		{ NULL, 0x13DF62 /* #1826 'NSPrintOperation' => 'AppKit.NSPrintOperation, Xamarin.Mac' */ },
		{ NULL, 0x13E062 /* #1827 'NSPrintPanel' => 'AppKit.NSPrintPanel, Xamarin.Mac' */ },
		{ NULL, 0x13E362 /* #1828 'NSPrintPanelAccessorizing' => 'AppKit.NSPrintPanelAccessorizing, Xamarin.Mac' */ },
		{ NULL, 0x13E462 /* #1829 'NSPrintPreviewGraphicsContext' => 'AppKit.NSPrintPreviewGraphicsContext, Xamarin.Mac' */ },
		{ NULL, 0x13E562 /* #1830 'NSProgressIndicator' => 'AppKit.NSProgressIndicator, Xamarin.Mac' */ },
		{ NULL, 0x13E762 /* #1831 'NSRemoteOpenPanel' => 'AppKit.NSRemoteOpenPanel, Xamarin.Mac' */ },
		{ NULL, 0x13E862 /* #1832 'NSRemoteSavePanel' => 'AppKit.NSRemoteSavePanel, Xamarin.Mac' */ },
		{ NULL, 0x13F062 /* #1833 'NSRuleEditorDelegate' => 'AppKit.NSRuleEditorDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13F162 /* #1834 'NSRulerMarker' => 'AppKit.NSRulerMarker, Xamarin.Mac' */ },
		{ NULL, 0x13F362 /* #1835 'NSRulerView' => 'AppKit.NSRulerView, Xamarin.Mac' */ },
		{ NULL, 0x13F662 /* #1836 'NSRunningApplication' => 'AppKit.NSRunningApplication, Xamarin.Mac' */ },
		{ NULL, 0x13FE62 /* #1837 'NSScrubber' => 'AppKit.NSScrubber, Xamarin.Mac' */ },
		{ NULL, 0x13FF62 /* #1838 'NSScrubberArrangedView' => 'AppKit.NSScrubberArrangedView, Xamarin.Mac' */ },
		{ NULL, 0x140262 /* #1839 'NSScrubberDataSource' => 'AppKit.NSScrubberDataSource, Xamarin.Mac' */ },
		{ NULL, 0x140662 /* #1840 'NSScrubberDelegate' => 'AppKit.NSScrubberDelegate, Xamarin.Mac' */ },
		{ NULL, 0x140E62 /* #1841 'NSScrubberLayout' => 'AppKit.NSScrubberLayout, Xamarin.Mac' */ },
		{ NULL, 0x140762 /* #1842 'NSScrubberFlowLayout' => 'AppKit.NSScrubberFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x140B62 /* #1843 'NSScrubberFlowLayoutDelegate' => 'AppKit.NSScrubberFlowLayoutDelegate, Xamarin.Mac' */ },
		{ NULL, 0x140D62 /* #1844 'NSScrubberItemView' => 'AppKit.NSScrubberItemView, Xamarin.Mac' */ },
		{ NULL, 0x140C62 /* #1845 'NSScrubberImageItemView' => 'AppKit.NSScrubberImageItemView, Xamarin.Mac' */ },
		{ NULL, 0x140F62 /* #1846 'NSScrubberLayoutAttributes' => 'AppKit.NSScrubberLayoutAttributes, Xamarin.Mac' */ },
		{ NULL, 0x141062 /* #1847 'NSScrubberProportionalLayout' => 'AppKit.NSScrubberProportionalLayout, Xamarin.Mac' */ },
		{ NULL, 0x141162 /* #1848 'NSScrubberSelectionStyle' => 'AppKit.NSScrubberSelectionStyle, Xamarin.Mac' */ },
		{ NULL, 0x141262 /* #1849 'NSScrubberSelectionView' => 'AppKit.NSScrubberSelectionView, Xamarin.Mac' */ },
		{ NULL, 0x141362 /* #1850 'NSScrubberTextItemView' => 'AppKit.NSScrubberTextItemView, Xamarin.Mac' */ },
		{ NULL, 0x141562 /* #1851 'NSSearchFieldCell' => 'AppKit.NSSearchFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x141962 /* #1852 'NSSearchFieldDelegate' => 'AppKit.NSSearchFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x149A62 /* #1853 'NSTextField' => 'AppKit.NSTextField, Xamarin.Mac' */ },
		{ NULL, 0x141A62 /* #1854 'NSSecureTextField' => 'AppKit.NSSecureTextField, Xamarin.Mac' */ },
		{ NULL, 0x141B62 /* #1855 'NSSecureTextFieldCell' => 'AppKit.NSSecureTextFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x141D62 /* #1856 'NSSegmentedCell' => 'AppKit.NSSegmentedCell, Xamarin.Mac' */ },
		{ NULL, 0x141E62 /* #1857 'NSSegmentedControl' => 'AppKit.NSSegmentedControl, Xamarin.Mac' */ },
		{ NULL, 0x142262 /* #1858 'NSSeguePerforming' => 'AppKit.NSSeguePerforming, Xamarin.Mac' */ },
		{ NULL, 0x142662 /* #1859 'NSShadow' => 'AppKit.NSShadow, Xamarin.Mac' */ },
		{ NULL, 0x143562 /* #1860 'NSSharingServicePickerDelegate' => 'AppKit.NSSharingServicePickerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x143662 /* #1861 'NSSharingServicePickerTouchBarItem' => 'AppKit.NSSharingServicePickerTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x143962 /* #1862 'NSSharingServicePickerTouchBarItemDelegate' => 'AppKit.NSSharingServicePickerTouchBarItemDelegate, Xamarin.Mac' */ },
		{ NULL, 0x143A62 /* #1863 'NSSlider' => 'AppKit.NSSlider, Xamarin.Mac' */ },
		{ NULL, 0x143C62 /* #1864 'NSSliderAccessoryBehavior' => 'AppKit.NSSliderAccessoryBehavior, Xamarin.Mac' */ },
		{ NULL, 0x143D62 /* #1865 'NSSliderCell' => 'AppKit.NSSliderCell, Xamarin.Mac' */ },
		{ NULL, 0x143E62 /* #1866 'NSSliderTouchBarItem' => 'AppKit.NSSliderTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x144462 /* #1867 'NSSoundDelegate' => 'AppKit.NSSoundDelegate, Xamarin.Mac' */ },
		{ NULL, 0x144562 /* #1868 'NSSpeechRecognizer' => 'AppKit.NSSpeechRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x144962 /* #1869 'NSSpeechRecognizerDelegate' => 'AppKit.NSSpeechRecognizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x144A62 /* #1870 'NSSpeechSynthesizer' => 'AppKit.NSSpeechSynthesizer, Xamarin.Mac' */ },
		{ NULL, 0x144E62 /* #1871 'NSSpeechSynthesizerDelegate' => 'AppKit.NSSpeechSynthesizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x145262 /* #1872 'NSSplitViewController' => 'AppKit.NSSplitViewController, Xamarin.Mac' */ },
		{ NULL, 0x145662 /* #1873 'NSSplitViewDelegate' => 'AppKit.NSSplitViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x145762 /* #1874 'NSSplitViewItem' => 'AppKit.NSSplitViewItem, Xamarin.Mac' */ },
		{ NULL, 0x145B62 /* #1875 'NSSpringLoadingDestination' => 'AppKit.NSSpringLoadingDestination, Xamarin.Mac' */ },
		{ NULL, 0x145C62 /* #1876 'NSStackView' => 'AppKit.NSStackView, Xamarin.Mac' */ },
		{ NULL, 0x146062 /* #1877 'NSStackViewDelegate' => 'AppKit.NSStackViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x146562 /* #1878 'NSStatusBar' => 'AppKit.NSStatusBar, Xamarin.Mac' */ },
		{ NULL, 0x146662 /* #1879 'NSStatusBarButton' => 'AppKit.NSStatusBarButton, Xamarin.Mac' */ },
		{ NULL, 0x146762 /* #1880 'NSStatusItem' => 'AppKit.NSStatusItem, Xamarin.Mac' */ },
		{ NULL, 0x146862 /* #1881 'NSStepper' => 'AppKit.NSStepper, Xamarin.Mac' */ },
		{ NULL, 0x146962 /* #1882 'NSStepperCell' => 'AppKit.NSStepperCell, Xamarin.Mac' */ },
		{ NULL, 0x146A62 /* #1883 'NSStoryboard' => 'AppKit.NSStoryboard, Xamarin.Mac' */ },
		{ NULL, 0x146B62 /* #1884 'NSStoryboardSegue' => 'AppKit.NSStoryboardSegue, Xamarin.Mac' */ },
		{ NULL, 0x146F62 /* #1885 'NSStringDrawingContext' => 'AppKit.NSStringDrawingContext, Xamarin.Mac' */ },
		{ NULL, 0x147062 /* #1886 'NSTableCellView' => 'AppKit.NSTableCellView, Xamarin.Mac' */ },
		{ NULL, 0x147162 /* #1887 'NSTableColumn' => 'AppKit.NSTableColumn, Xamarin.Mac' */ },
		{ NULL, 0x147262 /* #1888 'NSTableHeaderCell' => 'AppKit.NSTableHeaderCell, Xamarin.Mac' */ },
		{ NULL, 0x147362 /* #1889 'NSTableHeaderView' => 'AppKit.NSTableHeaderView, Xamarin.Mac' */ },
		{ NULL, 0x147462 /* #1890 'NSTableRowView' => 'AppKit.NSTableRowView, Xamarin.Mac' */ },
		{ NULL, 0x147C62 /* #1891 'NSTableViewDataSource' => 'AppKit.NSTableViewDataSource, Xamarin.Mac' */ },
		{ NULL, 0x148062 /* #1892 'NSTableViewDelegate' => 'AppKit.NSTableViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x148162 /* #1893 'NSTableViewRowAction' => 'AppKit.NSTableViewRowAction, Xamarin.Mac' */ },
		{ NULL, 0x148262 /* #1894 'NSTableViewSource' => 'AppKit.NSTableViewSource, Xamarin.Mac' */ },
		{ NULL, 0x148562 /* #1895 'NSTabViewController' => 'AppKit.NSTabViewController, Xamarin.Mac' */ },
		{ NULL, 0x148962 /* #1896 'NSTabViewDelegate' => 'AppKit.NSTabViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x148A62 /* #1897 'NSTabViewItem' => 'AppKit.NSTabViewItem, Xamarin.Mac' */ },
		{ NULL, 0x148D62 /* #1898 'NSTextAttachment' => 'AppKit.NSTextAttachment, Xamarin.Mac' */ },
		{ NULL, 0x148E62 /* #1899 'NSTextAttachmentCell' => 'AppKit.NSTextAttachmentCell, Xamarin.Mac' */ },
		{ NULL, 0x149162 /* #1900 'NSTextAttachmentContainer' => 'AppKit.NSTextAttachmentContainer, Xamarin.Mac' */ },
		{ NULL, 0x149262 /* #1901 'NSTextBlock' => 'AppKit.NSTextBlock, Xamarin.Mac' */ },
		{ NULL, 0x149562 /* #1902 'NSTextContainer' => 'AppKit.NSTextContainer, Xamarin.Mac' */ },
		{ NULL, 0x149962 /* #1903 'NSTextDelegate' => 'AppKit.NSTextDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14A262 /* #1904 'NSTextFinder' => 'AppKit.NSTextFinder, Xamarin.Mac' */ },
		{ NULL, 0x14A662 /* #1905 'NSTextFinderBarContainer' => 'AppKit.NSTextFinderBarContainer, Xamarin.Mac' */ },
		{ NULL, 0x14A962 /* #1906 'NSTextFinderClient' => 'AppKit.NSTextFinderClient, Xamarin.Mac' */ },
		{ NULL, 0x14B062 /* #1907 'NSTextInputClient' => 'AppKit.NSTextInputClient, Xamarin.Mac' */ },
		{ NULL, 0x14B262 /* #1908 'NSTextList' => 'AppKit.NSTextList, Xamarin.Mac' */ },
		{ NULL, 0x14BA62 /* #1909 'NSTextStorageDelegate' => 'AppKit.NSTextStorageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14BB62 /* #1910 'NSTextTab' => 'AppKit.NSTextTab, Xamarin.Mac' */ },
		{ NULL, 0x14BC62 /* #1911 'NSTextTable' => 'AppKit.NSTextTable, Xamarin.Mac' */ },
		{ NULL, 0x14BD62 /* #1912 'NSTextTableBlock' => 'AppKit.NSTextTableBlock, Xamarin.Mac' */ },
		{ NULL, 0x14C662 /* #1913 'NSTextViewDelegate' => 'AppKit.NSTextViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14C762 /* #1914 'NSTitlebarAccessoryViewController' => 'AppKit.NSTitlebarAccessoryViewController, Xamarin.Mac' */ },
		{ NULL, 0x14C862 /* #1915 'NSTokenField' => 'AppKit.NSTokenField, Xamarin.Mac' */ },
		{ NULL, 0x14C962 /* #1916 'NSTokenFieldCell' => 'AppKit.NSTokenFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x14CD62 /* #1917 'NSTokenFieldCellDelegate' => 'AppKit.NSTokenFieldCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14D162 /* #1918 'NSTokenFieldDelegate' => 'AppKit.NSTokenFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14D662 /* #1919 'NSToolbarDelegate' => 'AppKit.NSToolbarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14D762 /* #1920 'NSToolbarItem' => 'AppKit.NSToolbarItem, Xamarin.Mac' */ },
		{ NULL, 0x14D862 /* #1921 'NSToolbarItemGroup' => 'AppKit.NSToolbarItemGroup, Xamarin.Mac' */ },
		{ NULL, 0x14DD62 /* #1922 'NSTouch' => 'AppKit.NSTouch, Xamarin.Mac' */ },
		{ NULL, 0x14E362 /* #1923 'NSTouchBarDelegate' => 'AppKit.NSTouchBarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14E962 /* #1924 'NSTrackingArea' => 'AppKit.NSTrackingArea, Xamarin.Mac' */ },
		{ NULL, 0x14EA62 /* #1925 'NSTreeController' => 'AppKit.NSTreeController, Xamarin.Mac' */ },
		{ NULL, 0x14EB62 /* #1926 'NSTreeNode' => 'AppKit.NSTreeNode, Xamarin.Mac' */ },
		{ NULL, 0x14ED62 /* #1927 'NSUserDefaultsController' => 'AppKit.NSUserDefaultsController, Xamarin.Mac' */ },
		{ NULL, 0x14F062 /* #1928 'NSUserInterfaceCompressionOptions' => 'AppKit.NSUserInterfaceCompressionOptions, Xamarin.Mac' */ },
		{ NULL, 0x129162 /* #1929 'NSAnimation' => 'AppKit.NSAnimation, Xamarin.Mac' */ },
		{ NULL, 0x14FB62 /* #1930 'NSViewAnimation' => 'AppKit.NSViewAnimation, Xamarin.Mac' */ },
		{ NULL, 0x14FF62 /* #1931 'NSViewControllerPresentationAnimator' => 'AppKit.NSViewControllerPresentationAnimator, Xamarin.Mac' */ },
		{ NULL, 0x150262 /* #1932 'NSVisualEffectView' => 'AppKit.NSVisualEffectView, Xamarin.Mac' */ },
		{ NULL, 0x150A62 /* #1933 'NSWindowDelegate' => 'AppKit.NSWindowDelegate, Xamarin.Mac' */ },
		{ NULL, 0x150D62 /* #1934 'NSWindowRestoration' => 'AppKit.NSWindowRestoration, Xamarin.Mac' */ },
		{ NULL, 0x150E62 /* #1935 'NSWindowTab' => 'AppKit.NSWindowTab, Xamarin.Mac' */ },
		{ NULL, 0x150F62 /* #1936 'NSWindowTabGroup' => 'AppKit.NSWindowTabGroup, Xamarin.Mac' */ },
		{ NULL, 0x151262 /* #1937 'NSWorkspaceAuthorization' => 'AppKit.NSWorkspaceAuthorization, Xamarin.Mac' */ },
		{ NULL, 0x15AF62 /* #1938 '__monomac_internal_ActionDispatcher' => 'AppKit.ActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x15B562 /* #1939 '__MonoMac_NSAlertDidEndDispatcher' => 'AppKit.NSAlertDidEndDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x16C862 /* #1940 'ASIdentifierManager' => 'AdSupport.ASIdentifierManager, Xamarin.Mac' */ },
		{ NULL, 0x16C962 /* #1941 'ACAccount' => 'Accounts.ACAccount, Xamarin.Mac' */ },
		{ NULL, 0x16CA62 /* #1942 'ACAccountCredential' => 'Accounts.ACAccountCredential, Xamarin.Mac' */ },
		{ NULL, 0x16CD62 /* #1943 'ACAccountType' => 'Accounts.ACAccountType, Xamarin.Mac' */ },
		{ NULL, 0x16E262 /* #1944 'NSAffineTransform' => 'Foundation.NSAffineTransform, Xamarin.Mac' */ },
		{ NULL, 0x16E362 /* #1945 'NSAppleEventDescriptor' => 'Foundation.NSAppleEventDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x16E462 /* #1946 'NSAppleEventManager' => 'Foundation.NSAppleEventManager, Xamarin.Mac' */ },
		{ NULL, 0x16E562 /* #1947 'NSAppleScript' => 'Foundation.NSAppleScript, Xamarin.Mac' */ },
		{ NULL, 0x16E762 /* #1948 'NSAttributedString' => 'Foundation.NSAttributedString, Xamarin.Mac' */ },
		{ NULL, 0x16E862 /* #1949 'NSBindingSelectionMarker' => 'Foundation.NSBindingSelectionMarker, Xamarin.Mac' */ },
		{ NULL, 0x16E962 /* #1950 'NSBlockOperation' => 'Foundation.NSBlockOperation, Xamarin.Mac' */ },
		{ NULL, 0x16EA62 /* #1951 'NSBundle' => 'Foundation.NSBundle, Xamarin.Mac' */ },
		{ NULL, 0x16EB62 /* #1952 'NSByteCountFormatter' => 'Foundation.NSByteCountFormatter, Xamarin.Mac' */ },
		{ NULL, 0x16F162 /* #1953 'NSCacheDelegate' => 'Foundation.NSCacheDelegate, Xamarin.Mac' */ },
		{ NULL, 0x16F262 /* #1954 'NSCachedURLResponse' => 'Foundation.NSCachedUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x170862 /* #1955 'NSDate' => 'Foundation.NSDate, Xamarin.Mac' */ },
		{ NULL, 0x16F462 /* #1956 'NSCalendarDate' => 'Foundation.NSCalendarDate, Xamarin.Mac' */ },
		{ NULL, 0x16F562 /* #1957 'NSCharacterSet' => 'Foundation.NSCharacterSet, Xamarin.Mac' */ },
		{ NULL, 0x16F662 /* #1958 'NSCoder' => 'Foundation.NSCoder, Xamarin.Mac' */ },
		{ NULL, 0x16F962 /* #1959 'NSCoding' => 'Foundation.NSCoding, Xamarin.Mac' */ },
		{ NULL, 0x17A662 /* #1960 'NSPredicate' => 'Foundation.NSPredicate, Xamarin.Mac' */ },
		{ NULL, 0x16FA62 /* #1961 'NSComparisonPredicate' => 'Foundation.NSComparisonPredicate, Xamarin.Mac' */ },
		{ NULL, 0x16FB62 /* #1962 'NSCompoundPredicate' => 'Foundation.NSCompoundPredicate, Xamarin.Mac' */ },
		{ NULL, 0x16FC62 /* #1963 'NSCondition' => 'Foundation.NSCondition, Xamarin.Mac' */ },
		{ NULL, 0x16FD62 /* #1964 'NSConditionLock' => 'Foundation.NSConditionLock, Xamarin.Mac' */ },
		{ NULL, 0x16FE62 /* #1965 'NSConnection' => 'Foundation.NSConnection, Xamarin.Mac' */ },
		{ NULL, 0x170262 /* #1966 'NSConnectionDelegate' => 'Foundation.NSConnectionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x170562 /* #1967 'NSCopying' => 'Foundation.NSCopying, Xamarin.Mac' */ },
		{ NULL, 0x17B662 /* #1968 'NSRegularExpression' => 'Foundation.NSRegularExpression, Xamarin.Mac' */ },
		{ NULL, 0x170762 /* #1969 'NSDataDetector' => 'Foundation.NSDataDetector, Xamarin.Mac' */ },
		{ NULL, 0x170962 /* #1970 'NSDateComponents' => 'Foundation.NSDateComponents, Xamarin.Mac' */ },
		{ NULL, 0x170A62 /* #1971 'NSDateComponentsFormatter' => 'Foundation.NSDateComponentsFormatter, Xamarin.Mac' */ },
		{ NULL, 0x170B62 /* #1972 'NSDateFormatter' => 'Foundation.NSDateFormatter, Xamarin.Mac' */ },
		{ NULL, 0x170C62 /* #1973 'NSDateInterval' => 'Foundation.NSDateInterval, Xamarin.Mac' */ },
		{ NULL, 0x170D62 /* #1974 'NSDateIntervalFormatter' => 'Foundation.NSDateIntervalFormatter, Xamarin.Mac' */ },
		{ NULL, 0x184C62 /* #1975 'NSValue' => 'Foundation.NSValue, Xamarin.Mac' */ },
		{ NULL, 0x179062 /* #1976 'NSNumber' => 'Foundation.NSNumber, Xamarin.Mac' */ },
		{ NULL, 0x170E62 /* #1977 'NSDecimalNumber' => 'Foundation.NSDecimalNumber, Xamarin.Mac' */ },
		{ NULL, 0x17D762 /* #1978 'NSUnit' => 'Foundation.NSUnit, Xamarin.Mac' */ },
		{ NULL, 0x171062 /* #1979 'NSDimension' => 'Foundation.NSDimension, Xamarin.Mac' */ },
		{ NULL, 0x171862 /* #1980 'NSEnumerator' => 'Foundation.NSEnumerator, Xamarin.Mac' */ },
		{ NULL, 0x171162 /* #1981 'NSDirectoryEnumerator' => 'Foundation.NSDirectoryEnumerator, Xamarin.Mac' */ },
		{ NULL, 0x171462 /* #1982 'NSDistantObjectRequest' => 'Foundation.NSDistantObjectRequest, Xamarin.Mac' */ },
		{ NULL, 0x171562 /* #1983 'NSDistributedLock' => 'Foundation.NSDistributedLock, Xamarin.Mac' */ },
		{ NULL, 0x178D62 /* #1984 'NSNotificationCenter' => 'Foundation.NSNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x171662 /* #1985 'NSDistributedNotificationCenter' => 'Foundation.NSDistributedNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x171762 /* #1986 'NSEnergyFormatter' => 'Foundation.NSEnergyFormatter, Xamarin.Mac' */ },
		{ NULL, 0x171962 /* #1987 'NSError' => 'Foundation.NSError, Xamarin.Mac' */ },
		{ NULL, 0x171A62 /* #1988 'NSException' => 'Foundation.NSException, Xamarin.Mac' */ },
		{ NULL, 0x171D62 /* #1989 'NSExtensionItem' => 'Foundation.NSExtensionItem, Xamarin.Mac' */ },
		{ NULL, 0x172062 /* #1990 'NSExtensionRequestHandling' => 'Foundation.NSExtensionRequestHandling, Xamarin.Mac' */ },
		{ NULL, 0x172162 /* #1991 'NSFileAccessIntent' => 'Foundation.NSFileAccessIntent, Xamarin.Mac' */ },
		{ NULL, 0x172262 /* #1992 'NSFileCoordinator' => 'Foundation.NSFileCoordinator, Xamarin.Mac' */ },
		{ NULL, 0x172962 /* #1993 'NSFileManagerDelegate' => 'Foundation.NSFileManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x172D62 /* #1994 'NSFilePresenter' => 'Foundation.NSFilePresenter, Xamarin.Mac' */ },
		{ NULL, 0x172E62 /* #1995 'NSFileProviderService' => 'Foundation.NSFileProviderService, Xamarin.Mac' */ },
		{ NULL, 0x173062 /* #1996 'NSFileWrapper' => 'Foundation.NSFileWrapper, Xamarin.Mac' */ },
		{ NULL, 0x173362 /* #1997 'NSHTTPCookie' => 'Foundation.NSHttpCookie, Xamarin.Mac' */ },
		{ NULL, 0x181362 /* #1998 'NSURLResponse' => 'Foundation.NSUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x173562 /* #1999 'NSHTTPURLResponse' => 'Foundation.NSHttpUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x17C462 /* #2000 'NSStream' => 'Foundation.NSStream, Xamarin.Mac' */ },
		{ NULL, 0x173862 /* #2001 'NSInputStream' => 'Foundation.NSInputStream, Xamarin.Mac' */ },
		{ NULL, 0x173962 /* #2002 'NSInvocation' => 'Foundation.NSInvocation, Xamarin.Mac' */ },
		{ NULL, 0x173A62 /* #2003 'NSISO8601DateFormatter' => 'Foundation.NSIso8601DateFormatter, Xamarin.Mac' */ },
		{ NULL, 0x174562 /* #2004 'NSJSONSerialization' => 'Foundation.NSJsonSerialization, Xamarin.Mac' */ },
		{ NULL, 0x174B62 /* #2005 'NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x175062 /* #2006 'NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x175362 /* #2007 'NSLengthFormatter' => 'Foundation.NSLengthFormatter, Xamarin.Mac' */ },
		{ NULL, 0x175662 /* #2008 'NSLinguisticTagger' => 'Foundation.NSLinguisticTagger, Xamarin.Mac' */ },
		{ NULL, 0x175C62 /* #2009 'NSLock' => 'Foundation.NSLock, Xamarin.Mac' */ },
		{ NULL, 0x179F62 /* #2010 'NSPort' => 'Foundation.NSPort, Xamarin.Mac' */ },
		{ NULL, 0x175F62 /* #2011 'NSMachPort' => 'Foundation.NSMachPort, Xamarin.Mac' */ },
		{ NULL, 0x17A362 /* #2012 'NSPortDelegate' => 'Foundation.NSPortDelegate, Xamarin.Mac' */ },
		{ NULL, 0x176362 /* #2013 'NSMachPortDelegate' => 'Foundation.NSMachPortDelegate, Xamarin.Mac' */ },
		{ NULL, 0x176462 /* #2014 'NSMassFormatter' => 'Foundation.NSMassFormatter, Xamarin.Mac' */ },
		{ NULL, 0x176562 /* #2015 'NSMeasurement' => 'Foundation.NSMeasurement`1, Xamarin.Mac' */ },
		{ NULL, 0x176662 /* #2016 'NSMeasurementFormatter' => 'Foundation.NSMeasurementFormatter, Xamarin.Mac' */ },
		{ NULL, 0x176762 /* #2017 'NSMetadataItem' => 'Foundation.NSMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x176962 /* #2018 'NSMetadataQueryAttributeValueTuple' => 'Foundation.NSMetadataQueryAttributeValueTuple, Xamarin.Mac' */ },
		{ NULL, 0x176D62 /* #2019 'NSMetadataQueryDelegate' => 'Foundation.NSMetadataQueryDelegate, Xamarin.Mac' */ },
		{ NULL, 0x176E62 /* #2020 'NSMetadataQueryResultGroup' => 'Foundation.NSMetadataQueryResultGroup, Xamarin.Mac' */ },
		{ NULL, 0x176F62 /* #2021 'NSMethodSignature' => 'Foundation.NSMethodSignature, Xamarin.Mac' */ },
		{ NULL, 0x177162 /* #2022 'NSMutableAttributedString' => 'Foundation.NSMutableAttributedString, Xamarin.Mac' */ },
		{ NULL, 0x177262 /* #2023 'NSMutableCharacterSet' => 'Foundation.NSMutableCharacterSet, Xamarin.Mac' */ },
		{ NULL, 0x177562 /* #2024 'NSMutableCopying' => 'Foundation.NSMutableCopying, Xamarin.Mac' */ },
		{ NULL, 0x173762 /* #2025 'NSIndexSet' => 'Foundation.NSIndexSet, Xamarin.Mac' */ },
		{ NULL, 0x177862 /* #2026 'NSMutableIndexSet' => 'Foundation.NSMutableIndexSet, Xamarin.Mac' */ },
		{ NULL, 0x179862 /* #2027 'NSOrderedSet' => 'Foundation.NSOrderedSet, Xamarin.Mac' */ },
		{ NULL, 0x177962 /* #2028 'NSMutableOrderedSet' => 'Foundation.NSMutableOrderedSet, Xamarin.Mac' */ },
		{ NULL, 0x17C162 /* #2029 'NSSet' => 'Foundation.NSSet, Xamarin.Mac' */ },
		{ NULL, 0x177A62 /* #2030 'NSMutableSet' => 'Foundation.NSMutableSet, Xamarin.Mac' */ },
		{ NULL, 0x177B62 /* #2031 'NSMutableString' => 'Foundation.NSMutableString, Xamarin.Mac' */ },
		{ NULL, 0x181262 /* #2032 'NSURLRequest' => 'Foundation.NSUrlRequest, Xamarin.Mac' */ },
		{ NULL, 0x177C62 /* #2033 'NSMutableURLRequest' => 'Foundation.NSMutableUrlRequest, Xamarin.Mac' */ },
		{ NULL, 0x178762 /* #2034 'NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x178B62 /* #2035 'NSNetServiceDelegate' => 'Foundation.NSNetServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x178C62 /* #2036 'NSNotification' => 'Foundation.NSNotification, Xamarin.Mac' */ },
		{ NULL, 0x178E62 /* #2037 'NSNotificationQueue' => 'Foundation.NSNotificationQueue, Xamarin.Mac' */ },
		{ NULL, 0x178F62 /* #2038 'NSNull' => 'Foundation.NSNull, Xamarin.Mac' */ },
		{ NULL, 0x179162 /* #2039 'NSNumberFormatter' => 'Foundation.NSNumberFormatter, Xamarin.Mac' */ },
		{ NULL, 0x179762 /* #2040 'NSOperationQueue' => 'Foundation.NSOperationQueue, Xamarin.Mac' */ },
		{ NULL, 0x179962 /* #2041 'NSOrthography' => 'Foundation.NSOrthography, Xamarin.Mac' */ },
		{ NULL, 0x179A62 /* #2042 'NSOutputStream' => 'Foundation.NSOutputStream, Xamarin.Mac' */ },
		{ NULL, 0x179C62 /* #2043 'NSPersonNameComponents' => 'Foundation.NSPersonNameComponents, Xamarin.Mac' */ },
		{ NULL, 0x179D62 /* #2044 'NSPersonNameComponentsFormatter' => 'Foundation.NSPersonNameComponentsFormatter, Xamarin.Mac' */ },
		{ NULL, 0x179E62 /* #2045 'NSPipe' => 'Foundation.NSPipe, Xamarin.Mac' */ },
		{ NULL, 0x17A462 /* #2046 'NSPortMessage' => 'Foundation.NSPortMessage, Xamarin.Mac' */ },
		{ NULL, 0x17A562 /* #2047 'NSPortNameServer' => 'Foundation.NSPortNameServer, Xamarin.Mac' */ },
		{ NULL, 0x17B362 /* #2048 'NSPropertyListSerialization' => 'Foundation.NSPropertyListSerialization, Xamarin.Mac' */ },
		{ NULL, 0x170662 /* #2049 'NSData' => 'Foundation.NSData, Xamarin.Mac' */ },
		{ NULL, 0x177662 /* #2050 'NSMutableData' => 'Foundation.NSMutableData, Xamarin.Mac' */ },
		{ NULL, 0x17B462 /* #2051 'NSPurgeableData' => 'Foundation.NSPurgeableData, Xamarin.Mac' */ },
		{ NULL, 0x17B562 /* #2052 'NSRecursiveLock' => 'Foundation.NSRecursiveLock, Xamarin.Mac' */ },
		{ NULL, 0x17B762 /* #2053 'NSRunLoop' => 'Foundation.NSRunLoop, Xamarin.Mac' */ },
		{ NULL, 0x17BA62 /* #2054 'NSScriptCommand' => 'Foundation.NSScriptCommand, Xamarin.Mac' */ },
		{ NULL, 0x17BC62 /* #2055 'NSScriptCommandDescription' => 'Foundation.NSScriptCommandDescription, Xamarin.Mac' */ },
		{ NULL, 0x17C962 /* #2056 'NSStreamDelegate' => 'Foundation.NSStreamDelegate, Xamarin.Mac' */ },
		{ NULL, 0x17D062 /* #2057 'NSTextCheckingResult' => 'Foundation.NSTextCheckingResult, Xamarin.Mac' */ },
		{ NULL, 0x17D362 /* #2058 'NSTimer' => 'Foundation.NSTimer, Xamarin.Mac' */ },
		{ NULL, 0x17D462 /* #2059 'NSTimeZone' => 'Foundation.NSTimeZone, Xamarin.Mac' */ },
		{ NULL, 0x17D862 /* #2060 'NSUnitAcceleration' => 'Foundation.NSUnitAcceleration, Xamarin.Mac' */ },
		{ NULL, 0x17D962 /* #2061 'NSUnitAngle' => 'Foundation.NSUnitAngle, Xamarin.Mac' */ },
		{ NULL, 0x17DA62 /* #2062 'NSUnitArea' => 'Foundation.NSUnitArea, Xamarin.Mac' */ },
		{ NULL, 0x17DB62 /* #2063 'NSUnitConcentrationMass' => 'Foundation.NSUnitConcentrationMass, Xamarin.Mac' */ },
		{ NULL, 0x17DC62 /* #2064 'NSUnitConverter' => 'Foundation.NSUnitConverter, Xamarin.Mac' */ },
		{ NULL, 0x17DD62 /* #2065 'NSUnitConverterLinear' => 'Foundation.NSUnitConverterLinear, Xamarin.Mac' */ },
		{ NULL, 0x17DE62 /* #2066 'NSUnitDispersion' => 'Foundation.NSUnitDispersion, Xamarin.Mac' */ },
		{ NULL, 0x17DF62 /* #2067 'NSUnitDuration' => 'Foundation.NSUnitDuration, Xamarin.Mac' */ },
		{ NULL, 0x17E062 /* #2068 'NSUnitElectricCharge' => 'Foundation.NSUnitElectricCharge, Xamarin.Mac' */ },
		{ NULL, 0x17E162 /* #2069 'NSUnitElectricCurrent' => 'Foundation.NSUnitElectricCurrent, Xamarin.Mac' */ },
		{ NULL, 0x17E262 /* #2070 'NSUnitElectricPotentialDifference' => 'Foundation.NSUnitElectricPotentialDifference, Xamarin.Mac' */ },
		{ NULL, 0x17E362 /* #2071 'NSUnitElectricResistance' => 'Foundation.NSUnitElectricResistance, Xamarin.Mac' */ },
		{ NULL, 0x17E462 /* #2072 'NSUnitEnergy' => 'Foundation.NSUnitEnergy, Xamarin.Mac' */ },
		{ NULL, 0x17E562 /* #2073 'NSUnitFrequency' => 'Foundation.NSUnitFrequency, Xamarin.Mac' */ },
		{ NULL, 0x17E662 /* #2074 'NSUnitFuelEfficiency' => 'Foundation.NSUnitFuelEfficiency, Xamarin.Mac' */ },
		{ NULL, 0x17E762 /* #2075 'NSUnitIlluminance' => 'Foundation.NSUnitIlluminance, Xamarin.Mac' */ },
		{ NULL, 0x17E862 /* #2076 'NSUnitLength' => 'Foundation.NSUnitLength, Xamarin.Mac' */ },
		{ NULL, 0x17E962 /* #2077 'NSUnitMass' => 'Foundation.NSUnitMass, Xamarin.Mac' */ },
		{ NULL, 0x17EA62 /* #2078 'NSUnitPower' => 'Foundation.NSUnitPower, Xamarin.Mac' */ },
		{ NULL, 0x17EB62 /* #2079 'NSUnitPressure' => 'Foundation.NSUnitPressure, Xamarin.Mac' */ },
		{ NULL, 0x17EC62 /* #2080 'NSUnitSpeed' => 'Foundation.NSUnitSpeed, Xamarin.Mac' */ },
		{ NULL, 0x17ED62 /* #2081 'NSUnitTemperature' => 'Foundation.NSUnitTemperature, Xamarin.Mac' */ },
		{ NULL, 0x17EE62 /* #2082 'NSUnitVolume' => 'Foundation.NSUnitVolume, Xamarin.Mac' */ },
		{ NULL, 0x17F162 /* #2083 'NSURLAuthenticationChallenge' => 'Foundation.NSUrlAuthenticationChallenge, Xamarin.Mac' */ },
		{ NULL, 0x17F562 /* #2084 'NSURLAuthenticationChallengeSender' => 'Foundation.NSURLAuthenticationChallengeSender, Xamarin.Mac' */ },
		{ NULL, 0x17F762 /* #2085 'NSURLComponents' => 'Foundation.NSUrlComponents, Xamarin.Mac' */ },
		{ NULL, 0x180162 /* #2086 'NSURLConnectionDelegate' => 'Foundation.NSUrlConnectionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x17FD62 /* #2087 'NSURLConnectionDataDelegate' => 'Foundation.NSUrlConnectionDataDelegate, Xamarin.Mac' */ },
		{ NULL, 0x180562 /* #2088 'NSURLConnectionDownloadDelegate' => 'Foundation.NSUrlConnectionDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x180662 /* #2089 'NSURLCredential' => 'Foundation.NSUrlCredential, Xamarin.Mac' */ },
		{ NULL, 0x180C62 /* #2090 'NSUrlDownloadDelegate' => 'Foundation.NSUrlDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x180D62 /* #2091 'NSURLProtectionSpace' => 'Foundation.NSUrlProtectionSpace, Xamarin.Mac' */ },
		{ NULL, 0x180E62 /* #2092 'NSURLProtocol' => 'Foundation.NSUrlProtocol, Xamarin.Mac' */ },
		{ NULL, 0x181162 /* #2093 'NSURLQueryItem' => 'Foundation.NSUrlQueryItem, Xamarin.Mac' */ },
		{ NULL, 0x181A62 /* #2094 'NSURLSessionConfiguration' => 'Foundation.NSUrlSessionConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x182362 /* #2095 'NSURLSessionDelegate' => 'Foundation.NSUrlSessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x183362 /* #2096 'NSURLSessionTaskDelegate' => 'Foundation.NSUrlSessionTaskDelegate, Xamarin.Mac' */ },
		{ NULL, 0x181E62 /* #2097 'NSURLSessionDataDelegate' => 'Foundation.NSUrlSessionDataDelegate, Xamarin.Mac' */ },
		{ NULL, 0x182F62 /* #2098 'NSURLSessionTask' => 'Foundation.NSUrlSessionTask, Xamarin.Mac' */ },
		{ NULL, 0x181F62 /* #2099 'NSURLSessionDataTask' => 'Foundation.NSUrlSessionDataTask, Xamarin.Mac' */ },
		{ NULL, 0x182762 /* #2100 'NSURLSessionDownloadDelegate' => 'Foundation.NSUrlSessionDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x182862 /* #2101 'NSURLSessionDownloadTask' => 'Foundation.NSUrlSessionDownloadTask, Xamarin.Mac' */ },
		{ NULL, 0x182C62 /* #2102 'NSURLSessionStreamDelegate' => 'Foundation.NSUrlSessionStreamDelegate, Xamarin.Mac' */ },
		{ NULL, 0x183462 /* #2103 'NSURLSessionTaskMetrics' => 'Foundation.NSUrlSessionTaskMetrics, Xamarin.Mac' */ },
		{ NULL, 0x183662 /* #2104 'NSURLSessionTaskTransactionMetrics' => 'Foundation.NSUrlSessionTaskTransactionMetrics, Xamarin.Mac' */ },
		{ NULL, 0x183762 /* #2105 'NSURLSessionUploadTask' => 'Foundation.NSUrlSessionUploadTask, Xamarin.Mac' */ },
		{ NULL, 0x183F62 /* #2106 'NSUserActivityDelegate' => 'Foundation.NSUserActivityDelegate, Xamarin.Mac' */ },
		{ NULL, 0x184262 /* #2107 'NSUserNotification' => 'Foundation.NSUserNotification, Xamarin.Mac' */ },
		{ NULL, 0x184362 /* #2108 'NSUserNotificationAction' => 'Foundation.NSUserNotificationAction, Xamarin.Mac' */ },
		{ NULL, 0x184A62 /* #2109 'NSUserNotificationCenterDelegate' => 'Foundation.NSUserNotificationCenterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x184B62 /* #2110 'NSUUID' => 'Foundation.NSUuid, Xamarin.Mac' */ },
		{ NULL, 0x184D62 /* #2111 'NSValueTransformer' => 'Foundation.NSValueTransformer, Xamarin.Mac' */ },
		{ NULL, 0x184E62 /* #2112 'NSXPCListenerEndpoint' => 'Foundation.NSXpcListenerEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x188F62 /* #2113 'Foundation_InternalNSNotificationHandler' => 'Foundation.InternalNSNotificationHandler, Xamarin.Mac' */ },
		{ NULL, 0x189262 /* #2114 'NSProxy' => 'Foundation.NSProxy, Xamarin.Mac' */ },
		{ NULL, 0x189C62 /* #2115 'Foundation_NSUrlProtocolClient' => 'Foundation.NSUrlProtocolClient, Xamarin.Mac' */ },
		{ NULL, 0x191B62 /* #2116 'Foundation_NSDispatcher' => 'Foundation.NSDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191C62 /* #2117 '__MonoMac_NSActionDispatcher' => 'Foundation.NSActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191D62 /* #2118 '__MonoMac_NSSynchronizationContextDispatcher' => 'Foundation.NSSynchronizationContextDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191E62 /* #2119 '__Xamarin_NSTimerActionDispatcher' => 'Foundation.NSTimerActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191F62 /* #2120 'Foundation_NSAsyncDispatcher' => 'Foundation.NSAsyncDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x192062 /* #2121 '__MonoMac_NSAsyncActionDispatcher' => 'Foundation.NSAsyncActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x192162 /* #2122 '__MonoMac_NSAsyncSynchronizationContextDispatcher' => 'Foundation.NSAsyncSynchronizationContextDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x192262 /* #2123 'NSAutoreleasePool' => 'Foundation.NSAutoreleasePool, Xamarin.Mac' */ },
		{ NULL, 0x15062 /* #2124 'UNUserNotificationCenter' => 'UserNotifications.UNUserNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x1EF62 /* #2125 'WebHistoryItem' => 'WebKit.WebHistoryItem, Xamarin.Mac' */ },
		{ NULL, 0x20762 /* #2126 'WebView' => 'WebKit.WebView, Xamarin.Mac' */ },
		{ NULL, 0x22F62 /* #2127 'WKContentRuleListStore' => 'WebKit.WKContentRuleListStore, Xamarin.Mac' */ },
		{ NULL, 0x23362 /* #2128 'WKHTTPCookieStore' => 'WebKit.WKHttpCookieStore, Xamarin.Mac' */ },
		{ NULL, 0x25762 /* #2129 'WKWebsiteDataStore' => 'WebKit.WKWebsiteDataStore, Xamarin.Mac' */ },
		{ NULL, 0x25962 /* #2130 'WKWebView' => 'WebKit.WKWebView, Xamarin.Mac' */ },
		{ NULL, 0x2C662 /* #2131 'SKProductsRequest' => 'StoreKit.SKProductsRequest, Xamarin.Mac' */ },
		{ NULL, 0x2FA62 /* #2132 'SKPhysicsWorld' => 'SpriteKit.SKPhysicsWorld, Xamarin.Mac' */ },
		{ NULL, 0x30B62 /* #2133 'SKTextureAtlas' => 'SpriteKit.SKTextureAtlas, Xamarin.Mac' */ },
		{ NULL, 0x32F62 /* #2134 'SLRequest' => 'Social.SLRequest, Xamarin.Mac' */ },
		{ NULL, 0x39562 /* #2135 'SBApplication' => 'ScriptingBridge.SBApplication, Xamarin.Mac' */ },
		{ NULL, 0x3AB62 /* #2136 'SCNAnimationEvent' => 'SceneKit.SCNAnimationEvent, Xamarin.Mac' */ },
		{ NULL, 0x3E662 /* #2137 'SCNLayer' => 'SceneKit.SCNLayer, Xamarin.Mac' */ },
		{ NULL, 0x41C62 /* #2138 'SCNPhysicsWorld' => 'SceneKit.SCNPhysicsWorld, Xamarin.Mac' */ },
		{ NULL, 0x42862 /* #2139 'SCNRenderer' => 'SceneKit.SCNRenderer, Xamarin.Mac' */ },
		{ NULL, 0x45762 /* #2140 'SCNView' => 'SceneKit.SCNView, Xamarin.Mac' */ },
		{ NULL, 0x47162 /* #2141 'SFContentBlockerManager' => 'SafariServices.SFContentBlockerManager, Xamarin.Mac' */ },
		{ NULL, 0x47562 /* #2142 'SFSafariApplication' => 'SafariServices.SFSafariApplication, Xamarin.Mac' */ },
		{ NULL, 0x47662 /* #2143 'SFSafariExtensionHandler' => 'SafariServices.SFSafariExtensionHandler, Xamarin.Mac' */ },
		{ NULL, 0x47D62 /* #2144 'SFSafariPage' => 'SafariServices.SFSafariPage, Xamarin.Mac' */ },
		{ NULL, 0x48062 /* #2145 'SFSafariTab' => 'SafariServices.SFSafariTab, Xamarin.Mac' */ },
		{ NULL, 0x48262 /* #2146 'SFSafariWindow' => 'SafariServices.SFSafariWindow, Xamarin.Mac' */ },
		{ NULL, 0x51662 /* #2147 'PHLivePhotoEditingContext' => 'Photos.PHLivePhotoEditingContext, Xamarin.Mac' */ },
		{ NULL, 0x52062 /* #2148 'PHPhotoLibrary' => 'Photos.PHPhotoLibrary, Xamarin.Mac' */ },
		{ NULL, 0x5AE62 /* #2149 'PDFDocument' => 'PdfKit.PdfDocument, Xamarin.Mac' */ },
		{ NULL, 0x5C062 /* #2150 'PDFThumbnailView' => 'PdfKit.PdfThumbnailView, Xamarin.Mac' */ },
		{ NULL, 0x5C162 /* #2151 'PDFView' => 'PdfKit.PdfView, Xamarin.Mac' */ },
		{ NULL, 0x5D062 /* #2152 'NCWidgetListViewController' => 'NotificationCenter.NCWidgetListViewController, Xamarin.Mac' */ },
		{ NULL, 0x5DB62 /* #2153 'NCWidgetSearchViewController' => 'NotificationCenter.NCWidgetSearchViewController, Xamarin.Mac' */ },
		{ NULL, 0x5E462 /* #2154 'NEAppProxyFlow' => 'NetworkExtension.NEAppProxyFlow, Xamarin.Mac' */ },
		{ NULL, 0x60662 /* #2155 'NEProvider' => 'NetworkExtension.NEProvider, Xamarin.Mac' */ },
		{ NULL, 0x60B62 /* #2156 'NETunnelProvider' => 'NetworkExtension.NETunnelProvider, Xamarin.Mac' */ },
		{ NULL, 0x5E762 /* #2157 'NEAppProxyProvider' => 'NetworkExtension.NEAppProxyProvider, Xamarin.Mac' */ },
		{ NULL, 0x61E62 /* #2158 'NEVPNManager' => 'NetworkExtension.NEVpnManager, Xamarin.Mac' */ },
		{ NULL, 0x60E62 /* #2159 'NETunnelProviderManager' => 'NetworkExtension.NETunnelProviderManager, Xamarin.Mac' */ },
		{ NULL, 0x5E862 /* #2160 'NEAppProxyProviderManager' => 'NetworkExtension.NEAppProxyProviderManager, Xamarin.Mac' */ },
		{ NULL, 0x5E962 /* #2161 'NEAppProxyTCPFlow' => 'NetworkExtension.NEAppProxyTcpFlow, Xamarin.Mac' */ },
		{ NULL, 0x5EA62 /* #2162 'NEAppProxyUDPFlow' => 'NetworkExtension.NEAppProxyUdpFlow, Xamarin.Mac' */ },
		{ NULL, 0x5F162 /* #2163 'NEFilterManager' => 'NetworkExtension.NEFilterManager, Xamarin.Mac' */ },
		{ NULL, 0x5F462 /* #2164 'NEFilterProvider' => 'NetworkExtension.NEFilterProvider, Xamarin.Mac' */ },
		{ NULL, 0x60362 /* #2165 'NEPacketTunnelFlow' => 'NetworkExtension.NEPacketTunnelFlow, Xamarin.Mac' */ },
		{ NULL, 0x60562 /* #2166 'NEPacketTunnelProvider' => 'NetworkExtension.NEPacketTunnelProvider, Xamarin.Mac' */ },
		{ NULL, 0x62862 /* #2167 'NWTCPConnection' => 'NetworkExtension.NWTcpConnection, Xamarin.Mac' */ },
		{ NULL, 0x62F62 /* #2168 'NWUDPSession' => 'NetworkExtension.NWUdpSession, Xamarin.Mac' */ },
		{ NULL, 0x65562 /* #2169 'NLLanguageRecognizer' => 'NaturalLanguage.NLLanguageRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x65A62 /* #2170 'NLTagger' => 'NaturalLanguage.NLTagger, Xamarin.Mac' */ },
		{ NULL, 0x67B62 /* #2171 'MCSession' => 'MultipeerConnectivity.MCSession, Xamarin.Mac' */ },
		{ NULL, 0x6A862 /* #2172 'MDLMesh' => 'ModelIO.MDLMesh, Xamarin.Mac' */ },
		{ NULL, 0x79162 /* #2173 'MPSNNGraph' => 'MetalPerformanceShaders.MPSNNGraph, Xamarin.Mac' */ },
		{ NULL, 0x7C562 /* #2174 'MTKTextureLoader' => 'MetalKit.MTKTextureLoader, Xamarin.Mac' */ },
		{ NULL, 0x8BE62 /* #2175 'MPSkipIntervalCommand' => 'MediaPlayer.MPSkipIntervalCommand, Xamarin.Mac' */ },
		{ NULL, 0x8DB62 /* #2176 'MKDirections' => 'MapKit.MKDirections, Xamarin.Mac' */ },
		{ NULL, 0x8E762 /* #2177 'MKLocalSearch' => 'MapKit.MKLocalSearch, Xamarin.Mac' */ },
		{ NULL, 0x8F462 /* #2178 'MKMapSnapshotter' => 'MapKit.MKMapSnapshotter, Xamarin.Mac' */ },
		{ NULL, 0x8F662 /* #2179 'MKMapView' => 'MapKit.MKMapView, Xamarin.Mac' */ },
		{ NULL, 0x93162 /* #2180 'LAContext' => 'LocalAuthentication.LAContext, Xamarin.Mac' */ },
		{ NULL, 0x97762 /* #2181 'INInteraction' => 'Intents.INInteraction, Xamarin.Mac' */ },
		{ NULL, 0x9B562 /* #2182 'IKCameraDeviceView' => 'ImageKit.IKCameraDeviceView, Xamarin.Mac' */ },
		{ NULL, 0x9BB62 /* #2183 'IKDeviceBrowserView' => 'ImageKit.IKDeviceBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x9C162 /* #2184 'IKFilterBrowserPanel' => 'ImageKit.IKFilterBrowserPanel, Xamarin.Mac' */ },
		{ NULL, 0x9D462 /* #2185 'IKImageBrowserView' => 'ImageKit.IKImageBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x9E162 /* #2186 'IKSaveOptions' => 'ImageKit.IKSaveOptions, Xamarin.Mac' */ },
		{ NULL, 0x9E662 /* #2187 'IKScannerDeviceView' => 'ImageKit.IKScannerDeviceView, Xamarin.Mac' */ },
		{ NULL, 0xA2B62 /* #2188 'GLKTextureLoader' => 'GLKit.GLKTextureLoader, Xamarin.Mac' */ },
		{ NULL, 0xA9162 /* #2189 'GKAchievement' => 'GameKit.GKAchievement, Xamarin.Mac' */ },
		{ NULL, 0xA9462 /* #2190 'GKAchievementDescription' => 'GameKit.GKAchievementDescription, Xamarin.Mac' */ },
		{ NULL, 0xAB662 /* #2191 'GKGameCenterViewController' => 'GameKit.GKGameCenterViewController, Xamarin.Mac' */ },
		{ NULL, 0xA9562 /* #2192 'GKAchievementViewController' => 'GameKit.GKAchievementViewController, Xamarin.Mac' */ },
		{ NULL, 0xA9C62 /* #2193 'GKChallengeEventHandler' => 'GameKit.GKChallengeEventHandler, Xamarin.Mac' */ },
		{ NULL, 0xAAF62 /* #2194 'GKFriendRequestComposeViewController' => 'GameKit.GKFriendRequestComposeViewController, Xamarin.Mac' */ },
		{ NULL, 0xAB862 /* #2195 'GKGameSession' => 'GameKit.GKGameSession, Xamarin.Mac' */ },
		{ NULL, 0xAC562 /* #2196 'GKLeaderboard' => 'GameKit.GKLeaderboard, Xamarin.Mac' */ },
		{ NULL, 0xAC862 /* #2197 'GKLeaderboardSet' => 'GameKit.GKLeaderboardSet, Xamarin.Mac' */ },
		{ NULL, 0xACA62 /* #2198 'GKLeaderboardViewController' => 'GameKit.GKLeaderboardViewController, Xamarin.Mac' */ },
		{ NULL, 0xAF062 /* #2199 'GKPlayer' => 'GameKit.GKPlayer, Xamarin.Mac' */ },
		{ NULL, 0xACE62 /* #2200 'GKLocalPlayer' => 'GameKit.GKLocalPlayer, Xamarin.Mac' */ },
		{ NULL, 0xAD362 /* #2201 'GKMatch' => 'GameKit.GKMatch, Xamarin.Mac' */ },
		{ NULL, 0xADF62 /* #2202 'GKMatchmaker' => 'GameKit.GKMatchmaker, Xamarin.Mac' */ },
		{ NULL, 0xAE062 /* #2203 'GKMatchmakerViewController' => 'GameKit.GKMatchmakerViewController, Xamarin.Mac' */ },
		{ NULL, 0xAED62 /* #2204 'GKNotificationBanner' => 'GameKit.GKNotificationBanner, Xamarin.Mac' */ },
		{ NULL, 0xAF262 /* #2205 'GKSavedGame' => 'GameKit.GKSavedGame, Xamarin.Mac' */ },
		{ NULL, 0xAF762 /* #2206 'GKScore' => 'GameKit.GKScore, Xamarin.Mac' */ },
		{ NULL, 0xB0A62 /* #2207 'GKTurnBasedExchange' => 'GameKit.GKTurnBasedExchange, Xamarin.Mac' */ },
		{ NULL, 0xB0D62 /* #2208 'GKTurnBasedMatch' => 'GameKit.GKTurnBasedMatch, Xamarin.Mac' */ },
		{ NULL, 0xB3062 /* #2209 'GCController' => 'GameController.GCController, Xamarin.Mac' */ },
		{ NULL, 0xB4762 /* #2210 'FIFinderSync' => 'FinderSync.FIFinderSync, Xamarin.Mac' */ },
		{ NULL, 0xB4862 /* #2211 'FIFinderSyncController' => 'FinderSync.FIFinderSyncController, Xamarin.Mac' */ },
		{ NULL, 0xB4E62 /* #2212 'EAAccessory' => 'ExternalAccessory.EAAccessory, Xamarin.Mac' */ },
		{ NULL, 0xB5362 /* #2213 'EAAccessoryManager' => 'ExternalAccessory.EAAccessoryManager, Xamarin.Mac' */ },
		{ NULL, 0xB6862 /* #2214 'EKEventStore' => 'EventKit.EKEventStore, Xamarin.Mac' */ },
		{ NULL, 0xB8262 /* #2215 'CWInterface' => 'CoreWlan.CWInterface, Xamarin.Mac' */ },
		{ NULL, 0xC3B62 /* #2216 'CSSearchableIndex' => 'CoreSpotlight.CSSearchableIndex, Xamarin.Mac' */ },
		{ NULL, 0xC7262 /* #2217 'MLMultiArray' => 'CoreML.MLMultiArray, Xamarin.Mac' */ },
		{ NULL, 0xCD062 /* #2218 'CLGeocoder' => 'CoreLocation.CLGeocoder, Xamarin.Mac' */ },
		{ NULL, 0xCD462 /* #2219 'CLLocationManager' => 'CoreLocation.CLLocationManager, Xamarin.Mac' */ },
		{ NULL, 0xED462 /* #2220 'NSManagedObjectContext' => 'CoreData.NSManagedObjectContext, Xamarin.Mac' */ },
		{ NULL, 0xEDD62 /* #2221 'NSPersistentContainer' => 'CoreData.NSPersistentContainer, Xamarin.Mac' */ },
		{ NULL, 0xEE762 /* #2222 'NSPersistentStoreCoordinator' => 'CoreData.NSPersistentStoreCoordinator, Xamarin.Mac' */ },
		{ NULL, 0xF0462 /* #2223 'CBCentralManager' => 'CoreBluetooth.CBCentralManager, Xamarin.Mac' */ },
		{ NULL, 0xF1C62 /* #2224 'CBPeripheral' => 'CoreBluetooth.CBPeripheral, Xamarin.Mac' */ },
		{ NULL, 0xF2762 /* #2225 'CBPeripheralManager' => 'CoreBluetooth.CBPeripheralManager, Xamarin.Mac' */ },
		{ NULL, 0xF9662 /* #2226 'CNContactStore' => 'Contacts.CNContactStore, Xamarin.Mac' */ },
		{ NULL, 0xFC962 /* #2227 'CKContainer' => 'CloudKit.CKContainer, Xamarin.Mac' */ },
		{ NULL, 0xFCA62 /* #2228 'CKDatabase' => 'CloudKit.CKDatabase, Xamarin.Mac' */ },
		{ NULL, 0x103662 /* #2229 'AVAssetExportSession' => 'AVFoundation.AVAssetExportSession, Xamarin.Mac' */ },
		{ NULL, 0x105362 /* #2230 'AVAssetWriter' => 'AVFoundation.AVAssetWriter, Xamarin.Mac' */ },
		{ NULL, 0x106F62 /* #2231 'AVAudioEngine' => 'AVFoundation.AVAudioEngine, Xamarin.Mac' */ },
		{ NULL, 0x108A62 /* #2232 'AVAudioPlayerNode' => 'AVFoundation.AVAudioPlayerNode, Xamarin.Mac' */ },
		{ NULL, 0x10A762 /* #2233 'AVAudioUnitComponent' => 'AVFoundation.AVAudioUnitComponent, Xamarin.Mac' */ },
		{ NULL, 0x10C862 /* #2234 'AVCaptureDevice' => 'AVFoundation.AVCaptureDevice, Xamarin.Mac' */ },
		{ NULL, 0x10E162 /* #2235 'AVCaptureSession' => 'AVFoundation.AVCaptureSession, Xamarin.Mac' */ },
		{ NULL, 0x10E262 /* #2236 'AVCaptureStillImageOutput' => 'AVFoundation.AVCaptureStillImageOutput, Xamarin.Mac' */ },
		{ NULL, 0x10EC62 /* #2237 'AVCaptureVideoPreviewLayer' => 'AVFoundation.AVCaptureVideoPreviewLayer, Xamarin.Mac' */ },
		{ NULL, 0x111762 /* #2238 'AVFragmentedMovie' => 'AVFoundation.AVFragmentedMovie, Xamarin.Mac' */ },
		{ NULL, 0x111A62 /* #2239 'AVFragmentedMovieTrack' => 'AVFoundation.AVFragmentedMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x113562 /* #2240 'AVMIDIPlayer' => 'AVFoundation.AVMidiPlayer, Xamarin.Mac' */ },
		{ NULL, 0x115762 /* #2241 'AVPlayerItem' => 'AVFoundation.AVPlayerItem, Xamarin.Mac' */ },
		{ NULL, 0x117762 /* #2242 'AVPlayerItemVideoOutput' => 'AVFoundation.AVPlayerItemVideoOutput, Xamarin.Mac' */ },
		{ NULL, 0x118562 /* #2243 'AVRouteDetector' => 'AVFoundation.AVRouteDetector, Xamarin.Mac' */ },
		{ NULL, 0x118662 /* #2244 'AVSampleBufferAudioRenderer' => 'AVFoundation.AVSampleBufferAudioRenderer, Xamarin.Mac' */ },
		{ NULL, 0x118762 /* #2245 'AVSampleBufferDisplayLayer' => 'AVFoundation.AVSampleBufferDisplayLayer, Xamarin.Mac' */ },
		{ NULL, 0x118862 /* #2246 'AVSampleBufferGenerator' => 'AVFoundation.AVSampleBufferGenerator, Xamarin.Mac' */ },
		{ NULL, 0x118962 /* #2247 'AVSampleBufferRenderSynchronizer' => 'AVFoundation.AVSampleBufferRenderSynchronizer, Xamarin.Mac' */ },
		{ NULL, 0x11DC62 /* #2248 'AUAudioUnit' => 'AudioUnit.AUAudioUnit, Xamarin.Mac' */ },
		{ NULL, 0x125B62 /* #2249 'NSAccessibilityElement' => 'AppKit.NSAccessibilityElement, Xamarin.Mac' */ },
		{ NULL, 0x128862 /* #2250 'NSAlert' => 'AppKit.NSAlert, Xamarin.Mac' */ },
		{ NULL, 0x129D62 /* #2251 'NSApplication' => 'AppKit.NSApplication, Xamarin.Mac' */ },
		{ NULL, 0x12B262 /* #2252 'NSBrowser' => 'AppKit.NSBrowser, Xamarin.Mac' */ },
		{ NULL, 0x134A62 /* #2253 'NSGestureRecognizer' => 'AppKit.NSGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x12C262 /* #2254 'NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x12EC62 /* #2255 'NSColor' => 'AppKit.NSColor, Xamarin.Mac' */ },
		{ NULL, 0x12F062 /* #2256 'NSColorPanel' => 'AppKit.NSColorPanel, Xamarin.Mac' */ },
		{ NULL, 0x12F562 /* #2257 'NSComboBox' => 'AppKit.NSComboBox, Xamarin.Mac' */ },
		{ NULL, 0x130E62 /* #2258 'NSDatePicker' => 'AppKit.NSDatePicker, Xamarin.Mac' */ },
		{ NULL, 0x131062 /* #2259 'NSDatePickerCell' => 'AppKit.NSDatePickerCell, Xamarin.Mac' */ },
		{ NULL, 0x131B62 /* #2260 'NSDocument' => 'AppKit.NSDocument, Xamarin.Mac' */ },
		{ NULL, 0x132C62 /* #2261 'NSDrawer' => 'AppKit.NSDrawer, Xamarin.Mac' */ },
		{ NULL, 0x133762 /* #2262 'NSEvent' => 'AppKit.NSEvent, Xamarin.Mac' */ },
		{ NULL, 0x133E62 /* #2263 'NSFont' => 'AppKit.NSFont, Xamarin.Mac' */ },
		{ NULL, 0x135262 /* #2264 'NSGradient' => 'AppKit.NSGradient, Xamarin.Mac' */ },
		{ NULL, 0x135D62 /* #2265 'NSHelpManager' => 'AppKit.NSHelpManager, Xamarin.Mac' */ },
		{ NULL, 0x135E62 /* #2266 'NSImage' => 'AppKit.NSImage, Xamarin.Mac' */ },
		{ NULL, 0x137C62 /* #2267 'NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x138162 /* #2268 'NSMenu' => 'AppKit.NSMenu, Xamarin.Mac' */ },
		{ NULL, 0x138662 /* #2269 'NSMenuItem' => 'AppKit.NSMenuItem, Xamarin.Mac' */ },
		{ NULL, 0x147562 /* #2270 'NSTableView' => 'AppKit.NSTableView, Xamarin.Mac' */ },
		{ NULL, 0x139F62 /* #2271 'NSOutlineView' => 'AppKit.NSOutlineView, Xamarin.Mac' */ },
		{ NULL, 0x13A862 /* #2272 'NSPageController' => 'AppKit.NSPageController, Xamarin.Mac' */ },
		{ NULL, 0x13B162 /* #2273 'NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x13C262 /* #2274 'NSPathCell' => 'AppKit.NSPathCell, Xamarin.Mac' */ },
		{ NULL, 0x13D162 /* #2275 'NSPopover' => 'AppKit.NSPopover, Xamarin.Mac' */ },
		{ NULL, 0x13D762 /* #2276 'NSPopUpButton' => 'AppKit.NSPopUpButton, Xamarin.Mac' */ },
		{ NULL, 0x13D862 /* #2277 'NSPopUpButtonCell' => 'AppKit.NSPopUpButtonCell, Xamarin.Mac' */ },
		{ NULL, 0x13DA62 /* #2278 'NSPredicateEditorRowTemplate' => 'AppKit.NSPredicateEditorRowTemplate, Xamarin.Mac' */ },
		{ NULL, 0x13DB62 /* #2279 'NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x13EB62 /* #2280 'NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x13FB62 /* #2281 'NSScreen' => 'AppKit.NSScreen, Xamarin.Mac' */ },
		{ NULL, 0x13FC62 /* #2282 'NSScroller' => 'AppKit.NSScroller, Xamarin.Mac' */ },
		{ NULL, 0x13FD62 /* #2283 'NSScrollView' => 'AppKit.NSScrollView, Xamarin.Mac' */ },
		{ NULL, 0x141462 /* #2284 'NSSearchField' => 'AppKit.NSSearchField, Xamarin.Mac' */ },
		{ NULL, 0x142762 /* #2285 'NSSharingService' => 'AppKit.NSSharingService, Xamarin.Mac' */ },
		{ NULL, 0x143062 /* #2286 'NSSharingServicePicker' => 'AppKit.NSSharingServicePicker, Xamarin.Mac' */ },
		{ NULL, 0x143B62 /* #2287 'NSSliderAccessory' => 'AppKit.NSSliderAccessory, Xamarin.Mac' */ },
		{ NULL, 0x143F62 /* #2288 'NSSound' => 'AppKit.NSSound, Xamarin.Mac' */ },
		{ NULL, 0x144F62 /* #2289 'NSSpellChecker' => 'AppKit.NSSpellChecker, Xamarin.Mac' */ },
		{ NULL, 0x145162 /* #2290 'NSSplitView' => 'AppKit.NSSplitView, Xamarin.Mac' */ },
		{ NULL, 0x148362 /* #2291 'NSTabView' => 'AppKit.NSTabView, Xamarin.Mac' */ },
		{ NULL, 0x148B62 /* #2292 'NSText' => 'AppKit.NSText, Xamarin.Mac' */ },
		{ NULL, 0x148C62 /* #2293 'NSTextAlternatives' => 'AppKit.NSTextAlternatives, Xamarin.Mac' */ },
		{ NULL, 0x14B162 /* #2294 'NSTextInputContext' => 'AppKit.NSTextInputContext, Xamarin.Mac' */ },
		{ NULL, 0x14B562 /* #2295 'NSTextStorage' => 'AppKit.NSTextStorage, Xamarin.Mac' */ },
		{ NULL, 0x14BE62 /* #2296 'NSTextView' => 'AppKit.NSTextView, Xamarin.Mac' */ },
		{ NULL, 0x14D262 /* #2297 'NSToolbar' => 'AppKit.NSToolbar, Xamarin.Mac' */ },
		{ NULL, 0x14DF62 /* #2298 'NSTouchBar' => 'AppKit.NSTouchBar, Xamarin.Mac' */ },
		{ NULL, 0x151062 /* #2299 'NSWorkspace' => 'AppKit.NSWorkspace, Xamarin.Mac' */ },
		{ NULL, 0x16CC62 /* #2300 'ACAccountStore' => 'Accounts.ACAccountStore, Xamarin.Mac' */ },
		{ NULL, 0x16EC62 /* #2301 'NSCache' => 'Foundation.NSCache, Xamarin.Mac' */ },
		{ NULL, 0x16F362 /* #2302 'NSCalendar' => 'Foundation.NSCalendar, Xamarin.Mac' */ },
		{ NULL, 0x170F62 /* #2303 'NSDictionary' => 'Foundation.NSDictionary, Xamarin.Mac' */ },
		{ NULL, 0x172362 /* #2304 'NSFileHandle' => 'Foundation.NSFileHandle, Xamarin.Mac' */ },
		{ NULL, 0x172462 /* #2305 'NSFileManager' => 'Foundation.NSFileManager, Xamarin.Mac' */ },
		{ NULL, 0x172F62 /* #2306 'NSFileVersion' => 'Foundation.NSFileVersion, Xamarin.Mac' */ },
		{ NULL, 0x173262 /* #2307 'NSHost' => 'Foundation.NSHost, Xamarin.Mac' */ },
		{ NULL, 0x173462 /* #2308 'NSHTTPCookieStorage' => 'Foundation.NSHttpCookieStorage, Xamarin.Mac' */ },
		{ NULL, 0x173662 /* #2309 'NSIndexPath' => 'Foundation.NSIndexPath, Xamarin.Mac' */ },
		{ NULL, 0x173D62 /* #2310 'NSItemProvider' => 'Foundation.NSItemProvider, Xamarin.Mac' */ },
		{ NULL, 0x174662 /* #2311 'NSKeyedArchiver' => 'Foundation.NSKeyedArchiver, Xamarin.Mac' */ },
		{ NULL, 0x174C62 /* #2312 'NSKeyedUnarchiver' => 'Foundation.NSKeyedUnarchiver, Xamarin.Mac' */ },
		{ NULL, 0x175B62 /* #2313 'NSLocale' => 'Foundation.NSLocale, Xamarin.Mac' */ },
		{ NULL, 0x176862 /* #2314 'NSMetadataQuery' => 'Foundation.NSMetadataQuery, Xamarin.Mac' */ },
		{ NULL, 0x177762 /* #2315 'NSMutableDictionary' => 'Foundation.NSMutableDictionary, Xamarin.Mac' */ },
		{ NULL, 0x177D62 /* #2316 'NSNetService' => 'Foundation.NSNetService, Xamarin.Mac' */ },
		{ NULL, 0x178162 /* #2317 'NSNetServiceBrowser' => 'Foundation.NSNetServiceBrowser, Xamarin.Mac' */ },
		{ NULL, 0x17AD62 /* #2318 'NSProcessInfo' => 'Foundation.NSProcessInfo, Xamarin.Mac' */ },
		{ NULL, 0x17AF62 /* #2319 'NSProgress' => 'Foundation.NSProgress, Xamarin.Mac' */ },
		{ NULL, 0x17C062 /* #2320 'NSSecureUnarchiveFromDataTransformer' => 'Foundation.NSSecureUnarchiveFromDataTransformer, Xamarin.Mac' */ },
		{ NULL, 0x17CD62 /* #2321 'NSTask' => 'Foundation.NSTask, Xamarin.Mac' */ },
		{ NULL, 0x17D262 /* #2322 'NSThread' => 'Foundation.NSThread, Xamarin.Mac' */ },
		{ NULL, 0x17D562 /* #2323 'NSUbiquitousKeyValueStore' => 'Foundation.NSUbiquitousKeyValueStore, Xamarin.Mac' */ },
		{ NULL, 0x17D662 /* #2324 'NSUndoManager' => 'Foundation.NSUndoManager, Xamarin.Mac' */ },
		{ NULL, 0x17EF62 /* #2325 'NSURL' => 'Foundation.NSUrl, Xamarin.Mac' */ },
		{ NULL, 0x17F662 /* #2326 'NSURLCache' => 'Foundation.NSUrlCache, Xamarin.Mac' */ },
		{ NULL, 0x17F862 /* #2327 'NSURLConnection' => 'Foundation.NSUrlConnection, Xamarin.Mac' */ },
		{ NULL, 0x180762 /* #2328 'NSURLCredentialStorage' => 'Foundation.NSUrlCredentialStorage, Xamarin.Mac' */ },
		{ NULL, 0x181462 /* #2329 'NSURLSession' => 'Foundation.NSUrlSession, Xamarin.Mac' */ },
		{ NULL, 0x182D62 /* #2330 'NSURLSessionStreamTask' => 'Foundation.NSUrlSessionStreamTask, Xamarin.Mac' */ },
		{ NULL, 0x183A62 /* #2331 'NSUserActivity' => 'Foundation.NSUserActivity, Xamarin.Mac' */ },
		{ NULL, 0x184162 /* #2332 'NSUserDefaults' => 'Foundation.NSUserDefaults, Xamarin.Mac' */ },
		{ NULL, 0x184462 /* #2333 'NSUserNotificationCenter' => 'Foundation.NSUserNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x196F62 /* #2334 'WebKit_DomNode_DomNodeEventProxy' => 'WebKit.DomNode+DomNodeEventProxy, Xamarin.Mac' */ },
		{ NULL, 0x197062 /* #2335 'WebKit_DomNode_DomNodeEventProxy2' => 'WebKit.DomNode+DomNodeEventProxy2, Xamarin.Mac' */ },
		{ NULL, 0x197262 /* #2336 'WebKit_WebView__WebFrameLoadDelegate' => 'WebKit.WebView+_WebFrameLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197362 /* #2337 'WebKit_WebView__WebDownloadDelegate' => 'WebKit.WebView+_WebDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197462 /* #2338 'WebKit_WebView__WebResourceLoadDelegate' => 'WebKit.WebView+_WebResourceLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197562 /* #2339 'WebKit_WebView__WebUIDelegate' => 'WebKit.WebView+_WebUIDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197662 /* #2340 'WebKit_WebView__WebPolicyDelegate' => 'WebKit.WebView+_WebPolicyDelegate, Xamarin.Mac' */ },
		{ NULL, 0x198562 /* #2341 'StoreKit_SKRequest__SKRequestDelegate' => 'StoreKit.SKRequest+_SKRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x198462 /* #2342 'StoreKit_SKProductsRequest__SKProductsRequestDelegate' => 'StoreKit.SKProductsRequest+_SKProductsRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x198862 /* #2343 'SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsWorld+_SKPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x199562 /* #2344 'ScriptingBridge_SBApplication__SBApplicationDelegate' => 'ScriptingBridge.SBApplication+_SBApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x199B62 /* #2345 'SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsWorld+_SCNPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EBA62 /* #2346 'PdfKit_PdfDocument__PdfDocumentDelegate' => 'PdfKit.PdfDocument+_PdfDocumentDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EBE62 /* #2347 'PdfKit_PdfView__PdfViewDelegate' => 'PdfKit.PdfView+_PdfViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EC062 /* #2348 'NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate' => 'NotificationCenter.NCWidgetListViewController+_NCWidgetListViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EC162 /* #2349 'NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate' => 'NotificationCenter.NCWidgetSearchViewController+_NCWidgetSearchViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1662 /* #2350 'MapKit_MKMapView__MKMapViewDelegate' => 'MapKit.MKMapView+_MKMapViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1C62 /* #2351 'ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate' => 'ImageKit.IKCameraDeviceView+_IKCameraDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1D62 /* #2352 'ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate' => 'ImageKit.IKDeviceBrowserView+_IKDeviceBrowserViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1F62 /* #2353 'ImageKit_IKImageBrowserView__IKImageBrowserDelegate' => 'ImageKit.IKImageBrowserView+_IKImageBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F2062 /* #2354 'ImageKit_IKSaveOptions__IKSaveOptionsDelegate' => 'ImageKit.IKSaveOptions+_IKSaveOptionsDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F2162 /* #2355 'ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate' => 'ImageKit.IKScannerDeviceView+_IKScannerDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3962 /* #2356 'GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterViewController+_GKGameCenterControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3562 /* #2357 'GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewController+_GKAchievementViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3762 /* #2358 'GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandler+_GKChallengeEventHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3862 /* #2359 'GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewController+_GKFriendRequestComposeViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F4C62 /* #2360 'GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewController+_GKLeaderboardViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F5762 /* #2361 'GameKit_GKMatch__GKMatchDelegate' => 'GameKit.GKMatch+_GKMatchDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F6262 /* #2362 'GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewController+_GKMatchmakerViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F8962 /* #2363 'ExternalAccessory_EAAccessory__EAAccessoryDelegate' => 'ExternalAccessory.EAAccessory+_EAAccessoryDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1FE962 /* #2364 'CoreLocation_CLLocationManager__CLLocationManagerDelegate' => 'CoreLocation.CLLocationManager+_CLLocationManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202C62 /* #2365 'CoreBluetooth_CBCentralManager__CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManager+_CBCentralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202D62 /* #2366 'CoreBluetooth_CBPeripheral__CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheral+_CBPeripheralDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202E62 /* #2367 'CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManager+_CBPeripheralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202F62 /* #2368 'CoreAnimation_CAAnimation__CAAnimationDelegate' => 'CoreAnimation.CAAnimation+_CAAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x206962 /* #2369 'AVFoundation_AVCaptureFileOutput_recordingProxy' => 'AVFoundation.AVCaptureFileOutput+recordingProxy, Xamarin.Mac' */ },
		{ NULL, 0x209662 /* #2370 'AppKit_NSAlert__NSAlertDelegate' => 'AppKit.NSAlert+_NSAlertDelegate, Xamarin.Mac' */ },
		{ NULL, 0x209A62 /* #2371 'AppKit_NSAnimation__NSAnimationDelegate' => 'AppKit.NSAnimation+_NSAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x209C62 /* #2372 'AppKit_NSApplication__NSApplicationDelegate' => 'AppKit.NSApplication+_NSApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B262 /* #2373 '__NSGestureRecognizerToken' => 'AppKit.NSGestureRecognizer+Token, Xamarin.Mac' */ },
		{ NULL, 0x20A062 /* #2374 '__NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20DD62 /* #2375 'AppKit_NSTextField__NSTextFieldDelegate' => 'AppKit.NSTextField+_NSTextFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A362 /* #2376 'AppKit_NSComboBox__NSComboBoxDelegate' => 'AppKit.NSComboBox+_NSComboBoxDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A662 /* #2377 'AppKit_NSDatePicker__NSDatePickerCellDelegate' => 'AppKit.NSDatePicker+_NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A762 /* #2378 'AppKit_NSDatePickerCell__NSDatePickerCellDelegate' => 'AppKit.NSDatePickerCell+_NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A962 /* #2379 '__NSDocumentDuplicateCallback' => 'AppKit.NSDocument+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20AC62 /* #2380 'AppKit_NSDrawer__NSDrawerDelegate' => 'AppKit.NSDrawer+_NSDrawerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B162 /* #2381 'AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate' => 'AppKit.NSGestureRecognizer+_NSGestureRecognizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B362 /* #2382 '__NSGestureRecognizerParameterlessToken' => 'AppKit.NSGestureRecognizer+ParameterlessDispatch, Xamarin.Mac' */ },
		{ NULL, 0x20B462 /* #2383 '__NSGestureRecognizerParametrizedToken' => 'AppKit.NSGestureRecognizer+ParametrizedDispatch, Xamarin.Mac' */ },
		{ NULL, 0x20B762 /* #2384 'AppKit_NSImage__NSImageDelegate' => 'AppKit.NSImage+_NSImageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B962 /* #2385 '__NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20BA62 /* #2386 'AppKit_NSMatrix__NSMatrixDelegate' => 'AppKit.NSMatrix+_NSMatrixDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20BE62 /* #2387 'AppKit_NSPageController__NSPageControllerDelegate' => 'AppKit.NSPageController+_NSPageControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20BF62 /* #2388 '__NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20C062 /* #2389 'AppKit_NSPathCell__NSPathCellDelegate' => 'AppKit.NSPathCell+_NSPathCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20C562 /* #2390 '__NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20C662 /* #2391 '__NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20C762 /* #2392 'AppKit_NSRuleEditor__NSRuleEditorDelegate' => 'AppKit.NSRuleEditor+_NSRuleEditorDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20C962 /* #2393 'AppKit_NSSavePanel__NSOpenSavePanelDelegate' => 'AppKit.NSSavePanel+_NSOpenSavePanelDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20CD62 /* #2394 'AppKit_NSSearchField__NSSearchFieldDelegate' => 'AppKit.NSSearchField+_NSSearchFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20CE62 /* #2395 'AppKit_NSSharingService__NSSharingServiceDelegate' => 'AppKit.NSSharingService+_NSSharingServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20CF62 /* #2396 'AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate' => 'AppKit.NSSharingServicePicker+_NSSharingServicePickerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D162 /* #2397 'AppKit_NSSound__NSSoundDelegate' => 'AppKit.NSSound+_NSSoundDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D662 /* #2398 'AppKit_NSTableView__NSTableViewDelegate' => 'AppKit.NSTableView+_NSTableViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D862 /* #2399 'AppKit_NSTabView__NSTabViewDelegate' => 'AppKit.NSTabView+_NSTabViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D962 /* #2400 'AppKit_NSText__NSTextDelegate' => 'AppKit.NSText+_NSTextDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20DF62 /* #2401 'AppKit_NSTextStorage__NSTextStorageDelegate' => 'AppKit.NSTextStorage+_NSTextStorageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E162 /* #2402 'AppKit_NSTextView__NSTextViewDelegate' => 'AppKit.NSTextView+_NSTextViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E362 /* #2403 'AppKit_NSToolbar__NSToolbarDelegate' => 'AppKit.NSToolbar+_NSToolbarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E562 /* #2404 'AppKit_NSTouchBar__NSTouchBarDelegate' => 'AppKit.NSTouchBar+_NSTouchBarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E762 /* #2405 'AppKit_NSWindow__NSWindowDelegate' => 'AppKit.NSWindow+_NSWindowDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20FB62 /* #2406 'Foundation_NSUrlSessionHandler_WrappedNSInputStream' => 'Foundation.NSUrlSessionHandler+WrappedNSInputStream, Xamarin.Mac' */ },
		{ NULL, 0x210062 /* #2407 'Foundation_NSCache__NSCacheDelegate' => 'Foundation.NSCache+_NSCacheDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212562 /* #2408 'Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiver+_NSKeyedArchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212662 /* #2409 'Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiver+_NSKeyedUnarchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212A62 /* #2410 'Foundation_NSMetadataQuery__NSMetadataQueryDelegate' => 'Foundation.NSMetadataQuery+_NSMetadataQueryDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212F62 /* #2411 'Foundation_NSNetService__NSNetServiceDelegate' => 'Foundation.NSNetService+_NSNetServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x213062 /* #2412 'Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowser+_NSNetServiceBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x213362 /* #2413 '__NSObject_Disposer' => 'Foundation.NSObject+NSObject_Disposer, Xamarin.Mac' */ },
		{ NULL, 0x213462 /* #2414 '__XamarinObjectObserver' => 'Foundation.NSObject+Observer, Xamarin.Mac' */ },
		{ NULL, 0x213B62 /* #2415 'Foundation_NSStream__NSStreamDelegate' => 'Foundation.NSStream+_NSStreamDelegate, Xamarin.Mac' */ },
		{ NULL, 0x213F62 /* #2416 'Foundation_NSThread_ActionThread' => 'Foundation.NSThread+ActionThread, Xamarin.Mac' */ },
		{ NULL, 0x216062 /* #2417 'Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate' => 'Foundation.NSUserNotificationCenter+_NSUserNotificationCenterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20F762 /* #2418 'Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate' => 'Foundation.NSUrlSessionHandler+NSUrlSessionHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1 /* #2419 'AppDelegate' => 'PeekPoke.AppDelegate, PeekPoke' */ },
		{ NULL, 0x9 /* #2420 'ViewController' => 'PeekPoke.ViewController, PeekPoke' */ },
		{ NULL, 0x145 /* #2421 'PeekPoke_ScanTableDataSource' => 'PeekPoke.ScanTableDataSource, PeekPoke' */ },
		{ NULL, 0x14B /* #2422 'PeekPoke_ProductTableDelegate' => 'PeekPoke.ProductTableDelegate, PeekPoke' */ },
		{ NULL, 0x14F /* #2423 'PeekPoke_OutputTableDataSource' => 'PeekPoke.OutputTableDataSource, PeekPoke' */ },
		{ NULL, 0x155 /* #2424 'PeekPoke_OutputTableDelegate' => 'PeekPoke.OutputTableDelegate, PeekPoke' */ },
		{ NULL, 0x159 /* #2425 'PeekPoke_PTTableDataSource' => 'PeekPoke.PTTableDataSource, PeekPoke' */ },
		{ NULL, 0x15F /* #2426 'PeekPoke_PTTableDelegate' => 'PeekPoke.PTTableDelegate, PeekPoke' */ },
		{ NULL, 0 },
	};

	static const MTManagedClassMap __xamarin_skipped_map [] = {
		{ 0x9B462, 838 /* 'Intents.INIntentResolutionResult`1' => 'Intents.INIntentResolutionResult' */ },
		{ 0xA8C62, 942 /* 'GameplayKit.GKObstacleGraph`1' => 'GameplayKit.GKObstacleGraph' */ },
		{ 0x188062, 275 /* 'Foundation.NSArray`1' => 'Foundation.NSArray' */ },
		{ 0x188362, 2303 /* 'Foundation.NSDictionary`2' => 'Foundation.NSDictionary' */ },
		{ 0x188B62, 276 /* 'Foundation.NSMutableArray`1' => 'Foundation.NSMutableArray' */ },
		{ 0x188C62, 2315 /* 'Foundation.NSMutableDictionary`2' => 'Foundation.NSMutableDictionary' */ },
		{ 0x188D62, 2028 /* 'Foundation.NSMutableOrderedSet`1' => 'Foundation.NSMutableOrderedSet' */ },
		{ 0x188E62, 2030 /* 'Foundation.NSMutableSet`1' => 'Foundation.NSMutableSet' */ },
		{ 0x189162, 2027 /* 'Foundation.NSOrderedSet`1' => 'Foundation.NSOrderedSet' */ },
		{ 0x189862, 2029 /* 'Foundation.NSSet`1' => 'Foundation.NSSet' */ },
	};

	static const char *__xamarin_registration_assemblies []= {
		"librpc", 
		"System.Runtime", 
		"mscorlib", 
		"System.Core", 
		"System", 
		"Mono.Security", 
		"System.Configuration", 
		"System.Xml", 
		"System.Security", 
		"System.Numerics", 
		"Mono.Posix", 
		"System.ComponentModel.Composition", 
		"System.Net.Sockets", 
		"System.Net.Primitives", 
		"System.Collections", 
		"System.IO", 
		"System.Text.Encoding", 
		"System.Runtime.Extensions", 
		"System.IO.FileSystem", 
		"Newtonsoft.Json", 
		"netstandard", 
		"System.Data", 
		"System.Transactions", 
		"System.EnterpriseServices", 
		"System.Drawing.Primitives", 
		"System.IO.Compression", 
		"System.IO.Compression.FileSystem", 
		"System.Net.Http", 
		"System.Runtime.Serialization", 
		"System.ServiceModel.Internals", 
		"System.Web.Services", 
		"System.Web", 
		"System.Drawing", 
		"System.Runtime.Serialization.Formatters.Soap", 
		"System.Web.ApplicationServices", 
		"System.ComponentModel.DataAnnotations", 
		"Mono.Data.Sqlite", 
		"System.DirectoryServices", 
		"Novell.Directory.Ldap", 
		"System.Design", 
		"System.Windows.Forms", 
		"Accessibility", 
		"Mono.WebBrowser", 
		"System.Xml.Linq", 
		"NLog", 
		"Plugin.Clipboard.Abstractions", 
		"System.Resources.ResourceManager", 
		"System.Threading.Tasks", 
		"Plugin.Clipboard", 
		"Xamarin.Mac", 
		"SerialPortLib", 
		"SharpDisasm", 
		"Microsoft.Win32.Primitives", 
		"Microsoft.Win32.Registry.AccessControl", 
		"Microsoft.Win32.Registry", 
		"System.AppContext", 
		"System.Collections.Concurrent", 
		"System.Collections.NonGeneric", 
		"System.Collections.Specialized", 
		"System.ComponentModel.Annotations", 
		"System.ComponentModel", 
		"System.ComponentModel.EventBasedAsync", 
		"System.ComponentModel.Primitives", 
		"System.ComponentModel.TypeConverter", 
		"System.Console", 
		"System.Data.Common", 
		"System.Data.SqlClient", 
		"System.Diagnostics.Contracts", 
		"System.Diagnostics.Debug", 
		"System.Diagnostics.FileVersionInfo", 
		"System.Diagnostics.Process", 
		"System.Diagnostics.StackTrace", 
		"System.Diagnostics.TextWriterTraceListener", 
		"System.Diagnostics.Tools", 
		"System.Diagnostics.TraceEvent", 
		"System.Diagnostics.TraceSource", 
		"System.Diagnostics.Tracing", 
		"System.Dynamic.Runtime", 
		"System.Globalization.Calendars", 
		"System.Globalization", 
		"System.Globalization.Extensions", 
		"System.IO.Compression.ZipFile", 
		"System.IO.FileSystem.AccessControl", 
		"System.IO.FileSystem.DriveInfo", 
		"System.IO.FileSystem.Primitives", 
		"System.IO.FileSystem.Watcher", 
		"System.IO.IsolatedStorage", 
		"System.IO.MemoryMappedFiles", 
		"System.IO.Pipes", 
		"System.IO.UnmanagedMemoryStream", 
		"System.Linq", 
		"System.Linq.Expressions", 
		"System.Linq.Parallel", 
		"System.Linq.Queryable", 
		"System.Net.AuthenticationManager", 
		"System.Net.Cache", 
		"System.Net.Http.Rtc", 
		"System.Net.HttpListener", 
		"System.Net.Mail", 
		"System.Net.NameResolution", 
		"System.Net.NetworkInformation", 
		"System.Net.Ping", 
		"System.Net.Requests", 
		"System.Net.Security", 
		"System.Net.ServicePoint", 
		"System.Net.Utilities", 
		"System.Net.WebHeaderCollection", 
		"System.Net.WebSockets.Client", 
		"System.Net.WebSockets", 
		"System.ObjectModel", 
		"System.Reflection", 
		"System.Reflection.Emit", 
		"System.Reflection.Emit.ILGeneration", 
		"System.Reflection.Emit.Lightweight", 
		"System.Reflection.Extensions", 
		"System.Reflection.Primitives", 
		"System.Reflection.TypeExtensions", 
		"System.Resources.Reader", 
		"System.Resources.ReaderWriter", 
		"System.Resources.Writer", 
		"System.Runtime.CompilerServices.VisualC", 
		"System.Runtime.Handles", 
		"System.Runtime.InteropServices", 
		"System.Runtime.InteropServices.RuntimeInformation", 
		"System.Runtime.InteropServices.WindowsRuntime", 
		"System.Runtime.Numerics", 
		"System.Runtime.Serialization.Formatters", 
		"System.Runtime.Serialization.Json", 
		"System.Runtime.Serialization.Primitives", 
		"System.Runtime.Serialization.Xml", 
		"System.Security.AccessControl", 
		"System.Security.Claims", 
		"System.Security.Cryptography.Algorithms", 
		"System.Security.Cryptography.Csp", 
		"System.Security.Cryptography.DeriveBytes", 
		"System.Security.Cryptography.Encoding", 
		"System.Security.Cryptography.Encryption.Aes", 
		"System.Security.Cryptography.Encryption", 
		"System.Security.Cryptography.Encryption.ECDiffieHellman", 
		"System.Security.Cryptography.Encryption.ECDsa", 
		"System.Security.Cryptography.Hashing.Algorithms", 
		"System.Security.Cryptography.Hashing", 
		"System.Security.Cryptography.Primitives", 
		"System.Security.Cryptography.ProtectedData", 
		"System.Security.Cryptography.RandomNumberGenerator", 
		"System.Security.Cryptography.RSA", 
		"System.Security.Cryptography.X509Certificates", 
		"System.Security.Principal", 
		"System.Security.Principal.Windows", 
		"System.Security.SecureString", 
		"System.ServiceModel.Duplex", 
		"System.ServiceModel", 
		"System.IdentityModel", 
		"System.Messaging", 
		"Mono.Messaging", 
		"System.Configuration.Install", 
		"System.IdentityModel.Selectors", 
		"System.ServiceModel.Activation", 
		"System.ServiceModel.Http", 
		"System.ServiceModel.NetTcp", 
		"System.ServiceModel.Primitives", 
		"System.ServiceModel.Security", 
		"System.ServiceProcess.ServiceController", 
		"System.Text.Encoding.CodePages", 
		"System.Text.Encoding.Extensions", 
		"System.Text.RegularExpressions", 
		"System.Threading.AccessControl", 
		"System.Threading", 
		"System.Threading.Overlapped", 
		"System.Threading.Tasks.Parallel", 
		"System.Threading.Thread", 
		"System.Threading.ThreadPool", 
		"System.Threading.Timer", 
		"System.ValueTuple", 
		"System.Xml.ReaderWriter", 
		"System.Xml.XDocument", 
		"System.Xml.XmlDocument", 
		"System.Xml.XmlSerializer", 
		"System.Xml.XPath", 
		"System.Xml.XPath.XDocument", 
		"System.Xml.Xsl.Primitives", 
		"System.Json", 
		"PeekPoke"
	};

	static const struct MTFullTokenReference __xamarin_token_references [] = {
		{ /* #1 = 0x1 */ "PeekPoke", 0x1, 0x2000003 },
		{ /* #2 = 0x3 */ "PeekPoke", 0x1, 0x6000003 },
		{ /* #3 = 0x5 */ "PeekPoke", 0x1, 0x6000004 },
		{ /* #4 = 0x7 */ "PeekPoke", 0x1, 0x6000002 },
		{ /* #5 = 0x9 */ "PeekPoke", 0x1, 0x2000004 },
		{ /* #6 = 0xB */ "PeekPoke", 0x1, 0x6000018 },
		{ /* #7 = 0xD */ "PeekPoke", 0x1, 0x6000019 },
		{ /* #8 = 0xF */ "PeekPoke", 0x1, 0x600001A },
		{ /* #9 = 0x11 */ "PeekPoke", 0x1, 0x600001B },
		{ /* #10 = 0x13 */ "PeekPoke", 0x1, 0x600001C },
		{ /* #11 = 0x15 */ "PeekPoke", 0x1, 0x600001D },
		{ /* #12 = 0x17 */ "PeekPoke", 0x1, 0x600001E },
		{ /* #13 = 0x19 */ "PeekPoke", 0x1, 0x600001F },
		{ /* #14 = 0x1B */ "PeekPoke", 0x1, 0x6000020 },
		{ /* #15 = 0x1D */ "PeekPoke", 0x1, 0x6000021 },
		{ /* #16 = 0x1F */ "PeekPoke", 0x1, 0x6000022 },
		{ /* #17 = 0x21 */ "PeekPoke", 0x1, 0x6000023 },
		{ /* #18 = 0x23 */ "PeekPoke", 0x1, 0x6000024 },
		{ /* #19 = 0x25 */ "PeekPoke", 0x1, 0x6000025 },
		{ /* #20 = 0x27 */ "PeekPoke", 0x1, 0x6000026 },
		{ /* #21 = 0x29 */ "PeekPoke", 0x1, 0x6000027 },
		{ /* #22 = 0x2B */ "PeekPoke", 0x1, 0x6000028 },
		{ /* #23 = 0x2D */ "PeekPoke", 0x1, 0x6000029 },
		{ /* #24 = 0x2F */ "PeekPoke", 0x1, 0x600002A },
		{ /* #25 = 0x31 */ "PeekPoke", 0x1, 0x600002B },
		{ /* #26 = 0x33 */ "PeekPoke", 0x1, 0x600002C },
		{ /* #27 = 0x35 */ "PeekPoke", 0x1, 0x600002D },
		{ /* #28 = 0x37 */ "PeekPoke", 0x1, 0x600002E },
		{ /* #29 = 0x39 */ "PeekPoke", 0x1, 0x600002F },
		{ /* #30 = 0x3B */ "PeekPoke", 0x1, 0x6000030 },
		{ /* #31 = 0x3D */ "PeekPoke", 0x1, 0x6000031 },
		{ /* #32 = 0x3F */ "PeekPoke", 0x1, 0x6000032 },
		{ /* #33 = 0x41 */ "PeekPoke", 0x1, 0x6000033 },
		{ /* #34 = 0x43 */ "PeekPoke", 0x1, 0x6000034 },
		{ /* #35 = 0x45 */ "PeekPoke", 0x1, 0x6000035 },
		{ /* #36 = 0x47 */ "PeekPoke", 0x1, 0x6000036 },
		{ /* #37 = 0x49 */ "PeekPoke", 0x1, 0x6000037 },
		{ /* #38 = 0x4B */ "PeekPoke", 0x1, 0x6000038 },
		{ /* #39 = 0x4D */ "PeekPoke", 0x1, 0x6000039 },
		{ /* #40 = 0x4F */ "PeekPoke", 0x1, 0x600003A },
		{ /* #41 = 0x51 */ "PeekPoke", 0x1, 0x600003B },
		{ /* #42 = 0x53 */ "PeekPoke", 0x1, 0x600003C },
		{ /* #43 = 0x55 */ "PeekPoke", 0x1, 0x600003D },
		{ /* #44 = 0x57 */ "PeekPoke", 0x1, 0x600003E },
		{ /* #45 = 0x59 */ "PeekPoke", 0x1, 0x600003F },
		{ /* #46 = 0x5B */ "PeekPoke", 0x1, 0x6000040 },
		{ /* #47 = 0x5D */ "PeekPoke", 0x1, 0x6000041 },
		{ /* #48 = 0x5F */ "PeekPoke", 0x1, 0x6000042 },
		{ /* #49 = 0x61 */ "PeekPoke", 0x1, 0x6000043 },
		{ /* #50 = 0x63 */ "PeekPoke", 0x1, 0x6000044 },
		{ /* #51 = 0x65 */ "PeekPoke", 0x1, 0x6000045 },
		{ /* #52 = 0x67 */ "PeekPoke", 0x1, 0x6000046 },
		{ /* #53 = 0x69 */ "PeekPoke", 0x1, 0x6000047 },
		{ /* #54 = 0x6B */ "PeekPoke", 0x1, 0x6000048 },
		{ /* #55 = 0x6D */ "PeekPoke", 0x1, 0x6000049 },
		{ /* #56 = 0x6F */ "PeekPoke", 0x1, 0x600004A },
		{ /* #57 = 0x71 */ "PeekPoke", 0x1, 0x600004B },
		{ /* #58 = 0x73 */ "PeekPoke", 0x1, 0x600004C },
		{ /* #59 = 0x75 */ "PeekPoke", 0x1, 0x600004D },
		{ /* #60 = 0x77 */ "PeekPoke", 0x1, 0x600004E },
		{ /* #61 = 0x79 */ "PeekPoke", 0x1, 0x600004F },
		{ /* #62 = 0x7B */ "PeekPoke", 0x1, 0x6000050 },
		{ /* #63 = 0x7D */ "PeekPoke", 0x1, 0x6000051 },
		{ /* #64 = 0x7F */ "PeekPoke", 0x1, 0x6000052 },
		{ /* #65 = 0x81 */ "PeekPoke", 0x1, 0x6000053 },
		{ /* #66 = 0x83 */ "PeekPoke", 0x1, 0x6000054 },
		{ /* #67 = 0x85 */ "PeekPoke", 0x1, 0x6000055 },
		{ /* #68 = 0x87 */ "PeekPoke", 0x1, 0x6000056 },
		{ /* #69 = 0x89 */ "PeekPoke", 0x1, 0x6000057 },
		{ /* #70 = 0x8B */ "PeekPoke", 0x1, 0x6000058 },
		{ /* #71 = 0x8D */ "PeekPoke", 0x1, 0x6000059 },
		{ /* #72 = 0x8F */ "PeekPoke", 0x1, 0x600005A },
		{ /* #73 = 0x91 */ "PeekPoke", 0x1, 0x600005B },
		{ /* #74 = 0x93 */ "PeekPoke", 0x1, 0x600005C },
		{ /* #75 = 0x95 */ "PeekPoke", 0x1, 0x600005D },
		{ /* #76 = 0x97 */ "PeekPoke", 0x1, 0x600005E },
		{ /* #77 = 0x99 */ "PeekPoke", 0x1, 0x600005F },
		{ /* #78 = 0x9B */ "PeekPoke", 0x1, 0x6000060 },
		{ /* #79 = 0x9D */ "PeekPoke", 0x1, 0x6000061 },
		{ /* #80 = 0x9F */ "PeekPoke", 0x1, 0x6000062 },
		{ /* #81 = 0xA1 */ "PeekPoke", 0x1, 0x6000063 },
		{ /* #82 = 0xA3 */ "PeekPoke", 0x1, 0x6000064 },
		{ /* #83 = 0xA5 */ "PeekPoke", 0x1, 0x6000065 },
		{ /* #84 = 0xA7 */ "PeekPoke", 0x1, 0x6000066 },
		{ /* #85 = 0xA9 */ "PeekPoke", 0x1, 0x6000067 },
		{ /* #86 = 0xAB */ "PeekPoke", 0x1, 0x6000068 },
		{ /* #87 = 0xAD */ "PeekPoke", 0x1, 0x6000069 },
		{ /* #88 = 0xAF */ "PeekPoke", 0x1, 0x600006A },
		{ /* #89 = 0xB1 */ "PeekPoke", 0x1, 0x600006B },
		{ /* #90 = 0xB3 */ "PeekPoke", 0x1, 0x600006C },
		{ /* #91 = 0xB5 */ "PeekPoke", 0x1, 0x600006D },
		{ /* #92 = 0xB7 */ "PeekPoke", 0x1, 0x600006E },
		{ /* #93 = 0xB9 */ "PeekPoke", 0x1, 0x600006F },
		{ /* #94 = 0xBB */ "PeekPoke", 0x1, 0x6000070 },
		{ /* #95 = 0xBD */ "PeekPoke", 0x1, 0x6000071 },
		{ /* #96 = 0xBF */ "PeekPoke", 0x1, 0x6000072 },
		{ /* #97 = 0xC1 */ "PeekPoke", 0x1, 0x6000073 },
		{ /* #98 = 0xC3 */ "PeekPoke", 0x1, 0x6000074 },
		{ /* #99 = 0xC5 */ "PeekPoke", 0x1, 0x6000075 },
		{ /* #100 = 0xC7 */ "PeekPoke", 0x1, 0x6000076 },
		{ /* #101 = 0xC9 */ "PeekPoke", 0x1, 0x6000077 },
		{ /* #102 = 0xCB */ "PeekPoke", 0x1, 0x6000078 },
		{ /* #103 = 0xCD */ "PeekPoke", 0x1, 0x6000079 },
		{ /* #104 = 0xCF */ "PeekPoke", 0x1, 0x600007A },
		{ /* #105 = 0xD1 */ "PeekPoke", 0x1, 0x600007B },
		{ /* #106 = 0xD3 */ "PeekPoke", 0x1, 0x600007C },
		{ /* #107 = 0xD5 */ "PeekPoke", 0x1, 0x600007D },
		{ /* #108 = 0xD7 */ "PeekPoke", 0x1, 0x600007E },
		{ /* #109 = 0xD9 */ "PeekPoke", 0x1, 0x600007F },
		{ /* #110 = 0xDB */ "PeekPoke", 0x1, 0x6000080 },
		{ /* #111 = 0xDD */ "PeekPoke", 0x1, 0x6000081 },
		{ /* #112 = 0xDF */ "PeekPoke", 0x1, 0x6000082 },
		{ /* #113 = 0xE1 */ "PeekPoke", 0x1, 0x6000083 },
		{ /* #114 = 0xE3 */ "PeekPoke", 0x1, 0x6000084 },
		{ /* #115 = 0xE5 */ "PeekPoke", 0x1, 0x6000085 },
		{ /* #116 = 0xE7 */ "PeekPoke", 0x1, 0x6000086 },
		{ /* #117 = 0xE9 */ "PeekPoke", 0x1, 0x6000087 },
		{ /* #118 = 0xEB */ "PeekPoke", 0x1, 0x6000088 },
		{ /* #119 = 0xED */ "PeekPoke", 0x1, 0x6000089 },
		{ /* #120 = 0xEF */ "PeekPoke", 0x1, 0x600008A },
		{ /* #121 = 0xF1 */ "PeekPoke", 0x1, 0x600008B },
		{ /* #122 = 0xF3 */ "PeekPoke", 0x1, 0x600008C },
		{ /* #123 = 0xF5 */ "PeekPoke", 0x1, 0x600008D },
		{ /* #124 = 0xF7 */ "PeekPoke", 0x1, 0x600008E },
		{ /* #125 = 0xF9 */ "PeekPoke", 0x1, 0x600008F },
		{ /* #126 = 0xFB */ "PeekPoke", 0x1, 0x6000090 },
		{ /* #127 = 0xFD */ "PeekPoke", 0x1, 0x6000091 },
		{ /* #128 = 0xFF */ "PeekPoke", 0x1, 0x6000092 },
		{ /* #129 = 0x101 */ "PeekPoke", 0x1, 0x6000093 },
		{ /* #130 = 0x103 */ "PeekPoke", 0x1, 0x6000094 },
		{ /* #131 = 0x105 */ "PeekPoke", 0x1, 0x6000095 },
		{ /* #132 = 0x107 */ "PeekPoke", 0x1, 0x6000096 },
		{ /* #133 = 0x109 */ "PeekPoke", 0x1, 0x6000097 },
		{ /* #134 = 0x10B */ "PeekPoke", 0x1, 0x6000098 },
		{ /* #135 = 0x10D */ "PeekPoke", 0x1, 0x6000099 },
		{ /* #136 = 0x10F */ "PeekPoke", 0x1, 0x600000B },
		{ /* #137 = 0x111 */ "PeekPoke", 0x1, 0x6000016 },
		{ /* #138 = 0x113 */ "PeekPoke", 0x1, 0x6000017 },
		{ /* #139 = 0x115 */ "PeekPoke", 0x1, 0x600009A },
		{ /* #140 = 0x117 */ "PeekPoke", 0x1, 0x600009B },
		{ /* #141 = 0x119 */ "PeekPoke", 0x1, 0x600009C },
		{ /* #142 = 0x11B */ "PeekPoke", 0x1, 0x600009D },
		{ /* #143 = 0x11D */ "PeekPoke", 0x1, 0x600009E },
		{ /* #144 = 0x11F */ "PeekPoke", 0x1, 0x600009F },
		{ /* #145 = 0x121 */ "PeekPoke", 0x1, 0x60000A0 },
		{ /* #146 = 0x123 */ "PeekPoke", 0x1, 0x60000A1 },
		{ /* #147 = 0x125 */ "PeekPoke", 0x1, 0x60000A2 },
		{ /* #148 = 0x127 */ "PeekPoke", 0x1, 0x60000A3 },
		{ /* #149 = 0x129 */ "PeekPoke", 0x1, 0x60000A4 },
		{ /* #150 = 0x12B */ "PeekPoke", 0x1, 0x60000A5 },
		{ /* #151 = 0x12D */ "PeekPoke", 0x1, 0x60000A6 },
		{ /* #152 = 0x12F */ "PeekPoke", 0x1, 0x60000A7 },
		{ /* #153 = 0x131 */ "PeekPoke", 0x1, 0x60000A8 },
		{ /* #154 = 0x133 */ "PeekPoke", 0x1, 0x60000A9 },
		{ /* #155 = 0x135 */ "PeekPoke", 0x1, 0x60000AA },
		{ /* #156 = 0x137 */ "PeekPoke", 0x1, 0x60000AB },
		{ /* #157 = 0x139 */ "PeekPoke", 0x1, 0x60000AC },
		{ /* #158 = 0x13B */ "PeekPoke", 0x1, 0x60000AD },
		{ /* #159 = 0x13D */ "PeekPoke", 0x1, 0x60000AE },
		{ /* #160 = 0x13F */ "PeekPoke", 0x1, 0x60000AF },
		{ /* #161 = 0x141 */ "PeekPoke", 0x1, 0x60000B0 },
		{ /* #162 = 0x143 */ "PeekPoke", 0x1, 0x60000B1 },
		{ /* #163 = 0x145 */ "PeekPoke", 0x1, 0x2000006 },
		{ /* #164 = 0x147 */ "PeekPoke", 0x1, 0x60000BB },
		{ /* #165 = 0x149 */ "PeekPoke", 0x1, 0x60000BA },
		{ /* #166 = 0x14B */ "PeekPoke", 0x1, 0x2000007 },
		{ /* #167 = 0x14D */ "PeekPoke", 0x1, 0x60000BD },
		{ /* #168 = 0x14F */ "PeekPoke", 0x1, 0x2000009 },
		{ /* #169 = 0x151 */ "PeekPoke", 0x1, 0x60000C3 },
		{ /* #170 = 0x153 */ "PeekPoke", 0x1, 0x60000C2 },
		{ /* #171 = 0x155 */ "PeekPoke", 0x1, 0x200000A },
		{ /* #172 = 0x157 */ "PeekPoke", 0x1, 0x60000C5 },
		{ /* #173 = 0x159 */ "PeekPoke", 0x1, 0x200000D },
		{ /* #174 = 0x15B */ "PeekPoke", 0x1, 0x60000D8 },
		{ /* #175 = 0x15D */ "PeekPoke", 0x1, 0x60000D7 },
		{ /* #176 = 0x15F */ "PeekPoke", 0x1, 0x200000E },
		{ /* #177 = 0x161 */ "PeekPoke", 0x1, 0x60000DA },

	};

	static const MTProtocolWrapperMap __xamarin_protocol_wrapper_map [] = {
		{ 0x12062 /* VideoSubscriberAccount.IVSAccountManagerDelegate */, 0x12262 /* VSAccountManagerDelegateWrapper */ },
		{ 0x15162 /* UserNotifications.IUNUserNotificationCenterDelegate */, 0x15362 /* UNUserNotificationCenterDelegateWrapper */ },
		{ 0x18862 /* WebKit.IDomEventListener */, 0x18962 /* DomEventListenerWrapper */ },
		{ 0x18B62 /* WebKit.IDomEventTarget */, 0x18C62 /* DomEventTargetWrapper */ },
		{ 0x1CE62 /* WebKit.IDomNodeFilter */, 0x1CF62 /* DomNodeFilterWrapper */ },
		{ 0x1E062 /* WebKit.IWebDocumentRepresentation */, 0x1E162 /* WebDocumentRepresentationWrapper */ },
		{ 0x1E462 /* WebKit.IWebDownloadDelegate */, 0x1E662 /* WebDownloadDelegateWrapper */ },
		{ 0x1E962 /* WebKit.IWebFrameLoadDelegate */, 0x1EB62 /* WebFrameLoadDelegateWrapper */ },
		{ 0x1F062 /* WebKit.IWebOpenPanelResultListener */, 0x1F262 /* WebOpenPanelResultListenerWrapper */ },
		{ 0x1F462 /* WebKit.IWebPolicyDecisionListener */, 0x1F662 /* WebPolicyDecisionListenerWrapper */ },
		{ 0x1F862 /* WebKit.IWebPolicyDelegate */, 0x1FA62 /* WebPolicyDelegateWrapper */ },
		{ 0x1FE62 /* WebKit.IWebResourceLoadDelegate */, 0x20062 /* WebResourceLoadDelegateWrapper */ },
		{ 0x20362 /* WebKit.IWebUIDelegate */, 0x20562 /* WebUIDelegateWrapper */ },
		{ 0x23462 /* WebKit.IWKHttpCookieStoreObserver */, 0x23662 /* WKHttpCookieStoreObserverWrapper */ },
		{ 0x23A62 /* WebKit.IWKNavigationDelegate */, 0x23C62 /* WKNavigationDelegateWrapper */ },
		{ 0x24562 /* WebKit.IWKScriptMessageHandler */, 0x24662 /* WKScriptMessageHandlerWrapper */ },
		{ 0x24B62 /* WebKit.IWKUIDelegate */, 0x24D62 /* WKUIDelegateWrapper */ },
		{ 0x24F62 /* WebKit.IWKUrlSchemeHandler */, 0x25062 /* WKUrlSchemeHandlerWrapper */ },
		{ 0x25162 /* WebKit.IWKUrlSchemeTask */, 0x25262 /* WKUrlSchemeTaskWrapper */ },
		{ 0x28C62 /* Vision.IVNFaceObservationAccepting */, 0x28D62 /* VNFaceObservationAcceptingWrapper */ },
		{ 0x2A362 /* Vision.IVNRequestRevisionProviding */, 0x2A462 /* VNRequestRevisionProvidingWrapper */ },
		{ 0x2BD62 /* StoreKit.ISKPaymentTransactionObserver */, 0x2BF62 /* SKPaymentTransactionObserverWrapper */ },
		{ 0x2C862 /* StoreKit.ISKProductsRequestDelegate */, 0x2C962 /* SKProductsRequestDelegateWrapper */ },
		{ 0x2D062 /* StoreKit.ISKRequestDelegate */, 0x2D262 /* SKRequestDelegateWrapper */ },
		{ 0x2F062 /* SpriteKit.ISKPhysicsContactDelegate */, 0x2F262 /* SKPhysicsContactDelegateWrapper */ },
		{ 0x30262 /* SpriteKit.ISKSceneDelegate */, 0x30462 /* SKSceneDelegateWrapper */ },
		{ 0x31D62 /* SpriteKit.ISKViewDelegate */, 0x31F62 /* SKViewDelegateWrapper */ },
		{ 0x32162 /* SpriteKit.ISKWarpable */, 0x32262 /* SKWarpableWrapper */ },
		{ 0x39662 /* ScriptingBridge.ISBApplicationDelegate */, 0x39762 /* SBApplicationDelegateWrapper */ },
		{ 0x3A162 /* SceneKit.ISCNActionable */, 0x3A362 /* SCNActionableWrapper */ },
		{ 0x3A662 /* SceneKit.ISCNAnimatable */, 0x3A862 /* SCNAnimatableWrapper */ },
		{ 0x3AE62 /* SceneKit.ISCNAnimationProtocol */, 0x3AF62 /* SCNAnimationProtocolWrapper */ },
		{ 0x3B462 /* SceneKit.ISCNAvoidOccluderConstraintDelegate */, 0x3B662 /* SCNAvoidOccluderConstraintDelegateWrapper */ },
		{ 0x3BB62 /* SceneKit.ISCNBoundingVolume */, 0x3BC62 /* SCNBoundingVolumeWrapper */ },
		{ 0x3C062 /* SceneKit.ISCNBufferStream */, 0x3C162 /* SCNBufferStreamWrapper */ },
		{ 0x3C362 /* SceneKit.ISCNCameraControlConfiguration */, 0x3C462 /* SCNCameraControlConfigurationWrapper */ },
		{ 0x3C662 /* SceneKit.ISCNCameraControllerDelegate */, 0x3C862 /* SCNCameraControllerDelegateWrapper */ },
		{ 0x3F462 /* SceneKit.ISCNNodeRendererDelegate */, 0x3F662 /* SCNNodeRendererDelegateWrapper */ },
		{ 0x40B62 /* SceneKit.ISCNPhysicsContactDelegate */, 0x40D62 /* SCNPhysicsContactDelegateWrapper */ },
		{ 0x42062 /* SceneKit.ISCNProgramDelegate */, 0x42262 /* SCNProgramDelegateWrapper */ },
		{ 0x42F62 /* SceneKit.ISCNSceneExportDelegate */, 0x43162 /* SCNSceneExportDelegateWrapper */ },
		{ 0x43462 /* SceneKit.ISCNSceneRenderer */, 0x43662 /* SCNSceneRendererWrapper */ },
		{ 0x43862 /* SceneKit.ISCNSceneRendererDelegate */, 0x43A62 /* SCNSceneRendererDelegateWrapper */ },
		{ 0x44162 /* SceneKit.ISCNShadable */, 0x44362 /* SCNShadableWrapper */ },
		{ 0x44C62 /* SceneKit.ISCNTechniqueSupport */, 0x44D62 /* SCNTechniqueSupportWrapper */ },
		{ 0x47962 /* SafariServices.ISFSafariExtensionHandling */, 0x47B62 /* SFSafariExtensionHandlingWrapper */ },
		{ 0x48462 /* QuickLookUI.IQLPreviewingController */, 0x48562 /* QLPreviewingControllerWrapper */ },
		{ 0x48662 /* QuickLookUI.IQLPreviewItem */, 0x48862 /* QLPreviewItemWrapper */ },
		{ 0x48C62 /* QuickLookUI.IQLPreviewPanelDataSource */, 0x48D62 /* QLPreviewPanelDataSourceWrapper */ },
		{ 0x48F62 /* QuickLookUI.IQLPreviewPanelDelegate */, 0x49162 /* QLPreviewPanelDelegateWrapper */ },
		{ 0x4D462 /* PhotosUI.IPHContentEditingController */, 0x4D562 /* PHContentEditingControllerWrapper */ },
		{ 0x4D862 /* PhotosUI.IPHLivePhotoViewDelegate */, 0x4DA62 /* PHLivePhotoViewDelegateWrapper */ },
		{ 0x4E262 /* PhotosUI.IPHProjectExtensionController */, 0x4E462 /* PHProjectExtensionControllerWrapper */ },
		{ 0x4EE62 /* PhotosUI.IPHProjectTypeDescriptionDataSource */, 0x4F062 /* PHProjectTypeDescriptionDataSourceWrapper */ },
		{ 0x4F262 /* PhotosUI.IPHProjectTypeDescriptionInvalidator */, 0x4F362 /* PHProjectTypeDescriptionInvalidatorWrapper */ },
		{ 0x51B62 /* Photos.IPHLivePhotoFrame */, 0x51C62 /* PHLivePhotoFrameWrapper */ },
		{ 0x52262 /* Photos.IPHPhotoLibraryChangeObserver */, 0x52362 /* PHPhotoLibraryChangeObserverWrapper */ },
		{ 0x5B162 /* PdfKit.IPdfDocumentDelegate */, 0x5B362 /* PdfDocumentDelegateWrapper */ },
		{ 0x5C462 /* PdfKit.IPdfViewDelegate */, 0x5C662 /* PdfViewDelegateWrapper */ },
		{ 0x5D362 /* NotificationCenter.INCWidgetListViewDelegate */, 0x5D562 /* NCWidgetListViewDelegateWrapper */ },
		{ 0x5D762 /* NotificationCenter.INCWidgetProviding */, 0x5D962 /* NCWidgetProvidingWrapper */ },
		{ 0x5DE62 /* NotificationCenter.INCWidgetSearchViewDelegate */, 0x5DF62 /* NCWidgetSearchViewDelegateWrapper */ },
		{ 0x62962 /* NetworkExtension.INWTcpConnectionAuthenticationDelegate */, 0x62B62 /* NWTcpConnectionAuthenticationDelegateWrapper */ },
		{ 0x66462 /* MultipeerConnectivity.IMCAdvertiserAssistantDelegate */, 0x66662 /* MCAdvertiserAssistantDelegateWrapper */ },
		{ 0x66962 /* MultipeerConnectivity.IMCBrowserViewControllerDelegate */, 0x66B62 /* MCBrowserViewControllerDelegateWrapper */ },
		{ 0x67162 /* MultipeerConnectivity.IMCNearbyServiceAdvertiserDelegate */, 0x67362 /* MCNearbyServiceAdvertiserDelegateWrapper */ },
		{ 0x67662 /* MultipeerConnectivity.IMCNearbyServiceBrowserDelegate */, 0x67862 /* MCNearbyServiceBrowserDelegateWrapper */ },
		{ 0x67C62 /* MultipeerConnectivity.IMCSessionDelegate */, 0x67E62 /* MCSessionDelegateWrapper */ },
		{ 0x69162 /* ModelIO.IMDLAssetResolver */, 0x69262 /* MDLAssetResolverWrapper */ },
		{ 0x69762 /* ModelIO.IMDLComponent */, 0x69862 /* MDLComponentWrapper */ },
		{ 0x69A62 /* ModelIO.IMDLJointAnimation */, 0x69B62 /* MDLJointAnimationWrapper */ },
		{ 0x69E62 /* ModelIO.IMDLLightProbeIrradianceDataSource */, 0x6A062 /* MDLLightProbeIrradianceDataSourceWrapper */ },
		{ 0x6A962 /* ModelIO.IMDLMeshBuffer */, 0x6AB62 /* MDLMeshBufferWrapper */ },
		{ 0x6AC62 /* ModelIO.IMDLMeshBufferAllocator */, 0x6AD62 /* MDLMeshBufferAllocatorWrapper */ },
		{ 0x6B162 /* ModelIO.IMDLMeshBufferZone */, 0x6B362 /* MDLMeshBufferZoneWrapper */ },
		{ 0x6B562 /* ModelIO.IMDLNamed */, 0x6B662 /* MDLNamedWrapper */ },
		{ 0x6BB62 /* ModelIO.IMDLObjectContainerComponent */, 0x6BD62 /* MDLObjectContainerComponentWrapper */ },
		{ 0x6CE62 /* ModelIO.IMDLTransformComponent */, 0x6D062 /* MDLTransformComponentWrapper */ },
		{ 0x6D262 /* ModelIO.IMDLTransformOp */, 0x6D362 /* MDLTransformOpWrapper */ },
		{ 0x70062 /* MetalPerformanceShaders.IMPSCnnConvolutionDataSource */, 0x70262 /* MPSCnnConvolutionDataSourceWrapper */ },
		{ 0x74262 /* MetalPerformanceShaders.IMPSDeviceProvider */, 0x74362 /* MPSDeviceProviderWrapper */ },
		{ 0x74562 /* MetalPerformanceShaders.IMPSHandle */, 0x74662 /* MPSHandleWrapper */ },
		{ 0x74962 /* MetalPerformanceShaders.IMPSImageAllocator */, 0x74A62 /* MPSImageAllocatorWrapper */ },
		{ 0x76562 /* MetalPerformanceShaders.IMPSImageSizeEncodingState */, 0x76662 /* MPSImageSizeEncodingStateWrapper */ },
		{ 0x77262 /* MetalPerformanceShaders.IMPSImageTransformProvider */, 0x77362 /* MPSImageTransformProviderWrapper */ },
		{ 0x79562 /* MetalPerformanceShaders.IMPSNNPadding */, 0x79762 /* MPSNNPaddingWrapper */ },
		{ 0x7CE62 /* MetalKit.IMTKViewDelegate */, 0x7CF62 /* MTKViewDelegateWrapper */ },
		{ 0x7D762 /* Metal.IMTLArgumentEncoder */, 0x7D962 /* MTLArgumentEncoderWrapper */ },
		{ 0x7E362 /* Metal.IMTLBlitCommandEncoder */, 0x7E562 /* MTLBlitCommandEncoderWrapper */ },
		{ 0x7E762 /* Metal.IMTLBuffer */, 0x7E962 /* MTLBufferWrapper */ },
		{ 0x7ED62 /* Metal.IMTLCaptureScope */, 0x7EE62 /* MTLCaptureScopeWrapper */ },
		{ 0x7F162 /* Metal.IMTLCommandBuffer */, 0x7F362 /* MTLCommandBufferWrapper */ },
		{ 0x7F762 /* Metal.IMTLCommandEncoder */, 0x7F862 /* MTLCommandEncoderWrapper */ },
		{ 0x7F962 /* Metal.IMTLCommandQueue */, 0x7FA62 /* MTLCommandQueueWrapper */ },
		{ 0x7FD62 /* Metal.IMTLComputeCommandEncoder */, 0x7FF62 /* MTLComputeCommandEncoderWrapper */ },
		{ 0x80262 /* Metal.IMTLComputePipelineState */, 0x80462 /* MTLComputePipelineStateWrapper */ },
		{ 0x80A62 /* Metal.IMTLDepthStencilState */, 0x80B62 /* MTLDepthStencilStateWrapper */ },
		{ 0x80C62 /* Metal.IMTLDevice */, 0x80E62 /* MTLDeviceWrapper */ },
		{ 0x81062 /* Metal.IMTLDrawable */, 0x81162 /* MTLDrawableWrapper */ },
		{ 0x81362 /* Metal.IMTLEvent */, 0x81462 /* MTLEventWrapper */ },
		{ 0x81662 /* Metal.IMTLFence */, 0x81762 /* MTLFenceWrapper */ },
		{ 0x81862 /* Metal.IMTLFunction */, 0x81A62 /* MTLFunctionWrapper */ },
		{ 0x81E62 /* Metal.IMTLHeap */, 0x82062 /* MTLHeapWrapper */ },
		{ 0x82362 /* Metal.IMTLIndirectCommandBuffer */, 0x82462 /* MTLIndirectCommandBufferWrapper */ },
		{ 0x82762 /* Metal.IMTLIndirectRenderCommand */, 0x82862 /* MTLIndirectRenderCommandWrapper */ },
		{ 0x82A62 /* Metal.IMTLLibrary */, 0x82C62 /* MTLLibraryWrapper */ },
		{ 0x83362 /* Metal.IMTLParallelRenderCommandEncoder */, 0x83562 /* MTLParallelRenderCommandEncoderWrapper */ },
		{ 0x84062 /* Metal.IMTLRenderCommandEncoder */, 0x84262 /* MTLRenderCommandEncoderWrapper */ },
		{ 0x84F62 /* Metal.IMTLRenderPipelineState */, 0x85162 /* MTLRenderPipelineStateWrapper */ },
		{ 0x85362 /* Metal.IMTLResource */, 0x85562 /* MTLResourceWrapper */ },
		{ 0x85D62 /* Metal.IMTLSamplerState */, 0x85E62 /* MTLSamplerStateWrapper */ },
		{ 0x85F62 /* Metal.IMTLSharedEvent */, 0x86062 /* MTLSharedEventWrapper */ },
		{ 0x87162 /* Metal.IMTLTexture */, 0x87362 /* MTLTextureWrapper */ },
		{ 0x8D162 /* MapKit.IMKAnnotation */, 0x8D362 /* MKAnnotationWrapper */ },
		{ 0x8E962 /* MapKit.IMKLocalSearchCompleterDelegate */, 0x8EB62 /* MKLocalSearchCompleterDelegateWrapper */ },
		{ 0x8FF62 /* MapKit.IMKMapViewDelegate */, 0x90162 /* MKMapViewDelegateWrapper */ },
		{ 0x90462 /* MapKit.IMKOverlay */, 0x90662 /* MKOverlayWrapper */ },
		{ 0x93862 /* JavaScriptCore.IJSExport */, 0x93962 /* JSExportWrapper */ },
		{ 0x96A62 /* Intents.IINCallsDomainHandling */, 0x96B62 /* INCallsDomainHandlingWrapper */ },
		{ 0x98D62 /* Intents.IINSearchCallHistoryIntentHandling */, 0x98F62 /* INSearchCallHistoryIntentHandlingWrapper */ },
		{ 0x99362 /* Intents.IINSearchForMessagesIntentHandling */, 0x99562 /* INSearchForMessagesIntentHandlingWrapper */ },
		{ 0x99962 /* Intents.IINSendMessageIntentHandling */, 0x99B62 /* INSendMessageIntentHandlingWrapper */ },
		{ 0x9A162 /* Intents.IINSpeakable */, 0x9A362 /* INSpeakableWrapper */ },
		{ 0x9A762 /* Intents.IINStartAudioCallIntentHandling */, 0x9A962 /* INStartAudioCallIntentHandlingWrapper */ },
		{ 0x9AD62 /* Intents.IINStartVideoCallIntentHandling */, 0x9AF62 /* INStartVideoCallIntentHandlingWrapper */ },
		{ 0x9B762 /* ImageKit.IIKCameraDeviceViewDelegate */, 0x9B962 /* IKCameraDeviceViewDelegateWrapper */ },
		{ 0x9BD62 /* ImageKit.IIKDeviceBrowserViewDelegate */, 0x9BF62 /* IKDeviceBrowserViewDelegateWrapper */ },
		{ 0x9C362 /* ImageKit.IIKFilterCustomUIProvider */, 0x9C462 /* IKFilterCustomUIProviderWrapper */ },
		{ 0x9D962 /* ImageKit.IIKImageEditPanelDataSource */, 0x9DB62 /* IKImageEditPanelDataSourceWrapper */ },
		{ 0x9EA62 /* ImageKit.IIKScannerDeviceViewDelegate */, 0x9EC62 /* IKScannerDeviceViewDelegateWrapper */ },
		{ 0x9EF62 /* ImageKit.IIKSlideshowDataSource */, 0x9F162 /* IKSlideshowDataSourceWrapper */ },
		{ 0xA2462 /* GLKit.IGLKNamedEffect */, 0xA2562 /* GLKNamedEffectWrapper */ },
		{ 0xA3E62 /* GameplayKit.IGKAgentDelegate */, 0xA4062 /* GKAgentDelegateWrapper */ },
		{ 0xA5062 /* GameplayKit.IGKGameModel */, 0xA5262 /* GKGameModelWrapper */ },
		{ 0xA5362 /* GameplayKit.IGKGameModelPlayer */, 0xA5562 /* GKGameModelPlayerWrapper */ },
		{ 0xA5662 /* GameplayKit.IGKGameModelUpdate */, 0xA5762 /* GKGameModelUpdateWrapper */ },
		{ 0xA7362 /* GameplayKit.IGKRandom */, 0xA7462 /* GKRandomWrapper */ },
		{ 0xA7D62 /* GameplayKit.IGKSceneRootNodeType */, 0xA7E62 /* GKSceneRootNodeTypeWrapper */ },
		{ 0xA8662 /* GameplayKit.IGKStrategist */, 0xA8762 /* GKStrategistWrapper */ },
		{ 0xA9662 /* GameKit.IGKAchievementViewControllerDelegate */, 0xA9762 /* GKAchievementViewControllerDelegateWrapper */ },
		{ 0xA9D62 /* GameKit.IGKChallengeEventHandlerDelegate */, 0xA9F62 /* GKChallengeEventHandlerDelegateWrapper */ },
		{ 0xAA162 /* GameKit.IGKChallengeListener */, 0xAA362 /* GKChallengeListenerWrapper */ },
		{ 0xAA762 /* GameKit.IGKChallengesViewControllerDelegate */, 0xAA862 /* GKChallengesViewControllerDelegateWrapper */ },
		{ 0xAB062 /* GameKit.IGKFriendRequestComposeViewControllerDelegate */, 0xAB162 /* GKFriendRequestComposeViewControllerDelegateWrapper */ },
		{ 0xAB362 /* GameKit.IGKGameCenterControllerDelegate */, 0xAB462 /* GKGameCenterControllerDelegateWrapper */ },
		{ 0xABB62 /* GameKit.IGKGameSessionEventListener */, 0xABD62 /* GKGameSessionEventListenerWrapper */ },
		{ 0xAC062 /* GameKit.IGKInviteEventListener */, 0xAC262 /* GKInviteEventListenerWrapper */ },
		{ 0xACB62 /* GameKit.IGKLeaderboardViewControllerDelegate */, 0xACC62 /* GKLeaderboardViewControllerDelegateWrapper */ },
		{ 0xAD062 /* GameKit.IGKLocalPlayerListener */, 0xAD162 /* GKLocalPlayerListenerWrapper */ },
		{ 0xADB62 /* GameKit.IGKMatchDelegate */, 0xADD62 /* GKMatchDelegateWrapper */ },
		{ 0xAE662 /* GameKit.IGKMatchmakerViewControllerDelegate */, 0xAE862 /* GKMatchmakerViewControllerDelegateWrapper */ },
		{ 0xAF362 /* GameKit.IGKSavedGameListener */, 0xAF562 /* GKSavedGameListenerWrapper */ },
		{ 0xAFB62 /* GameKit.IGKSessionDelegate */, 0xAFD62 /* GKSessionDelegateWrapper */ },
		{ 0xB0262 /* GameKit.IGKTurnBasedEventHandlerDelegate */, 0xB0462 /* GKTurnBasedEventHandlerDelegateWrapper */ },
		{ 0xB0662 /* GameKit.IGKTurnBasedEventListener */, 0xB0862 /* GKTurnBasedEventListenerWrapper */ },
		{ 0xB0F62 /* GameKit.IGKTurnBasedMatchmakerViewControllerDelegate */, 0xB1062 /* GKTurnBasedMatchmakerViewControllerDelegateWrapper */ },
		{ 0xB1662 /* GameKit.IGKViewController */, 0xB1762 /* GKViewControllerWrapper */ },
		{ 0xB4962 /* FinderSync.IFIFinderSyncProtocol */, 0xB4B62 /* FIFinderSyncProtocolWrapper */ },
		{ 0xB4F62 /* ExternalAccessory.IEAAccessoryDelegate */, 0xB5162 /* EAAccessoryDelegateWrapper */ },
		{ 0xB7E62 /* CoreWlan.ICWEventDelegate */, 0xB8062 /* CWEventDelegateWrapper */ },
		{ 0xC3D62 /* CoreSpotlight.ICSSearchableIndexDelegate */, 0xC3F62 /* CSSearchableIndexDelegateWrapper */ },
		{ 0xC5662 /* CoreML.IMLBatchProvider */, 0xC5762 /* MLBatchProviderWrapper */ },
		{ 0xC5962 /* CoreML.IMLCustomLayer */, 0xC5B62 /* MLCustomLayerWrapper */ },
		{ 0xC5C62 /* CoreML.IMLCustomModel */, 0xC5E62 /* MLCustomModelWrapper */ },
		{ 0xC6362 /* CoreML.IMLFeatureProvider */, 0xC6462 /* MLFeatureProviderWrapper */ },
		{ 0xCDB62 /* CoreLocation.ICLLocationManagerDelegate */, 0xCDD62 /* CLLocationManagerDelegateWrapper */ },
		{ 0xD5762 /* CoreImage.ICIFilterConstructor */, 0xD5862 /* CIFilterConstructorWrapper */ },
		{ 0xD7862 /* CoreImage.ICIImageProcessorInput */, 0xD7A62 /* CIImageProcessorInputWrapper */ },
		{ 0xD7C62 /* CoreImage.ICIImageProcessorOutput */, 0xD7E62 /* CIImageProcessorOutputWrapper */ },
		{ 0xECE62 /* CoreData.INSFetchRequestResult */, 0xECF62 /* NSFetchRequestResultWrapper */ },
		{ 0xF0A62 /* CoreBluetooth.ICBCentralManagerDelegate */, 0xF0C62 /* CBCentralManagerDelegateWrapper */ },
		{ 0xF2362 /* CoreBluetooth.ICBPeripheralDelegate */, 0xF2562 /* CBPeripheralDelegateWrapper */ },
		{ 0xF3062 /* CoreBluetooth.ICBPeripheralManagerDelegate */, 0xF3262 /* CBPeripheralManagerDelegateWrapper */ },
		{ 0xF4062 /* CoreAudioKit.IAUCustomViewPersistentData */, 0xF4162 /* AUCustomViewPersistentDataWrapper */ },
		{ 0xF4962 /* CoreAnimation.ICAAction */, 0xF4A62 /* CAActionWrapper */ },
		{ 0xF4D62 /* CoreAnimation.ICAAnimationDelegate */, 0xF4F62 /* CAAnimationDelegateWrapper */ },
		{ 0xF6062 /* CoreAnimation.ICALayerDelegate */, 0xF6262 /* CALayerDelegateWrapper */ },
		{ 0xF6462 /* CoreAnimation.ICAMediaTiming */, 0xF6562 /* CAMediaTimingWrapper */ },
		{ 0xF6862 /* CoreAnimation.ICAMetalDrawable */, 0xF6962 /* CAMetalDrawableWrapper */ },
		{ 0xF8762 /* ContactsUI.ICNContactPickerDelegate */, 0xF8962 /* CNContactPickerDelegateWrapper */ },
		{ 0xFA862 /* Contacts.ICNKeyDescriptor */, 0xFA962 /* CNKeyDescriptorWrapper */ },
		{ 0xFFB62 /* CloudKit.ICKRecordValue */, 0xFFC62 /* CKRecordValueWrapper */ },
		{ 0x102B62 /* AVKit.IAVCaptureViewDelegate */, 0x102C62 /* AVCaptureViewDelegateWrapper */ },
		{ 0x104662 /* AVFoundation.IAVAssetResourceLoaderDelegate */, 0x104862 /* AVAssetResourceLoaderDelegateWrapper */ },
		{ 0x105D62 /* AVFoundation.IAVAsynchronousKeyValueLoading */, 0x105E62 /* AVAsynchronousKeyValueLoadingWrapper */ },
		{ 0x106162 /* AVFoundation.IAVAudio3DMixing */, 0x106262 /* AVAudio3DMixingWrapper */ },
		{ 0x107D62 /* AVFoundation.IAVAudioMixing */, 0x107F62 /* AVAudioMixingWrapper */ },
		{ 0x108662 /* AVFoundation.IAVAudioPlayerDelegate */, 0x108862 /* AVAudioPlayerDelegateWrapper */ },
		{ 0x108F62 /* AVFoundation.IAVAudioRecorderDelegate */, 0x109162 /* AVAudioRecorderDelegateWrapper */ },
		{ 0x10A162 /* AVFoundation.IAVAudioStereoMixing */, 0x10A262 /* AVAudioStereoMixingWrapper */ },
		{ 0x10BF62 /* AVFoundation.IAVCaptureAudioDataOutputSampleBufferDelegate */, 0x10C162 /* AVCaptureAudioDataOutputSampleBufferDelegateWrapper */ },
		{ 0x10D062 /* AVFoundation.IAVCaptureFileOutputDelegate */, 0x10D262 /* AVCaptureFileOutputDelegateWrapper */ },
		{ 0x10D462 /* AVFoundation.IAVCaptureFileOutputRecordingDelegate */, 0x10D662 /* AVCaptureFileOutputRecordingDelegateWrapper */ },
		{ 0x10E762 /* AVFoundation.IAVCaptureVideoDataOutputSampleBufferDelegate */, 0x10E962 /* AVCaptureVideoDataOutputSampleBufferDelegateWrapper */ },
		{ 0x10FA62 /* AVFoundation.IAVContentKeyRecipient */, 0x10FB62 /* AVContentKeyRecipientWrapper */ },
		{ 0x110462 /* AVFoundation.IAVContentKeySessionDelegate */, 0x110662 /* AVContentKeySessionDelegateWrapper */ },
		{ 0x111B62 /* AVFoundation.IAVFragmentMinding */, 0x111D62 /* AVFragmentMindingWrapper */ },
		{ 0x115E62 /* AVFoundation.IAVPlayerItemLegibleOutputPushDelegate */, 0x116062 /* AVPlayerItemLegibleOutputPushDelegateWrapper */ },
		{ 0x116462 /* AVFoundation.IAVPlayerItemMetadataCollectorPushDelegate */, 0x116562 /* AVPlayerItemMetadataCollectorPushDelegateWrapper */ },
		{ 0x116862 /* AVFoundation.IAVPlayerItemMetadataOutputPushDelegate */, 0x116A62 /* AVPlayerItemMetadataOutputPushDelegateWrapper */ },
		{ 0x116D62 /* AVFoundation.IAVPlayerItemOutputPullDelegate */, 0x116F62 /* AVPlayerItemOutputPullDelegateWrapper */ },
		{ 0x117162 /* AVFoundation.IAVPlayerItemOutputPushDelegate */, 0x117362 /* AVPlayerItemOutputPushDelegateWrapper */ },
		{ 0x118162 /* AVFoundation.IAVQueuedSampleBufferRendering */, 0x118262 /* AVQueuedSampleBufferRenderingWrapper */ },
		{ 0x119B62 /* AVFoundation.IAVVideoCompositing */, 0x119D62 /* AVVideoCompositingWrapper */ },
		{ 0x11A462 /* AVFoundation.IAVVideoCompositionValidationHandling */, 0x11A662 /* AVVideoCompositionValidationHandlingWrapper */ },
		{ 0x11E062 /* AudioUnit.IAUAudioUnitFactory */, 0x11E162 /* AUAudioUnitFactoryWrapper */ },
		{ 0x124A62 /* AppKit.INSAccessibility */, 0x124C62 /* NSAccessibilityWrapper */ },
		{ 0x125062 /* AppKit.INSAccessibilityButton */, 0x125162 /* NSAccessibilityButtonWrapper */ },
		{ 0x125262 /* AppKit.INSAccessibilityContainsTransientUI */, 0x125362 /* NSAccessibilityContainsTransientUIWrapper */ },
		{ 0x125762 /* AppKit.INSAccessibilityCustomRotorItemSearchDelegate */, 0x125862 /* NSAccessibilityCustomRotorItemSearchDelegateWrapper */ },
		{ 0x125C62 /* AppKit.INSAccessibilityElementLoading */, 0x125E62 /* NSAccessibilityElementLoadingWrapper */ },
		{ 0x125F62 /* AppKit.INSAccessibilityElementProtocol */, 0x126162 /* NSAccessibilityElementProtocolWrapper */ },
		{ 0x126362 /* AppKit.INSAccessibilityGroup */, 0x126462 /* NSAccessibilityGroupWrapper */ },
		{ 0x126562 /* AppKit.INSAccessibilityImage */, 0x126662 /* NSAccessibilityImageWrapper */ },
		{ 0x126762 /* AppKit.INSAccessibilityLayoutArea */, 0x126862 /* NSAccessibilityLayoutAreaWrapper */ },
		{ 0x126962 /* AppKit.INSAccessibilityLayoutItem */, 0x126B62 /* NSAccessibilityLayoutItemWrapper */ },
		{ 0x126C62 /* AppKit.INSAccessibilityNavigableStaticText */, 0x126D62 /* NSAccessibilityNavigableStaticTextWrapper */ },
		{ 0x127062 /* AppKit.INSAccessibilityProgressIndicator */, 0x127162 /* NSAccessibilityProgressIndicatorWrapper */ },
		{ 0x127262 /* AppKit.INSAccessibilityRadioButton */, 0x127362 /* NSAccessibilityRadioButtonWrapper */ },
		{ 0x127562 /* AppKit.INSAccessibilityRow */, 0x127762 /* NSAccessibilityRowWrapper */ },
		{ 0x127862 /* AppKit.INSAccessibilitySlider */, 0x127962 /* NSAccessibilitySliderWrapper */ },
		{ 0x127A62 /* AppKit.INSAccessibilityStaticText */, 0x127C62 /* NSAccessibilityStaticTextWrapper */ },
		{ 0x127D62 /* AppKit.INSAccessibilityStepper */, 0x127F62 /* NSAccessibilityStepperWrapper */ },
		{ 0x128162 /* AppKit.INSAccessibilitySwitch */, 0x128362 /* NSAccessibilitySwitchWrapper */ },
		{ 0x128462 /* AppKit.INSAccessibilityTable */, 0x128662 /* NSAccessibilityTableWrapper */ },
		{ 0x128962 /* AppKit.INSAlertDelegate */, 0x128B62 /* NSAlertDelegateWrapper */ },
		{ 0x128E62 /* AppKit.INSAlignmentFeedbackToken */, 0x128F62 /* NSAlignmentFeedbackTokenWrapper */ },
		{ 0x129462 /* AppKit.INSAnimationDelegate */, 0x129662 /* NSAnimationDelegateWrapper */ },
		{ 0x129962 /* AppKit.INSAppearanceCustomization */, 0x129B62 /* NSAppearanceCustomizationWrapper */ },
		{ 0x12A862 /* AppKit.INSApplicationDelegate */, 0x12AA62 /* NSApplicationDelegateWrapper */ },
		{ 0x12B462 /* AppKit.INSBrowserDelegate */, 0x12B662 /* NSBrowserDelegateWrapper */ },
		{ 0x12BC62 /* AppKit.INSCandidateListTouchBarItemDelegate */, 0x12BE62 /* NSCandidateListTouchBarItemDelegateWrapper */ },
		{ 0x12C462 /* AppKit.INSCloudSharingServiceDelegate */, 0x12C662 /* NSCloudSharingServiceDelegateWrapper */ },
		{ 0x12C862 /* AppKit.INSCloudSharingValidation */, 0x12C962 /* NSCloudSharingValidationWrapper */ },
		{ 0x12CD62 /* AppKit.INSCollectionViewDataSource */, 0x12CF62 /* NSCollectionViewDataSourceWrapper */ },
		{ 0x12D162 /* AppKit.INSCollectionViewDelegate */, 0x12D362 /* NSCollectionViewDelegateWrapper */ },
		{ 0x12D562 /* AppKit.INSCollectionViewDelegateFlowLayout */, 0x12D762 /* NSCollectionViewDelegateFlowLayoutWrapper */ },
		{ 0x12D962 /* AppKit.INSCollectionViewElement */, 0x12DB62 /* NSCollectionViewElementWrapper */ },
		{ 0x12E462 /* AppKit.INSCollectionViewPrefetching */, 0x12E662 /* NSCollectionViewPrefetchingWrapper */ },
		{ 0x12E762 /* AppKit.INSCollectionViewSectionHeaderView */, 0x12E962 /* NSCollectionViewSectionHeaderViewWrapper */ },
		{ 0x12ED62 /* AppKit.INSColorChanging */, 0x12EE62 /* NSColorChangingWrapper */ },
		{ 0x12F762 /* AppKit.INSComboBoxCellDataSource */, 0x12F962 /* NSComboBoxCellDataSourceWrapper */ },
		{ 0x12FB62 /* AppKit.INSComboBoxDataSource */, 0x12FD62 /* NSComboBoxDataSourceWrapper */ },
		{ 0x12FF62 /* AppKit.INSComboBoxDelegate */, 0x130162 /* NSComboBoxDelegateWrapper */ },
		{ 0x130662 /* AppKit.INSControlTextEditingDelegate */, 0x130862 /* NSControlTextEditingDelegateWrapper */ },
		{ 0x131162 /* AppKit.INSDatePickerCellDelegate */, 0x131362 /* NSDatePickerCellDelegateWrapper */ },
		{ 0x131862 /* AppKit.INSDockTilePlugIn */, 0x131962 /* NSDockTilePlugInWrapper */ },
		{ 0x131D62 /* AppKit.INSDraggingDestination */, 0x131F62 /* NSDraggingDestinationWrapper */ },
		{ 0x132262 /* AppKit.INSDraggingInfo */, 0x132462 /* NSDraggingInfoWrapper */ },
		{ 0x132862 /* AppKit.INSDraggingSource */, 0x132A62 /* NSDraggingSourceWrapper */ },
		{ 0x132D62 /* AppKit.INSDrawerDelegate */, 0x132F62 /* NSDrawerDelegateWrapper */ },
		{ 0x133162 /* AppKit.INSEditor */, 0x133262 /* NSEditorWrapper */ },
		{ 0x133362 /* AppKit.INSEditorRegistration */, 0x133562 /* NSEditorRegistrationWrapper */ },
		{ 0x133A62 /* AppKit.INSFilePromiseProviderDelegate */, 0x133C62 /* NSFilePromiseProviderDelegateWrapper */ },
		{ 0x134062 /* AppKit.INSFontChanging */, 0x134262 /* NSFontChangingWrapper */ },
		{ 0x134C62 /* AppKit.INSGestureRecognizerDelegate */, 0x134E62 /* NSGestureRecognizerDelegateWrapper */ },
		{ 0x135A62 /* AppKit.INSHapticFeedbackPerformer */, 0x135B62 /* NSHapticFeedbackPerformerWrapper */ },
		{ 0x136362 /* AppKit.INSImageDelegate */, 0x136562 /* NSImageDelegateWrapper */ },
		{ 0x137462 /* AppKit.INSLayoutManagerDelegate */, 0x137662 /* NSLayoutManagerDelegateWrapper */ },
		{ 0x137E62 /* AppKit.INSMatrixDelegate */, 0x137F62 /* NSMatrixDelegateWrapper */ },
		{ 0x138262 /* AppKit.INSMenuDelegate */, 0x138462 /* NSMenuDelegateWrapper */ },
		{ 0x138862 /* AppKit.INSMenuItemValidation */, 0x138962 /* NSMenuItemValidationWrapper */ },
		{ 0x139B62 /* AppKit.INSOpenSavePanelDelegate */, 0x139D62 /* NSOpenSavePanelDelegateWrapper */ },
		{ 0x13A062 /* AppKit.INSOutlineViewDataSource */, 0x13A262 /* NSOutlineViewDataSourceWrapper */ },
		{ 0x13A462 /* AppKit.INSOutlineViewDelegate */, 0x13A662 /* NSOutlineViewDelegateWrapper */ },
		{ 0x13AB62 /* AppKit.INSPageControllerDelegate */, 0x13AD62 /* NSPageControllerDelegateWrapper */ },
		{ 0x13B562 /* AppKit.INSPasteboardItemDataProvider */, 0x13B662 /* NSPasteboardItemDataProviderWrapper */ },
		{ 0x13B862 /* AppKit.INSPasteboardReading */, 0x13B962 /* NSPasteboardReadingWrapper */ },
		{ 0x13BB62 /* AppKit.INSPasteboardTypeOwner */, 0x13BD62 /* NSPasteboardTypeOwnerWrapper */ },
		{ 0x13BE62 /* AppKit.INSPasteboardWriting */, 0x13C062 /* NSPasteboardWritingWrapper */ },
		{ 0x13C562 /* AppKit.INSPathCellDelegate */, 0x13C762 /* NSPathCellDelegateWrapper */ },
		{ 0x13CB62 /* AppKit.INSPathControlDelegate */, 0x13CD62 /* NSPathControlDelegateWrapper */ },
		{ 0x13D262 /* AppKit.INSPopoverDelegate */, 0x13D462 /* NSPopoverDelegateWrapper */ },
		{ 0x13E162 /* AppKit.INSPrintPanelAccessorizing */, 0x13E262 /* NSPrintPanelAccessorizingWrapper */ },
		{ 0x13ED62 /* AppKit.INSRuleEditorDelegate */, 0x13EF62 /* NSRuleEditorDelegateWrapper */ },
		{ 0x140062 /* AppKit.INSScrubberDataSource */, 0x140162 /* NSScrubberDataSourceWrapper */ },
		{ 0x140362 /* AppKit.INSScrubberDelegate */, 0x140562 /* NSScrubberDelegateWrapper */ },
		{ 0x140862 /* AppKit.INSScrubberFlowLayoutDelegate */, 0x140A62 /* NSScrubberFlowLayoutDelegateWrapper */ },
		{ 0x141662 /* AppKit.INSSearchFieldDelegate */, 0x141862 /* NSSearchFieldDelegateWrapper */ },
		{ 0x141F62 /* AppKit.INSSeguePerforming */, 0x142162 /* NSSeguePerformingWrapper */ },
		{ 0x142362 /* AppKit.INSServicesMenuRequestor */, 0x142562 /* NSServicesMenuRequestorWrapper */ },
		{ 0x142A62 /* AppKit.INSSharingServiceDelegate */, 0x142C62 /* NSSharingServiceDelegateWrapper */ },
		{ 0x143262 /* AppKit.INSSharingServicePickerDelegate */, 0x143462 /* NSSharingServicePickerDelegateWrapper */ },
		{ 0x143762 /* AppKit.INSSharingServicePickerTouchBarItemDelegate */, 0x143862 /* NSSharingServicePickerTouchBarItemDelegateWrapper */ },
		{ 0x144162 /* AppKit.INSSoundDelegate */, 0x144362 /* NSSoundDelegateWrapper */ },
		{ 0x144662 /* AppKit.INSSpeechRecognizerDelegate */, 0x144862 /* NSSpeechRecognizerDelegateWrapper */ },
		{ 0x144B62 /* AppKit.INSSpeechSynthesizerDelegate */, 0x144D62 /* NSSpeechSynthesizerDelegateWrapper */ },
		{ 0x145362 /* AppKit.INSSplitViewDelegate */, 0x145562 /* NSSplitViewDelegateWrapper */ },
		{ 0x145862 /* AppKit.INSSpringLoadingDestination */, 0x145A62 /* NSSpringLoadingDestinationWrapper */ },
		{ 0x145D62 /* AppKit.INSStackViewDelegate */, 0x145F62 /* NSStackViewDelegateWrapper */ },
		{ 0x146262 /* AppKit.INSStandardKeyBindingResponding */, 0x146462 /* NSStandardKeyBindingRespondingWrapper */ },
		{ 0x147962 /* AppKit.INSTableViewDataSource */, 0x147B62 /* NSTableViewDataSourceWrapper */ },
		{ 0x147D62 /* AppKit.INSTableViewDelegate */, 0x147F62 /* NSTableViewDelegateWrapper */ },
		{ 0x148662 /* AppKit.INSTabViewDelegate */, 0x148862 /* NSTabViewDelegateWrapper */ },
		{ 0x148F62 /* AppKit.INSTextAttachmentContainer */, 0x149062 /* NSTextAttachmentContainerWrapper */ },
		{ 0x149662 /* AppKit.INSTextDelegate */, 0x149862 /* NSTextDelegateWrapper */ },
		{ 0x149E62 /* AppKit.INSTextFieldDelegate */, 0x14A062 /* NSTextFieldDelegateWrapper */ },
		{ 0x14A362 /* AppKit.INSTextFinderBarContainer */, 0x14A562 /* NSTextFinderBarContainerWrapper */ },
		{ 0x14A762 /* AppKit.INSTextFinderClient */, 0x14A862 /* NSTextFinderClientWrapper */ },
		{ 0x14AB62 /* AppKit.INSTextInput */, 0x14AC62 /* NSTextInputWrapper */ },
		{ 0x14AD62 /* AppKit.INSTextInputClient */, 0x14AF62 /* NSTextInputClientWrapper */ },
		{ 0x14B762 /* AppKit.INSTextStorageDelegate */, 0x14B962 /* NSTextStorageDelegateWrapper */ },
		{ 0x14C362 /* AppKit.INSTextViewDelegate */, 0x14C562 /* NSTextViewDelegateWrapper */ },
		{ 0x14CA62 /* AppKit.INSTokenFieldCellDelegate */, 0x14CC62 /* NSTokenFieldCellDelegateWrapper */ },
		{ 0x14CE62 /* AppKit.INSTokenFieldDelegate */, 0x14D062 /* NSTokenFieldDelegateWrapper */ },
		{ 0x14D362 /* AppKit.INSToolbarDelegate */, 0x14D562 /* NSToolbarDelegateWrapper */ },
		{ 0x14D962 /* AppKit.INSToolbarItemValidation */, 0x14DA62 /* NSToolbarItemValidationWrapper */ },
		{ 0x14E062 /* AppKit.INSTouchBarDelegate */, 0x14E262 /* NSTouchBarDelegateWrapper */ },
		{ 0x14E762 /* AppKit.INSTouchBarProvider */, 0x14E862 /* NSTouchBarProviderWrapper */ },
		{ 0x14EE62 /* AppKit.INSUserInterfaceCompression */, 0x14EF62 /* NSUserInterfaceCompressionWrapper */ },
		{ 0x14F162 /* AppKit.INSUserInterfaceItemIdentification */, 0x14F362 /* NSUserInterfaceItemIdentificationWrapper */ },
		{ 0x14F462 /* AppKit.INSUserInterfaceValidations */, 0x14F562 /* NSUserInterfaceValidationsWrapper */ },
		{ 0x14F662 /* AppKit.INSValidatedUserInterfaceItem */, 0x14F762 /* NSValidatedUserInterfaceItemWrapper */ },
		{ 0x14FD62 /* AppKit.INSViewControllerPresentationAnimator */, 0x14FE62 /* NSViewControllerPresentationAnimatorWrapper */ },
		{ 0x150062 /* AppKit.INSViewToolTipOwner */, 0x150162 /* NSViewToolTipOwnerWrapper */ },
		{ 0x150762 /* AppKit.INSWindowDelegate */, 0x150962 /* NSWindowDelegateWrapper */ },
		{ 0x150B62 /* AppKit.INSWindowRestoration */, 0x150C62 /* NSWindowRestorationWrapper */ },
		{ 0x16EE62 /* Foundation.INSCacheDelegate */, 0x16F062 /* NSCacheDelegateWrapper */ },
		{ 0x16F762 /* Foundation.INSCoding */, 0x16F862 /* NSCodingWrapper */ },
		{ 0x16FF62 /* Foundation.INSConnectionDelegate */, 0x170162 /* NSConnectionDelegateWrapper */ },
		{ 0x170362 /* Foundation.INSCopying */, 0x170462 /* NSCopyingWrapper */ },
		{ 0x171262 /* Foundation.INSDiscardableContent */, 0x171362 /* NSDiscardableContentWrapper */ },
		{ 0x171E62 /* Foundation.INSExtensionRequestHandling */, 0x171F62 /* NSExtensionRequestHandlingWrapper */ },
		{ 0x172662 /* Foundation.INSFileManagerDelegate */, 0x172862 /* NSFileManagerDelegateWrapper */ },
		{ 0x172A62 /* Foundation.INSFilePresenter */, 0x172C62 /* NSFilePresenterWrapper */ },
		{ 0x173F62 /* Foundation.INSItemProviderReading */, 0x174062 /* NSItemProviderReadingWrapper */ },
		{ 0x174162 /* Foundation.INSItemProviderWriting */, 0x174362 /* NSItemProviderWritingWrapper */ },
		{ 0x174862 /* Foundation.INSKeyedArchiverDelegate */, 0x174A62 /* NSKeyedArchiverDelegateWrapper */ },
		{ 0x174D62 /* Foundation.INSKeyedUnarchiverDelegate */, 0x174F62 /* NSKeyedUnarchiverDelegateWrapper */ },
		{ 0x175D62 /* Foundation.INSLocking */, 0x175E62 /* NSLockingWrapper */ },
		{ 0x176062 /* Foundation.INSMachPortDelegate */, 0x176262 /* NSMachPortDelegateWrapper */ },
		{ 0x176A62 /* Foundation.INSMetadataQueryDelegate */, 0x176C62 /* NSMetadataQueryDelegateWrapper */ },
		{ 0x177362 /* Foundation.INSMutableCopying */, 0x177462 /* NSMutableCopyingWrapper */ },
		{ 0x178462 /* Foundation.INSNetServiceBrowserDelegate */, 0x178662 /* NSNetServiceBrowserDelegateWrapper */ },
		{ 0x178862 /* Foundation.INSNetServiceDelegate */, 0x178A62 /* NSNetServiceDelegateWrapper */ },
		{ 0x179362 /* Foundation.INSObjectProtocol */, 0x179562 /* NSObjectProtocolWrapper */ },
		{ 0x17A062 /* Foundation.INSPortDelegate */, 0x17A262 /* NSPortDelegateWrapper */ },
		{ 0x17B062 /* Foundation.INSProgressReporting */, 0x17B262 /* NSProgressReportingWrapper */ },
		{ 0x17BE62 /* Foundation.INSSecureCoding */, 0x17BF62 /* NSSecureCodingWrapper */ },
		{ 0x17C662 /* Foundation.INSStreamDelegate */, 0x17C862 /* NSStreamDelegateWrapper */ },
		{ 0x17F262 /* Foundation.INSURLAuthenticationChallengeSender */, 0x17F462 /* NSURLAuthenticationChallengeSenderWrapper */ },
		{ 0x17FA62 /* Foundation.INSUrlConnectionDataDelegate */, 0x17FC62 /* NSUrlConnectionDataDelegateWrapper */ },
		{ 0x17FE62 /* Foundation.INSUrlConnectionDelegate */, 0x180062 /* NSUrlConnectionDelegateWrapper */ },
		{ 0x180262 /* Foundation.INSUrlConnectionDownloadDelegate */, 0x180462 /* NSUrlConnectionDownloadDelegateWrapper */ },
		{ 0x180962 /* Foundation.INSUrlDownloadDelegate */, 0x180B62 /* NSUrlDownloadDelegateWrapper */ },
		{ 0x180F62 /* Foundation.INSUrlProtocolClient */, 0x181062 /* NSUrlProtocolClientWrapper */ },
		{ 0x181B62 /* Foundation.INSUrlSessionDataDelegate */, 0x181D62 /* NSUrlSessionDataDelegateWrapper */ },
		{ 0x182062 /* Foundation.INSUrlSessionDelegate */, 0x182262 /* NSUrlSessionDelegateWrapper */ },
		{ 0x182462 /* Foundation.INSUrlSessionDownloadDelegate */, 0x182662 /* NSUrlSessionDownloadDelegateWrapper */ },
		{ 0x182962 /* Foundation.INSUrlSessionStreamDelegate */, 0x182B62 /* NSUrlSessionStreamDelegateWrapper */ },
		{ 0x183062 /* Foundation.INSUrlSessionTaskDelegate */, 0x183262 /* NSUrlSessionTaskDelegateWrapper */ },
		{ 0x183C62 /* Foundation.INSUserActivityDelegate */, 0x183E62 /* NSUserActivityDelegateWrapper */ },
		{ 0x184762 /* Foundation.INSUserNotificationCenterDelegate */, 0x184962 /* NSUserNotificationCenterDelegateWrapper */ },
	};

	static struct MTRegistrationMap __xamarin_registration_map = {
		__xamarin_registration_assemblies,
		__xamarin_class_map,
		__xamarin_token_references,
		__xamarin_skipped_map,
		__xamarin_protocol_wrapper_map,
		{ NULL, NULL },
		183,
		2427,
		93,
		177,
		10,
		353,
		0
	};

void xamarin_create_classes () {
	__xamarin_class_map [0].handle = objc_getClass ("NSObject");
	__xamarin_class_map [1].handle = objc_getClass ("VSAccountManager");
	__xamarin_class_map [2].handle = objc_getClass ("VSAccountManagerDelegate");
	__xamarin_class_map [3].handle = objc_getClass ("VSAccountManagerResult");
	__xamarin_class_map [4].handle = objc_getClass ("VSAccountMetadata");
	__xamarin_class_map [5].handle = objc_getClass ("VSAccountMetadataRequest");
	__xamarin_class_map [6].handle = objc_getClass ("VSAccountProviderResponse");
	__xamarin_class_map [7].handle = objc_getClass ("VSSubscription");
	__xamarin_class_map [8].handle = objc_getClass ("VSSubscriptionRegistrationCenter");
	__xamarin_class_map [9].handle = objc_getClass ("UNNotificationTrigger");
	__xamarin_class_map [10].handle = objc_getClass ("UNCalendarNotificationTrigger");
	__xamarin_class_map [11].handle = objc_getClass ("UNNotificationContent");
	__xamarin_class_map [12].handle = objc_getClass ("UNMutableNotificationContent");
	__xamarin_class_map [13].handle = objc_getClass ("UNNotification");
	__xamarin_class_map [14].handle = objc_getClass ("UNNotificationAction");
	__xamarin_class_map [15].handle = objc_getClass ("UNNotificationAttachment");
	__xamarin_class_map [16].handle = objc_getClass ("UNNotificationCategory");
	__xamarin_class_map [17].handle = objc_getClass ("UNNotificationRequest");
	__xamarin_class_map [18].handle = objc_getClass ("UNNotificationResponse");
	__xamarin_class_map [19].handle = objc_getClass ("UNNotificationServiceExtension");
	__xamarin_class_map [20].handle = objc_getClass ("UNNotificationSettings");
	__xamarin_class_map [21].handle = objc_getClass ("UNNotificationSound");
	__xamarin_class_map [22].handle = objc_getClass ("UNPushNotificationTrigger");
	__xamarin_class_map [23].handle = objc_getClass ("UNTextInputNotificationAction");
	__xamarin_class_map [24].handle = objc_getClass ("UNTextInputNotificationResponse");
	__xamarin_class_map [25].handle = objc_getClass ("UNTimeIntervalNotificationTrigger");
	__xamarin_class_map [26].handle = objc_getClass ("UNUserNotificationCenterDelegate");
	__xamarin_class_map [27].handle = objc_getClass ("WebScriptObject");
	__xamarin_class_map [28].handle = objc_getClass ("DOMObject");
	__xamarin_class_map [29].handle = objc_getClass ("DOMAbstractView");
	__xamarin_class_map [30].handle = objc_getClass ("DOMNode");
	__xamarin_class_map [31].handle = objc_getClass ("DOMAttr");
	__xamarin_class_map [32].handle = objc_getClass ("DOMBlob");
	__xamarin_class_map [33].handle = objc_getClass ("DOMCharacterData");
	__xamarin_class_map [34].handle = objc_getClass ("DOMText");
	__xamarin_class_map [35].handle = objc_getClass ("DOMCDATASection");
	__xamarin_class_map [36].handle = objc_getClass ("DOMComment");
	__xamarin_class_map [37].handle = objc_getClass ("DOMCSSRule");
	__xamarin_class_map [38].handle = objc_getClass ("DOMCSSCharsetRule");
	__xamarin_class_map [39].handle = objc_getClass ("DOMCSSFontFaceRule");
	__xamarin_class_map [40].handle = objc_getClass ("DOMCSSMediaRule");
	__xamarin_class_map [41].handle = objc_getClass ("DOMCSSPageRule");
	__xamarin_class_map [42].handle = objc_getClass ("DOMCSSRuleList");
	__xamarin_class_map [43].handle = objc_getClass ("DOMCSSStyleDeclaration");
	__xamarin_class_map [44].handle = objc_getClass ("DOMCSSStyleRule");
	__xamarin_class_map [45].handle = objc_getClass ("DOMStyleSheet");
	__xamarin_class_map [46].handle = objc_getClass ("DOMCSSStyleSheet");
	__xamarin_class_map [47].handle = objc_getClass ("DOMCSSUnknownRule");
	__xamarin_class_map [48].handle = objc_getClass ("DOMCSSValue");
	__xamarin_class_map [49].handle = objc_getClass ("DOMDocument");
	__xamarin_class_map [50].handle = objc_getClass ("DOMDocumentFragment");
	__xamarin_class_map [51].handle = objc_getClass ("DOMDocumentType");
	__xamarin_class_map [52].handle = objc_getClass ("DOMElement");
	__xamarin_class_map [53].handle = objc_getClass ("DOMEntityReference");
	__xamarin_class_map [54].handle = objc_getClass ("DOMEvent");
	__xamarin_class_map [55].handle = objc_getClass ("DOMEventListener");
	__xamarin_class_map [56].handle = objc_getClass ("DOMEventTarget");
	__xamarin_class_map [57].handle = objc_getClass ("DOMFile");
	__xamarin_class_map [58].handle = objc_getClass ("DOMFileList");
	__xamarin_class_map [59].handle = objc_getClass ("DOMHTMLElement");
	__xamarin_class_map [60].handle = objc_getClass ("DOMHTMLAnchorElement");
	__xamarin_class_map [61].handle = objc_getClass ("DOMHTMLAppletElement");
	__xamarin_class_map [62].handle = objc_getClass ("DOMHTMLAreaElement");
	__xamarin_class_map [63].handle = objc_getClass ("DOMHTMLBaseElement");
	__xamarin_class_map [64].handle = objc_getClass ("DOMHTMLBaseFontElement");
	__xamarin_class_map [65].handle = objc_getClass ("DOMHTMLBodyElement");
	__xamarin_class_map [66].handle = objc_getClass ("DOMHTMLBRElement");
	__xamarin_class_map [67].handle = objc_getClass ("DOMHTMLButtonElement");
	__xamarin_class_map [68].handle = objc_getClass ("DOMHTMLCollection");
	__xamarin_class_map [69].handle = objc_getClass ("DOMHTMLDirectoryElement");
	__xamarin_class_map [70].handle = objc_getClass ("DOMHTMLDivElement");
	__xamarin_class_map [71].handle = objc_getClass ("DOMHTMLDListElement");
	__xamarin_class_map [72].handle = objc_getClass ("DOMHTMLDocument");
	__xamarin_class_map [73].handle = objc_getClass ("DOMHTMLEmbedElement");
	__xamarin_class_map [74].handle = objc_getClass ("DOMHTMLFieldSetElement");
	__xamarin_class_map [75].handle = objc_getClass ("DOMHTMLFontElement");
	__xamarin_class_map [76].handle = objc_getClass ("DOMHTMLFormElement");
	__xamarin_class_map [77].handle = objc_getClass ("DOMHTMLFrameElement");
	__xamarin_class_map [78].handle = objc_getClass ("DOMHTMLFrameSetElement");
	__xamarin_class_map [79].handle = objc_getClass ("DOMHTMLHeadElement");
	__xamarin_class_map [80].handle = objc_getClass ("DOMHTMLHeadingElement");
	__xamarin_class_map [81].handle = objc_getClass ("DOMHTMLHRElement");
	__xamarin_class_map [82].handle = objc_getClass ("DOMHTMLHtmlElement");
	__xamarin_class_map [83].handle = objc_getClass ("DOMHTMLIFrameElement");
	__xamarin_class_map [84].handle = objc_getClass ("DOMHTMLImageElement");
	__xamarin_class_map [85].handle = objc_getClass ("DOMHTMLInputElement");
	__xamarin_class_map [86].handle = objc_getClass ("DOMHTMLLabelElement");
	__xamarin_class_map [87].handle = objc_getClass ("DOMHTMLLegendElement");
	__xamarin_class_map [88].handle = objc_getClass ("DOMHTMLLIElement");
	__xamarin_class_map [89].handle = objc_getClass ("DOMHTMLLinkElement");
	__xamarin_class_map [90].handle = objc_getClass ("DOMHTMLMapElement");
	__xamarin_class_map [91].handle = objc_getClass ("DOMHTMLMarqueeElement");
	__xamarin_class_map [92].handle = objc_getClass ("DOMHTMLMenuElement");
	__xamarin_class_map [93].handle = objc_getClass ("DOMHTMLMetaElement");
	__xamarin_class_map [94].handle = objc_getClass ("DOMHTMLModElement");
	__xamarin_class_map [95].handle = objc_getClass ("DOMHTMLObjectElement");
	__xamarin_class_map [96].handle = objc_getClass ("DOMHTMLOListElement");
	__xamarin_class_map [97].handle = objc_getClass ("DOMHTMLOptGroupElement");
	__xamarin_class_map [98].handle = objc_getClass ("DOMHTMLOptionElement");
	__xamarin_class_map [99].handle = objc_getClass ("DOMHTMLOptionsCollection");
	__xamarin_class_map [100].handle = objc_getClass ("DOMHTMLParagraphElement");
	__xamarin_class_map [101].handle = objc_getClass ("DOMHTMLParamElement");
	__xamarin_class_map [102].handle = objc_getClass ("DOMHTMLPreElement");
	__xamarin_class_map [103].handle = objc_getClass ("DOMHTMLQuoteElement");
	__xamarin_class_map [104].handle = objc_getClass ("DOMHTMLScriptElement");
	__xamarin_class_map [105].handle = objc_getClass ("DOMHTMLSelectElement");
	__xamarin_class_map [106].handle = objc_getClass ("DOMHTMLStyleElement");
	__xamarin_class_map [107].handle = objc_getClass ("DOMHTMLTableCaptionElement");
	__xamarin_class_map [108].handle = objc_getClass ("DOMHTMLTableCellElement");
	__xamarin_class_map [109].handle = objc_getClass ("DOMHTMLTableColElement");
	__xamarin_class_map [110].handle = objc_getClass ("DOMHTMLTableElement");
	__xamarin_class_map [111].handle = objc_getClass ("DOMHTMLTableRowElement");
	__xamarin_class_map [112].handle = objc_getClass ("DOMHTMLTableSectionElement");
	__xamarin_class_map [113].handle = objc_getClass ("DOMHTMLTextAreaElement");
	__xamarin_class_map [114].handle = objc_getClass ("DOMImplementation");
	__xamarin_class_map [115].handle = objc_getClass ("DOMCSSImportRule");
	__xamarin_class_map [116].handle = objc_getClass ("DOMUIEvent");
	__xamarin_class_map [117].handle = objc_getClass ("DOMKeyboardEvent");
	__xamarin_class_map [118].handle = objc_getClass ("DOMMediaList");
	__xamarin_class_map [119].handle = objc_getClass ("DOMMouseEvent");
	__xamarin_class_map [120].handle = objc_getClass ("DOMNamedNodeMap");
	__xamarin_class_map [121].handle = objc_getClass ("Xamarin_Mac__WebKit_DomNodeFilter");
	__xamarin_class_map [122].handle = objc_getClass ("DOMNodeIterator");
	__xamarin_class_map [123].handle = objc_getClass ("DOMNodeList");
	__xamarin_class_map [124].handle = objc_getClass ("DOMOverflowEvent");
	__xamarin_class_map [125].handle = objc_getClass ("DOMProcessingInstruction");
	__xamarin_class_map [126].handle = objc_getClass ("DOMProgressEvent");
	__xamarin_class_map [127].handle = objc_getClass ("DOMRange");
	__xamarin_class_map [128].handle = objc_getClass ("DOMStyleSheetList");
	__xamarin_class_map [129].handle = objc_getClass ("DOMWheelEvent");
	__xamarin_class_map [130].handle = objc_getClass ("WebArchive");
	__xamarin_class_map [131].handle = objc_getClass ("WebBackForwardList");
	__xamarin_class_map [132].handle = objc_getClass ("WebDataSource");
	__xamarin_class_map [133].handle = objc_getClass ("WebDocumentRepresentation");
	__xamarin_class_map [134].handle = objc_getClass ("NSURLDownload");
	__xamarin_class_map [135].handle = objc_getClass ("WebDownload");
	__xamarin_class_map [136].handle = objc_getClass ("WebDownloadDelegate");
	__xamarin_class_map [137].handle = objc_getClass ("WebFrame");
	__xamarin_class_map [138].handle = objc_getClass ("WebFrameLoadDelegate");
	__xamarin_class_map [139].handle = objc_getClass ("NSResponder");
	__xamarin_class_map [140].handle = objc_getClass ("NSView");
	__xamarin_class_map [141].handle = objc_getClass ("WebFrameView");
	__xamarin_class_map [142].handle = objc_getClass ("WebHistory");
	__xamarin_class_map [143].handle = objc_getClass ("Xamarin_Mac__WebKit_WebOpenPanelResultListener");
	__xamarin_class_map [144].handle = objc_getClass ("Xamarin_Mac__WebKit_WebPolicyDecisionListener");
	__xamarin_class_map [145].handle = objc_getClass ("WebPolicyDelegate");
	__xamarin_class_map [146].handle = objc_getClass ("WebPreferences");
	__xamarin_class_map [147].handle = objc_getClass ("WebResource");
	__xamarin_class_map [148].handle = objc_getClass ("WebResourceLoadDelegate");
	__xamarin_class_map [149].handle = objc_getClass ("WebUIDelegate");
	__xamarin_class_map [150].handle = objc_getClass ("WKBackForwardList");
	__xamarin_class_map [151].handle = objc_getClass ("WKBackForwardListItem");
	__xamarin_class_map [152].handle = objc_getClass ("WKContentRuleList");
	__xamarin_class_map [153].handle = objc_getClass ("WKFrameInfo");
	__xamarin_class_map [154].handle = objc_getClass ("WKNavigation");
	__xamarin_class_map [155].handle = objc_getClass ("WKNavigationAction");
	__xamarin_class_map [156].handle = objc_getClass ("WKNavigationDelegate");
	__xamarin_class_map [157].handle = objc_getClass ("WKNavigationResponse");
	__xamarin_class_map [158].handle = objc_getClass ("WKOpenPanelParameters");
	__xamarin_class_map [159].handle = objc_getClass ("WKPreferences");
	__xamarin_class_map [160].handle = objc_getClass ("WKProcessPool");
	__xamarin_class_map [161].handle = objc_getClass ("WKScriptMessage");
	__xamarin_class_map [162].handle = objc_getClass ("WKScriptMessageHandler");
	__xamarin_class_map [163].handle = objc_getClass ("WKSecurityOrigin");
	__xamarin_class_map [164].handle = objc_getClass ("WKSnapshotConfiguration");
	__xamarin_class_map [165].handle = objc_getClass ("WKUIDelegate");
	__xamarin_class_map [166].handle = objc_getClass ("WKUserContentController");
	__xamarin_class_map [167].handle = objc_getClass ("WKUserScript");
	__xamarin_class_map [168].handle = objc_getClass ("WKWebsiteDataRecord");
	__xamarin_class_map [169].handle = objc_getClass ("WKWebViewConfiguration");
	__xamarin_class_map [170].handle = objc_getClass ("WKWindowFeatures");
	__xamarin_class_map [171].handle = objc_getClass ("VNObservation");
	__xamarin_class_map [172].handle = objc_getClass ("VNDetectedObjectObservation");
	__xamarin_class_map [173].handle = objc_getClass ("VNRectangleObservation");
	__xamarin_class_map [174].handle = objc_getClass ("VNBarcodeObservation");
	__xamarin_class_map [175].handle = objc_getClass ("VNClassificationObservation");
	__xamarin_class_map [176].handle = objc_getClass ("VNCoreMLFeatureValueObservation");
	__xamarin_class_map [177].handle = objc_getClass ("VNCoreMLModel");
	__xamarin_class_map [178].handle = objc_getClass ("VNRequest");
	__xamarin_class_map [179].handle = objc_getClass ("VNImageBasedRequest");
	__xamarin_class_map [180].handle = objc_getClass ("VNCoreMLRequest");
	__xamarin_class_map [181].handle = objc_getClass ("VNDetectBarcodesRequest");
	__xamarin_class_map [182].handle = objc_getClass ("VNDetectFaceLandmarksRequest");
	__xamarin_class_map [183].handle = objc_getClass ("VNDetectFaceRectanglesRequest");
	__xamarin_class_map [184].handle = objc_getClass ("VNDetectHorizonRequest");
	__xamarin_class_map [185].handle = objc_getClass ("VNDetectRectanglesRequest");
	__xamarin_class_map [186].handle = objc_getClass ("VNDetectTextRectanglesRequest");
	__xamarin_class_map [187].handle = objc_getClass ("VNFaceLandmarkRegion");
	__xamarin_class_map [188].handle = objc_getClass ("VNFaceLandmarkRegion2D");
	__xamarin_class_map [189].handle = objc_getClass ("VNFaceLandmarks");
	__xamarin_class_map [190].handle = objc_getClass ("VNFaceLandmarks2D");
	__xamarin_class_map [191].handle = objc_getClass ("VNFaceObservation");
	__xamarin_class_map [192].handle = objc_getClass ("VNTargetedImageRequest");
	__xamarin_class_map [193].handle = objc_getClass ("VNImageRegistrationRequest");
	__xamarin_class_map [194].handle = objc_getClass ("VNHomographicImageRegistrationRequest");
	__xamarin_class_map [195].handle = objc_getClass ("VNHorizonObservation");
	__xamarin_class_map [196].handle = objc_getClass ("VNImageAlignmentObservation");
	__xamarin_class_map [197].handle = objc_getClass ("VNImageHomographicAlignmentObservation");
	__xamarin_class_map [198].handle = objc_getClass ("VNImageRequestHandler");
	__xamarin_class_map [199].handle = objc_getClass ("VNImageTranslationAlignmentObservation");
	__xamarin_class_map [200].handle = objc_getClass ("VNPixelBufferObservation");
	__xamarin_class_map [201].handle = objc_getClass ("VNRecognizedObjectObservation");
	__xamarin_class_map [202].handle = objc_getClass ("VNSequenceRequestHandler");
	__xamarin_class_map [203].handle = objc_getClass ("VNTextObservation");
	__xamarin_class_map [204].handle = objc_getClass ("VNTrackingRequest");
	__xamarin_class_map [205].handle = objc_getClass ("VNTrackObjectRequest");
	__xamarin_class_map [206].handle = objc_getClass ("VNTrackRectangleRequest");
	__xamarin_class_map [207].handle = objc_getClass ("VNTranslationalImageRegistrationRequest");
	__xamarin_class_map [208].handle = objc_getClass ("SKDownload");
	__xamarin_class_map [209].handle = objc_getClass ("SKPayment");
	__xamarin_class_map [210].handle = objc_getClass ("SKMutablePayment");
	__xamarin_class_map [211].handle = objc_getClass ("SKPaymentQueue");
	__xamarin_class_map [212].handle = objc_getClass ("SKPaymentTransaction");
	__xamarin_class_map [213].handle = objc_getClass ("SKPaymentTransactionObserver");
	__xamarin_class_map [214].handle = objc_getClass ("SKProduct");
	__xamarin_class_map [215].handle = objc_getClass ("SKProductDiscount");
	__xamarin_class_map [216].handle = objc_getClass ("SKRequestDelegate");
	__xamarin_class_map [217].handle = objc_getClass ("SKProductsRequestDelegate");
	__xamarin_class_map [218].handle = objc_getClass ("SKProductsResponse");
	__xamarin_class_map [219].handle = objc_getClass ("SKProductSubscriptionPeriod");
	__xamarin_class_map [220].handle = objc_getClass ("SKRequest");
	__xamarin_class_map [221].handle = objc_getClass ("SKReceiptRefreshRequest");
	__xamarin_class_map [222].handle = objc_getClass ("SKStoreReviewController");
	__xamarin_class_map [223].handle = objc_getClass ("SKNode");
	__xamarin_class_map [224].handle = objc_getClass ("SK3DNode");
	__xamarin_class_map [225].handle = objc_getClass ("SKAction");
	__xamarin_class_map [226].handle = objc_getClass ("SKAttribute");
	__xamarin_class_map [227].handle = objc_getClass ("SKAttributeValue");
	__xamarin_class_map [228].handle = objc_getClass ("SKAudioNode");
	__xamarin_class_map [229].handle = objc_getClass ("SKCameraNode");
	__xamarin_class_map [230].handle = objc_getClass ("SKConstraint");
	__xamarin_class_map [231].handle = objc_getClass ("SKCropNode");
	__xamarin_class_map [232].handle = objc_getClass ("SKEffectNode");
	__xamarin_class_map [233].handle = objc_getClass ("SKEmitterNode");
	__xamarin_class_map [234].handle = objc_getClass ("SKFieldNode");
	__xamarin_class_map [235].handle = objc_getClass ("SKKeyframeSequence");
	__xamarin_class_map [236].handle = objc_getClass ("SKLabelNode");
	__xamarin_class_map [237].handle = objc_getClass ("SKLightNode");
	__xamarin_class_map [238].handle = objc_getClass ("SKTexture");
	__xamarin_class_map [239].handle = objc_getClass ("SKMutableTexture");
	__xamarin_class_map [240].handle = objc_getClass ("SKPhysicsBody");
	__xamarin_class_map [241].handle = objc_getClass ("SKPhysicsContact");
	__xamarin_class_map [242].handle = objc_getClass ("SKPhysicsContactDelegate");
	__xamarin_class_map [243].handle = objc_getClass ("SKPhysicsJoint");
	__xamarin_class_map [244].handle = objc_getClass ("SKPhysicsJointFixed");
	__xamarin_class_map [245].handle = objc_getClass ("SKPhysicsJointLimit");
	__xamarin_class_map [246].handle = objc_getClass ("SKPhysicsJointPin");
	__xamarin_class_map [247].handle = objc_getClass ("SKPhysicsJointSliding");
	__xamarin_class_map [248].handle = objc_getClass ("SKPhysicsJointSpring");
	__xamarin_class_map [249].handle = objc_getClass ("SKRange");
	__xamarin_class_map [250].handle = objc_getClass ("SKReachConstraints");
	__xamarin_class_map [251].handle = objc_getClass ("SKReferenceNode");
	__xamarin_class_map [252].handle = objc_getClass ("SKRegion");
	__xamarin_class_map [253].handle = objc_getClass ("SKRenderer");
	__xamarin_class_map [254].handle = objc_getClass ("SKScene");
	__xamarin_class_map [255].handle = objc_getClass ("SKSceneDelegate");
	__xamarin_class_map [256].handle = objc_getClass ("SKShader");
	__xamarin_class_map [257].handle = objc_getClass ("SKShapeNode");
	__xamarin_class_map [258].handle = objc_getClass ("SKSpriteNode");
	__xamarin_class_map [259].handle = objc_getClass ("SKTileDefinition");
	__xamarin_class_map [260].handle = objc_getClass ("SKTileGroup");
	__xamarin_class_map [261].handle = objc_getClass ("SKTileGroupRule");
	__xamarin_class_map [262].handle = objc_getClass ("SKTileMapNode");
	__xamarin_class_map [263].handle = objc_getClass ("SKTileSet");
	__xamarin_class_map [264].handle = objc_getClass ("SKTransformNode");
	__xamarin_class_map [265].handle = objc_getClass ("SKTransition");
	__xamarin_class_map [266].handle = objc_getClass ("SKUniform");
	__xamarin_class_map [267].handle = objc_getClass ("SKVideoNode");
	__xamarin_class_map [268].handle = objc_getClass ("SKView");
	__xamarin_class_map [269].handle = objc_getClass ("SKViewDelegate");
	__xamarin_class_map [270].handle = objc_getClass ("SKWarpGeometry");
	__xamarin_class_map [271].handle = objc_getClass ("SKWarpGeometryGrid");
	__xamarin_class_map [272].handle = objc_getClass ("NSViewController");
	__xamarin_class_map [273].handle = objc_getClass ("SLComposeServiceViewController");
	__xamarin_class_map [274].handle = objc_getClass ("SBApplicationDelegate");
	__xamarin_class_map [275].handle = objc_getClass ("NSArray");
	__xamarin_class_map [276].handle = objc_getClass ("NSMutableArray");
	__xamarin_class_map [277].handle = objc_getClass ("SBElementArray");
	__xamarin_class_map [278].handle = objc_getClass ("SBObject");
	__xamarin_class_map [279].handle = objc_getClass ("SCNConstraint");
	__xamarin_class_map [280].handle = objc_getClass ("SCNAccelerationConstraint");
	__xamarin_class_map [281].handle = objc_getClass ("SCNAction");
	__xamarin_class_map [282].handle = objc_getClass ("SCNActionable");
	__xamarin_class_map [283].handle = objc_getClass ("SCNAnimatable");
	__xamarin_class_map [284].handle = objc_getClass ("SCNAnimation");
	__xamarin_class_map [285].handle = objc_getClass ("SCNAnimationPlayer");
	__xamarin_class_map [286].handle = objc_getClass ("SCNAudioPlayer");
	__xamarin_class_map [287].handle = objc_getClass ("SCNAudioSource");
	__xamarin_class_map [288].handle = objc_getClass ("SCNAvoidOccluderConstraint");
	__xamarin_class_map [289].handle = objc_getClass ("SCNAvoidOccluderConstraintDelegate");
	__xamarin_class_map [290].handle = objc_getClass ("SCNBillboardConstraint");
	__xamarin_class_map [291].handle = objc_getClass ("SCNBoundingVolume");
	__xamarin_class_map [292].handle = objc_getClass ("SCNGeometry");
	__xamarin_class_map [293].handle = objc_getClass ("SCNBox");
	__xamarin_class_map [294].handle = objc_getClass ("SCNCamera");
	__xamarin_class_map [295].handle = objc_getClass ("SCNCameraController");
	__xamarin_class_map [296].handle = objc_getClass ("SCNCameraControllerDelegate");
	__xamarin_class_map [297].handle = objc_getClass ("SCNCapsule");
	__xamarin_class_map [298].handle = objc_getClass ("SCNCone");
	__xamarin_class_map [299].handle = objc_getClass ("SCNCylinder");
	__xamarin_class_map [300].handle = objc_getClass ("SCNDistanceConstraint");
	__xamarin_class_map [301].handle = objc_getClass ("SCNFloor");
	__xamarin_class_map [302].handle = objc_getClass ("SCNGeometryElement");
	__xamarin_class_map [303].handle = objc_getClass ("SCNGeometrySource");
	__xamarin_class_map [304].handle = objc_getClass ("SCNGeometryTessellator");
	__xamarin_class_map [305].handle = objc_getClass ("SCNHitTestResult");
	__xamarin_class_map [306].handle = objc_getClass ("SCNIKConstraint");
	__xamarin_class_map [307].handle = objc_getClass ("SCNLevelOfDetail");
	__xamarin_class_map [308].handle = objc_getClass ("SCNLight");
	__xamarin_class_map [309].handle = objc_getClass ("SCNLookAtConstraint");
	__xamarin_class_map [310].handle = objc_getClass ("SCNMaterial");
	__xamarin_class_map [311].handle = objc_getClass ("SCNMaterialProperty");
	__xamarin_class_map [312].handle = objc_getClass ("SCNMorpher");
	__xamarin_class_map [313].handle = objc_getClass ("SCNNodeRendererDelegate");
	__xamarin_class_map [314].handle = objc_getClass ("SCNParticlePropertyController");
	__xamarin_class_map [315].handle = objc_getClass ("SCNParticleSystem");
	__xamarin_class_map [316].handle = objc_getClass ("SCNPhysicsBehavior");
	__xamarin_class_map [317].handle = objc_getClass ("SCNPhysicsBallSocketJoint");
	__xamarin_class_map [318].handle = objc_getClass ("SCNPhysicsBody");
	__xamarin_class_map [319].handle = objc_getClass ("SCNPhysicsConeTwistJoint");
	__xamarin_class_map [320].handle = objc_getClass ("SCNPhysicsContact");
	__xamarin_class_map [321].handle = objc_getClass ("SCNPhysicsContactDelegate");
	__xamarin_class_map [322].handle = objc_getClass ("SCNPhysicsField");
	__xamarin_class_map [323].handle = objc_getClass ("SCNPhysicsHingeJoint");
	__xamarin_class_map [324].handle = objc_getClass ("SCNPhysicsShape");
	__xamarin_class_map [325].handle = objc_getClass ("SCNPhysicsSliderJoint");
	__xamarin_class_map [326].handle = objc_getClass ("SCNPhysicsVehicle");
	__xamarin_class_map [327].handle = objc_getClass ("SCNPhysicsVehicleWheel");
	__xamarin_class_map [328].handle = objc_getClass ("SCNPlane");
	__xamarin_class_map [329].handle = objc_getClass ("SCNProgram");
	__xamarin_class_map [330].handle = objc_getClass ("SCNProgramDelegate");
	__xamarin_class_map [331].handle = objc_getClass ("SCNPyramid");
	__xamarin_class_map [332].handle = objc_getClass ("SCNNode");
	__xamarin_class_map [333].handle = objc_getClass ("SCNReferenceNode");
	__xamarin_class_map [334].handle = objc_getClass ("SCNReplicatorConstraint");
	__xamarin_class_map [335].handle = objc_getClass ("SCNScene");
	__xamarin_class_map [336].handle = objc_getClass ("SCNSceneExportDelegate");
	__xamarin_class_map [337].handle = objc_getClass ("SCNSceneRenderer");
	__xamarin_class_map [338].handle = objc_getClass ("SCNSceneRendererDelegate");
	__xamarin_class_map [339].handle = objc_getClass ("SCNSceneSource");
	__xamarin_class_map [340].handle = objc_getClass ("SCNShadable");
	__xamarin_class_map [341].handle = objc_getClass ("SCNShape");
	__xamarin_class_map [342].handle = objc_getClass ("SCNSkinner");
	__xamarin_class_map [343].handle = objc_getClass ("SCNSliderConstraint");
	__xamarin_class_map [344].handle = objc_getClass ("SCNSphere");
	__xamarin_class_map [345].handle = objc_getClass ("SCNTechnique");
	__xamarin_class_map [346].handle = objc_getClass ("SCNTechniqueSupport");
	__xamarin_class_map [347].handle = objc_getClass ("SCNText");
	__xamarin_class_map [348].handle = objc_getClass ("SCNTimingFunction");
	__xamarin_class_map [349].handle = objc_getClass ("SCNTorus");
	__xamarin_class_map [350].handle = objc_getClass ("SCNTransaction");
	__xamarin_class_map [351].handle = objc_getClass ("SCNTransformConstraint");
	__xamarin_class_map [352].handle = objc_getClass ("SCNTube");
	__xamarin_class_map [353].handle = objc_getClass ("SFContentBlockerState");
	__xamarin_class_map [354].handle = objc_getClass ("SFSafariExtensionViewController");
	__xamarin_class_map [355].handle = objc_getClass ("SFSafariPageProperties");
	__xamarin_class_map [356].handle = objc_getClass ("SFSafariToolbarItem");
	__xamarin_class_map [357].handle = objc_getClass ("QLPreviewItem");
	__xamarin_class_map [358].handle = objc_getClass ("NSWindow");
	__xamarin_class_map [359].handle = objc_getClass ("NSPanel");
	__xamarin_class_map [360].handle = objc_getClass ("QLPreviewPanel");
	__xamarin_class_map [361].handle = objc_getClass ("QLPreviewPanelDataSource");
	__xamarin_class_map [362].handle = objc_getClass ("QLPreviewPanelDelegate");
	__xamarin_class_map [363].handle = objc_getClass ("QLPreviewView");
	__xamarin_class_map [364].handle = objc_getClass ("QCComposition");
	__xamarin_class_map [365].handle = objc_getClass ("CALayer");
	__xamarin_class_map [366].handle = objc_getClass ("CAOpenGLLayer");
	__xamarin_class_map [367].handle = objc_getClass ("QCCompositionLayer");
	__xamarin_class_map [368].handle = objc_getClass ("QCCompositionRepository");
	__xamarin_class_map [369].handle = objc_getClass ("PHLivePhotoView");
	__xamarin_class_map [370].handle = objc_getClass ("PHLivePhotoViewDelegate");
	__xamarin_class_map [371].handle = objc_getClass ("PHProjectElement");
	__xamarin_class_map [372].handle = objc_getClass ("PHProjectAssetElement");
	__xamarin_class_map [373].handle = objc_getClass ("NSExtensionContext");
	__xamarin_class_map [374].handle = objc_getClass ("PHProjectExtensionContext");
	__xamarin_class_map [375].handle = objc_getClass ("PHProjectInfo");
	__xamarin_class_map [376].handle = objc_getClass ("PHProjectJournalEntryElement");
	__xamarin_class_map [377].handle = objc_getClass ("PHProjectMapElement");
	__xamarin_class_map [378].handle = objc_getClass ("PHProjectRegionOfInterest");
	__xamarin_class_map [379].handle = objc_getClass ("PHProjectSection");
	__xamarin_class_map [380].handle = objc_getClass ("PHProjectSectionContent");
	__xamarin_class_map [381].handle = objc_getClass ("PHProjectTextElement");
	__xamarin_class_map [382].handle = objc_getClass ("PHProjectTypeDescription");
	__xamarin_class_map [383].handle = objc_getClass ("PHProjectTypeDescriptionDataSource");
	__xamarin_class_map [384].handle = objc_getClass ("PHAdjustmentData");
	__xamarin_class_map [385].handle = objc_getClass ("PHObject");
	__xamarin_class_map [386].handle = objc_getClass ("PHAsset");
	__xamarin_class_map [387].handle = objc_getClass ("PHCollection");
	__xamarin_class_map [388].handle = objc_getClass ("PHAssetCollection");
	__xamarin_class_map [389].handle = objc_getClass ("PHChange");
	__xamarin_class_map [390].handle = objc_getClass ("PHCloudIdentifier");
	__xamarin_class_map [391].handle = objc_getClass ("PHCollectionList");
	__xamarin_class_map [392].handle = objc_getClass ("PHContentEditingInput");
	__xamarin_class_map [393].handle = objc_getClass ("PHContentEditingOutput");
	__xamarin_class_map [394].handle = objc_getClass ("PHFetchOptions");
	__xamarin_class_map [395].handle = objc_getClass ("PHFetchResult");
	__xamarin_class_map [396].handle = objc_getClass ("PHFetchResultChangeDetails");
	__xamarin_class_map [397].handle = objc_getClass ("PHImageManager");
	__xamarin_class_map [398].handle = objc_getClass ("PHImageRequestOptions");
	__xamarin_class_map [399].handle = objc_getClass ("PHLivePhoto");
	__xamarin_class_map [400].handle = objc_getClass ("PHObjectChangeDetails");
	__xamarin_class_map [401].handle = objc_getClass ("PHPhotoLibraryChangeObserver");
	__xamarin_class_map [402].handle = objc_getClass ("PHProject");
	__xamarin_class_map [403].handle = objc_getClass ("PHProjectChangeRequest");
	__xamarin_class_map [404].handle = objc_getClass ("PDFAction");
	__xamarin_class_map [405].handle = objc_getClass ("PDFActionGoTo");
	__xamarin_class_map [406].handle = objc_getClass ("PDFActionNamed");
	__xamarin_class_map [407].handle = objc_getClass ("PDFActionRemoteGoTo");
	__xamarin_class_map [408].handle = objc_getClass ("PDFActionResetForm");
	__xamarin_class_map [409].handle = objc_getClass ("PDFActionURL");
	__xamarin_class_map [410].handle = objc_getClass ("PDFAnnotation");
	__xamarin_class_map [411].handle = objc_getClass ("PDFAnnotationButtonWidget");
	__xamarin_class_map [412].handle = objc_getClass ("PDFAnnotationChoiceWidget");
	__xamarin_class_map [413].handle = objc_getClass ("PDFAnnotationCircle");
	__xamarin_class_map [414].handle = objc_getClass ("PDFAnnotationFreeText");
	__xamarin_class_map [415].handle = objc_getClass ("PDFAnnotationInk");
	__xamarin_class_map [416].handle = objc_getClass ("PDFAnnotationLine");
	__xamarin_class_map [417].handle = objc_getClass ("PDFAnnotationLink");
	__xamarin_class_map [418].handle = objc_getClass ("PDFAnnotationMarkup");
	__xamarin_class_map [419].handle = objc_getClass ("PDFAnnotationPopup");
	__xamarin_class_map [420].handle = objc_getClass ("PDFAnnotationSquare");
	__xamarin_class_map [421].handle = objc_getClass ("PDFAnnotationStamp");
	__xamarin_class_map [422].handle = objc_getClass ("PDFAnnotationText");
	__xamarin_class_map [423].handle = objc_getClass ("PDFAnnotationTextWidget");
	__xamarin_class_map [424].handle = objc_getClass ("PDFAppearanceCharacteristics");
	__xamarin_class_map [425].handle = objc_getClass ("PDFBorder");
	__xamarin_class_map [426].handle = objc_getClass ("PDFDestination");
	__xamarin_class_map [427].handle = objc_getClass ("PDFDocumentDelegate");
	__xamarin_class_map [428].handle = objc_getClass ("PDFOutline");
	__xamarin_class_map [429].handle = objc_getClass ("PDFPage");
	__xamarin_class_map [430].handle = objc_getClass ("PDFSelection");
	__xamarin_class_map [431].handle = objc_getClass ("PDFViewDelegate");
	__xamarin_class_map [432].handle = objc_getClass ("NCWidgetController");
	__xamarin_class_map [433].handle = objc_getClass ("NCWidgetListViewDelegate");
	__xamarin_class_map [434].handle = objc_getClass ("NCWidgetProviding");
	__xamarin_class_map [435].handle = objc_getClass ("NCWidgetSearchViewDelegate");
	__xamarin_class_map [436].handle = objc_getClass ("NEAppRule");
	__xamarin_class_map [437].handle = objc_getClass ("NEVPNProtocol");
	__xamarin_class_map [438].handle = objc_getClass ("NEDNSProxyProviderProtocol");
	__xamarin_class_map [439].handle = objc_getClass ("NEDNSSettings");
	__xamarin_class_map [440].handle = objc_getClass ("NEEvaluateConnectionRule");
	__xamarin_class_map [441].handle = objc_getClass ("NEFilterProviderConfiguration");
	__xamarin_class_map [442].handle = objc_getClass ("NEFlowMetaData");
	__xamarin_class_map [443].handle = objc_getClass ("NEIPv4Route");
	__xamarin_class_map [444].handle = objc_getClass ("NEIPv4Settings");
	__xamarin_class_map [445].handle = objc_getClass ("NEIPv6Route");
	__xamarin_class_map [446].handle = objc_getClass ("NEIPv6Settings");
	__xamarin_class_map [447].handle = objc_getClass ("NEOnDemandRule");
	__xamarin_class_map [448].handle = objc_getClass ("NEOnDemandRuleConnect");
	__xamarin_class_map [449].handle = objc_getClass ("NEOnDemandRuleDisconnect");
	__xamarin_class_map [450].handle = objc_getClass ("NEOnDemandRuleEvaluateConnection");
	__xamarin_class_map [451].handle = objc_getClass ("NEOnDemandRuleIgnore");
	__xamarin_class_map [452].handle = objc_getClass ("NEPacket");
	__xamarin_class_map [453].handle = objc_getClass ("NETunnelNetworkSettings");
	__xamarin_class_map [454].handle = objc_getClass ("NEPacketTunnelNetworkSettings");
	__xamarin_class_map [455].handle = objc_getClass ("NEProxyServer");
	__xamarin_class_map [456].handle = objc_getClass ("NEProxySettings");
	__xamarin_class_map [457].handle = objc_getClass ("NETunnelProviderProtocol");
	__xamarin_class_map [458].handle = objc_getClass ("NEVPNConnection");
	__xamarin_class_map [459].handle = objc_getClass ("NETunnelProviderSession");
	__xamarin_class_map [460].handle = objc_getClass ("NEVPNIKEv2SecurityAssociationParameters");
	__xamarin_class_map [461].handle = objc_getClass ("NEVPNProtocolIPSec");
	__xamarin_class_map [462].handle = objc_getClass ("NEVPNProtocolIKEv2");
	__xamarin_class_map [463].handle = objc_getClass ("NWEndpoint");
	__xamarin_class_map [464].handle = objc_getClass ("NWBonjourServiceEndpoint");
	__xamarin_class_map [465].handle = objc_getClass ("NWHostEndpoint");
	__xamarin_class_map [466].handle = objc_getClass ("NWPath");
	__xamarin_class_map [467].handle = objc_getClass ("NWTCPConnectionAuthenticationDelegate");
	__xamarin_class_map [468].handle = objc_getClass ("NWTLSParameters");
	__xamarin_class_map [469].handle = objc_getClass ("NLModel");
	__xamarin_class_map [470].handle = objc_getClass ("NLModelConfiguration");
	__xamarin_class_map [471].handle = objc_getClass ("NLTokenizer");
	__xamarin_class_map [472].handle = objc_getClass ("MCAdvertiserAssistant");
	__xamarin_class_map [473].handle = objc_getClass ("MCAdvertiserAssistantDelegate");
	__xamarin_class_map [474].handle = objc_getClass ("MCBrowserViewController");
	__xamarin_class_map [475].handle = objc_getClass ("MCBrowserViewControllerDelegate");
	__xamarin_class_map [476].handle = objc_getClass ("MCNearbyServiceAdvertiser");
	__xamarin_class_map [477].handle = objc_getClass ("MCNearbyServiceAdvertiserDelegate");
	__xamarin_class_map [478].handle = objc_getClass ("MCNearbyServiceBrowser");
	__xamarin_class_map [479].handle = objc_getClass ("MCNearbyServiceBrowserDelegate");
	__xamarin_class_map [480].handle = objc_getClass ("MCPeerID");
	__xamarin_class_map [481].handle = objc_getClass ("MCSessionDelegate");
	__xamarin_class_map [482].handle = objc_getClass ("MDLAnimatedValue");
	__xamarin_class_map [483].handle = objc_getClass ("MDLAnimatedMatrix4x4");
	__xamarin_class_map [484].handle = objc_getClass ("MDLAnimatedQuaternionArray");
	__xamarin_class_map [485].handle = objc_getClass ("MDLAnimatedScalar");
	__xamarin_class_map [486].handle = objc_getClass ("MDLAnimatedScalarArray");
	__xamarin_class_map [487].handle = objc_getClass ("MDLAnimatedVector2");
	__xamarin_class_map [488].handle = objc_getClass ("MDLAnimatedVector3");
	__xamarin_class_map [489].handle = objc_getClass ("MDLAnimatedVector3Array");
	__xamarin_class_map [490].handle = objc_getClass ("MDLAnimatedVector4");
	__xamarin_class_map [491].handle = objc_getClass ("MDLAnimationBindComponent");
	__xamarin_class_map [492].handle = objc_getClass ("MDLObject");
	__xamarin_class_map [493].handle = objc_getClass ("MDLLight");
	__xamarin_class_map [494].handle = objc_getClass ("MDLPhysicallyPlausibleLight");
	__xamarin_class_map [495].handle = objc_getClass ("MDLAreaLight");
	__xamarin_class_map [496].handle = objc_getClass ("MDLAsset");
	__xamarin_class_map [497].handle = objc_getClass ("MDLBundleAssetResolver");
	__xamarin_class_map [498].handle = objc_getClass ("MDLCamera");
	__xamarin_class_map [499].handle = objc_getClass ("MDLTexture");
	__xamarin_class_map [500].handle = objc_getClass ("MDLCheckerboardTexture");
	__xamarin_class_map [501].handle = objc_getClass ("MDLColorSwatchTexture");
	__xamarin_class_map [502].handle = objc_getClass ("MDLLightProbe");
	__xamarin_class_map [503].handle = objc_getClass ("MDLLightProbeIrradianceDataSource");
	__xamarin_class_map [504].handle = objc_getClass ("MDLMaterial");
	__xamarin_class_map [505].handle = objc_getClass ("MDLMaterialProperty");
	__xamarin_class_map [506].handle = objc_getClass ("MDLMaterialPropertyConnection");
	__xamarin_class_map [507].handle = objc_getClass ("MDLMaterialPropertyNode");
	__xamarin_class_map [508].handle = objc_getClass ("MDLMaterialPropertyGraph");
	__xamarin_class_map [509].handle = objc_getClass ("MDLMatrix4x4Array");
	__xamarin_class_map [510].handle = objc_getClass ("MDLMeshBufferData");
	__xamarin_class_map [511].handle = objc_getClass ("MDLMeshBufferDataAllocator");
	__xamarin_class_map [512].handle = objc_getClass ("MDLMeshBufferMap");
	__xamarin_class_map [513].handle = objc_getClass ("MDLMeshBufferZoneDefault");
	__xamarin_class_map [514].handle = objc_getClass ("MDLNoiseTexture");
	__xamarin_class_map [515].handle = objc_getClass ("MDLNormalMapTexture");
	__xamarin_class_map [516].handle = objc_getClass ("MDLObjectContainer");
	__xamarin_class_map [517].handle = objc_getClass ("MDLPackedJointAnimation");
	__xamarin_class_map [518].handle = objc_getClass ("MDLPathAssetResolver");
	__xamarin_class_map [519].handle = objc_getClass ("MDLPhotometricLight");
	__xamarin_class_map [520].handle = objc_getClass ("MDLScatteringFunction");
	__xamarin_class_map [521].handle = objc_getClass ("MDLPhysicallyPlausibleScatteringFunction");
	__xamarin_class_map [522].handle = objc_getClass ("MDLRelativeAssetResolver");
	__xamarin_class_map [523].handle = objc_getClass ("MDLSkeleton");
	__xamarin_class_map [524].handle = objc_getClass ("MDLSkyCubeTexture");
	__xamarin_class_map [525].handle = objc_getClass ("MDLStereoscopicCamera");
	__xamarin_class_map [526].handle = objc_getClass ("MDLSubmesh");
	__xamarin_class_map [527].handle = objc_getClass ("MDLSubmeshTopology");
	__xamarin_class_map [528].handle = objc_getClass ("MDLTextureFilter");
	__xamarin_class_map [529].handle = objc_getClass ("MDLTextureSampler");
	__xamarin_class_map [530].handle = objc_getClass ("MDLTransform");
	__xamarin_class_map [531].handle = objc_getClass ("MDLTransformMatrixOp");
	__xamarin_class_map [532].handle = objc_getClass ("MDLTransformRotateOp");
	__xamarin_class_map [533].handle = objc_getClass ("MDLTransformRotateXOp");
	__xamarin_class_map [534].handle = objc_getClass ("MDLTransformRotateYOp");
	__xamarin_class_map [535].handle = objc_getClass ("MDLTransformRotateZOp");
	__xamarin_class_map [536].handle = objc_getClass ("MDLTransformScaleOp");
	__xamarin_class_map [537].handle = objc_getClass ("MDLTransformStack");
	__xamarin_class_map [538].handle = objc_getClass ("MDLTransformTranslateOp");
	__xamarin_class_map [539].handle = objc_getClass ("MDLURLTexture");
	__xamarin_class_map [540].handle = objc_getClass ("MDLVertexAttribute");
	__xamarin_class_map [541].handle = objc_getClass ("MDLVertexAttributeData");
	__xamarin_class_map [542].handle = objc_getClass ("MDLVertexBufferLayout");
	__xamarin_class_map [543].handle = objc_getClass ("MDLVertexDescriptor");
	__xamarin_class_map [544].handle = objc_getClass ("MDLVoxelArray");
	__xamarin_class_map [545].handle = objc_getClass ("MPSKernel");
	__xamarin_class_map [546].handle = objc_getClass ("MPSBinaryImageKernel");
	__xamarin_class_map [547].handle = objc_getClass ("MPSCNNKernel");
	__xamarin_class_map [548].handle = objc_getClass ("MPSCNNBinaryConvolution");
	__xamarin_class_map [549].handle = objc_getClass ("MPSNNFilterNode");
	__xamarin_class_map [550].handle = objc_getClass ("MPSCNNConvolutionNode");
	__xamarin_class_map [551].handle = objc_getClass ("MPSCNNBinaryConvolutionNode");
	__xamarin_class_map [552].handle = objc_getClass ("MPSCNNBinaryFullyConnected");
	__xamarin_class_map [553].handle = objc_getClass ("MPSCNNBinaryFullyConnectedNode");
	__xamarin_class_map [554].handle = objc_getClass ("MPSCNNBinaryKernel");
	__xamarin_class_map [555].handle = objc_getClass ("MPSCNNConvolution");
	__xamarin_class_map [556].handle = objc_getClass ("MPSCNNConvolutionDataSource");
	__xamarin_class_map [557].handle = objc_getClass ("MPSCNNConvolutionDescriptor");
	__xamarin_class_map [558].handle = objc_getClass ("MPSState");
	__xamarin_class_map [559].handle = objc_getClass ("MPSCNNConvolutionState");
	__xamarin_class_map [560].handle = objc_getClass ("MPSNNStateNode");
	__xamarin_class_map [561].handle = objc_getClass ("MPSCNNConvolutionStateNode");
	__xamarin_class_map [562].handle = objc_getClass ("MPSCNNConvolutionTranspose");
	__xamarin_class_map [563].handle = objc_getClass ("MPSCNNConvolutionTransposeNode");
	__xamarin_class_map [564].handle = objc_getClass ("MPSCNNCrossChannelNormalization");
	__xamarin_class_map [565].handle = objc_getClass ("MPSCNNNormalizationNode");
	__xamarin_class_map [566].handle = objc_getClass ("MPSCNNCrossChannelNormalizationNode");
	__xamarin_class_map [567].handle = objc_getClass ("MPSCNNDepthWiseConvolutionDescriptor");
	__xamarin_class_map [568].handle = objc_getClass ("MPSCNNPooling");
	__xamarin_class_map [569].handle = objc_getClass ("MPSCNNDilatedPoolingMax");
	__xamarin_class_map [570].handle = objc_getClass ("MPSCNNDilatedPoolingMaxNode");
	__xamarin_class_map [571].handle = objc_getClass ("MPSCNNFullyConnected");
	__xamarin_class_map [572].handle = objc_getClass ("MPSCNNFullyConnectedNode");
	__xamarin_class_map [573].handle = objc_getClass ("MPSCNNLocalContrastNormalization");
	__xamarin_class_map [574].handle = objc_getClass ("MPSCNNLocalContrastNormalizationNode");
	__xamarin_class_map [575].handle = objc_getClass ("MPSCNNLogSoftMax");
	__xamarin_class_map [576].handle = objc_getClass ("MPSCNNLogSoftMaxNode");
	__xamarin_class_map [577].handle = objc_getClass ("MPSCNNNeuron");
	__xamarin_class_map [578].handle = objc_getClass ("MPSCNNNeuronAbsolute");
	__xamarin_class_map [579].handle = objc_getClass ("MPSCNNNeuronNode");
	__xamarin_class_map [580].handle = objc_getClass ("MPSCNNNeuronAbsoluteNode");
	__xamarin_class_map [581].handle = objc_getClass ("MPSCNNNeuronELU");
	__xamarin_class_map [582].handle = objc_getClass ("MPSCNNNeuronELUNode");
	__xamarin_class_map [583].handle = objc_getClass ("MPSCNNNeuronHardSigmoid");
	__xamarin_class_map [584].handle = objc_getClass ("MPSCNNNeuronHardSigmoidNode");
	__xamarin_class_map [585].handle = objc_getClass ("MPSCNNNeuronLinear");
	__xamarin_class_map [586].handle = objc_getClass ("MPSCNNNeuronLinearNode");
	__xamarin_class_map [587].handle = objc_getClass ("MPSCNNNeuronPReLU");
	__xamarin_class_map [588].handle = objc_getClass ("MPSCNNNeuronPReLUNode");
	__xamarin_class_map [589].handle = objc_getClass ("MPSCNNNeuronReLU");
	__xamarin_class_map [590].handle = objc_getClass ("MPSCNNNeuronReLUN");
	__xamarin_class_map [591].handle = objc_getClass ("MPSCNNNeuronReLUNNode");
	__xamarin_class_map [592].handle = objc_getClass ("MPSCNNNeuronReLUNode");
	__xamarin_class_map [593].handle = objc_getClass ("MPSCNNNeuronSigmoid");
	__xamarin_class_map [594].handle = objc_getClass ("MPSCNNNeuronSigmoidNode");
	__xamarin_class_map [595].handle = objc_getClass ("MPSCNNNeuronSoftPlus");
	__xamarin_class_map [596].handle = objc_getClass ("MPSCNNNeuronSoftPlusNode");
	__xamarin_class_map [597].handle = objc_getClass ("MPSCNNNeuronSoftSign");
	__xamarin_class_map [598].handle = objc_getClass ("MPSCNNNeuronSoftSignNode");
	__xamarin_class_map [599].handle = objc_getClass ("MPSCNNNeuronTanH");
	__xamarin_class_map [600].handle = objc_getClass ("MPSCNNNeuronTanHNode");
	__xamarin_class_map [601].handle = objc_getClass ("MPSCNNPoolingAverage");
	__xamarin_class_map [602].handle = objc_getClass ("MPSCNNPoolingNode");
	__xamarin_class_map [603].handle = objc_getClass ("MPSCNNPoolingAverageNode");
	__xamarin_class_map [604].handle = objc_getClass ("MPSCNNPoolingL2Norm");
	__xamarin_class_map [605].handle = objc_getClass ("MPSCNNPoolingL2NormNode");
	__xamarin_class_map [606].handle = objc_getClass ("MPSCNNPoolingMax");
	__xamarin_class_map [607].handle = objc_getClass ("MPSCNNPoolingMaxNode");
	__xamarin_class_map [608].handle = objc_getClass ("MPSCNNSoftMax");
	__xamarin_class_map [609].handle = objc_getClass ("MPSCNNSoftMaxNode");
	__xamarin_class_map [610].handle = objc_getClass ("MPSCNNSpatialNormalization");
	__xamarin_class_map [611].handle = objc_getClass ("MPSCNNSpatialNormalizationNode");
	__xamarin_class_map [612].handle = objc_getClass ("MPSCNNSubPixelConvolutionDescriptor");
	__xamarin_class_map [613].handle = objc_getClass ("MPSCNNUpsampling");
	__xamarin_class_map [614].handle = objc_getClass ("MPSCNNUpsamplingBilinear");
	__xamarin_class_map [615].handle = objc_getClass ("MPSCNNUpsamplingBilinearNode");
	__xamarin_class_map [616].handle = objc_getClass ("MPSCNNUpsamplingNearest");
	__xamarin_class_map [617].handle = objc_getClass ("MPSCNNUpsamplingNearestNode");
	__xamarin_class_map [618].handle = objc_getClass ("MPSRNNDescriptor");
	__xamarin_class_map [619].handle = objc_getClass ("MPSGRUDescriptor");
	__xamarin_class_map [620].handle = objc_getClass ("MPSImage");
	__xamarin_class_map [621].handle = objc_getClass ("MPSImageArithmetic");
	__xamarin_class_map [622].handle = objc_getClass ("MPSImageAdd");
	__xamarin_class_map [623].handle = objc_getClass ("MPSUnaryImageKernel");
	__xamarin_class_map [624].handle = objc_getClass ("MPSImageAreaMax");
	__xamarin_class_map [625].handle = objc_getClass ("MPSImageAreaMin");
	__xamarin_class_map [626].handle = objc_getClass ("MPSImageScale");
	__xamarin_class_map [627].handle = objc_getClass ("MPSImageBilinearScale");
	__xamarin_class_map [628].handle = objc_getClass ("MPSImageBox");
	__xamarin_class_map [629].handle = objc_getClass ("MPSImageConversion");
	__xamarin_class_map [630].handle = objc_getClass ("MPSImageConvolution");
	__xamarin_class_map [631].handle = objc_getClass ("MPSImageCopyToMatrix");
	__xamarin_class_map [632].handle = objc_getClass ("MPSImageDescriptor");
	__xamarin_class_map [633].handle = objc_getClass ("MPSImageDilate");
	__xamarin_class_map [634].handle = objc_getClass ("MPSImageDivide");
	__xamarin_class_map [635].handle = objc_getClass ("MPSImageErode");
	__xamarin_class_map [636].handle = objc_getClass ("MPSImageFindKeypoints");
	__xamarin_class_map [637].handle = objc_getClass ("MPSImageGaussianBlur");
	__xamarin_class_map [638].handle = objc_getClass ("MPSImagePyramid");
	__xamarin_class_map [639].handle = objc_getClass ("MPSImageGaussianPyramid");
	__xamarin_class_map [640].handle = objc_getClass ("MPSImageHistogram");
	__xamarin_class_map [641].handle = objc_getClass ("MPSImageHistogramEqualization");
	__xamarin_class_map [642].handle = objc_getClass ("MPSImageHistogramSpecification");
	__xamarin_class_map [643].handle = objc_getClass ("MPSImageIntegral");
	__xamarin_class_map [644].handle = objc_getClass ("MPSImageIntegralOfSquares");
	__xamarin_class_map [645].handle = objc_getClass ("MPSImageLanczosScale");
	__xamarin_class_map [646].handle = objc_getClass ("MPSImageLaplacian");
	__xamarin_class_map [647].handle = objc_getClass ("MPSImageMedian");
	__xamarin_class_map [648].handle = objc_getClass ("MPSImageMultiply");
	__xamarin_class_map [649].handle = objc_getClass ("MPSImageSobel");
	__xamarin_class_map [650].handle = objc_getClass ("MPSImageStatisticsMean");
	__xamarin_class_map [651].handle = objc_getClass ("MPSImageStatisticsMeanAndVariance");
	__xamarin_class_map [652].handle = objc_getClass ("MPSImageStatisticsMinAndMax");
	__xamarin_class_map [653].handle = objc_getClass ("MPSImageSubtract");
	__xamarin_class_map [654].handle = objc_getClass ("MPSImageTent");
	__xamarin_class_map [655].handle = objc_getClass ("MPSImageThresholdBinary");
	__xamarin_class_map [656].handle = objc_getClass ("MPSImageThresholdBinaryInverse");
	__xamarin_class_map [657].handle = objc_getClass ("MPSImageThresholdToZero");
	__xamarin_class_map [658].handle = objc_getClass ("MPSImageThresholdToZeroInverse");
	__xamarin_class_map [659].handle = objc_getClass ("MPSImageThresholdTruncate");
	__xamarin_class_map [660].handle = objc_getClass ("MPSImageTranspose");
	__xamarin_class_map [661].handle = objc_getClass ("MPSLSTMDescriptor");
	__xamarin_class_map [662].handle = objc_getClass ("MPSMatrix");
	__xamarin_class_map [663].handle = objc_getClass ("MPSMatrixBinaryKernel");
	__xamarin_class_map [664].handle = objc_getClass ("MPSMatrixCopy");
	__xamarin_class_map [665].handle = objc_getClass ("MPSMatrixCopyDescriptor");
	__xamarin_class_map [666].handle = objc_getClass ("MPSMatrixUnaryKernel");
	__xamarin_class_map [667].handle = objc_getClass ("MPSMatrixDecompositionCholesky");
	__xamarin_class_map [668].handle = objc_getClass ("MPSMatrixDecompositionLU");
	__xamarin_class_map [669].handle = objc_getClass ("MPSMatrixDescriptor");
	__xamarin_class_map [670].handle = objc_getClass ("MPSMatrixFindTopK");
	__xamarin_class_map [671].handle = objc_getClass ("MPSMatrixFullyConnected");
	__xamarin_class_map [672].handle = objc_getClass ("MPSMatrixSoftMax");
	__xamarin_class_map [673].handle = objc_getClass ("MPSMatrixLogSoftMax");
	__xamarin_class_map [674].handle = objc_getClass ("MPSMatrixMultiplication");
	__xamarin_class_map [675].handle = objc_getClass ("MPSMatrixNeuron");
	__xamarin_class_map [676].handle = objc_getClass ("MPSMatrixSolveCholesky");
	__xamarin_class_map [677].handle = objc_getClass ("MPSMatrixSolveLU");
	__xamarin_class_map [678].handle = objc_getClass ("MPSMatrixSolveTriangular");
	__xamarin_class_map [679].handle = objc_getClass ("MPSMatrixSum");
	__xamarin_class_map [680].handle = objc_getClass ("MPSMatrixVectorMultiplication");
	__xamarin_class_map [681].handle = objc_getClass ("MPSNNBinaryArithmeticNode");
	__xamarin_class_map [682].handle = objc_getClass ("MPSNNAdditionNode");
	__xamarin_class_map [683].handle = objc_getClass ("MPSNNScaleNode");
	__xamarin_class_map [684].handle = objc_getClass ("MPSNNBilinearScaleNode");
	__xamarin_class_map [685].handle = objc_getClass ("MPSNNConcatenationNode");
	__xamarin_class_map [686].handle = objc_getClass ("MPSNNDefaultPadding");
	__xamarin_class_map [687].handle = objc_getClass ("MPSNNDivisionNode");
	__xamarin_class_map [688].handle = objc_getClass ("MPSNNImageNode");
	__xamarin_class_map [689].handle = objc_getClass ("MPSNNLanczosScaleNode");
	__xamarin_class_map [690].handle = objc_getClass ("MPSNNMultiplicationNode");
	__xamarin_class_map [691].handle = objc_getClass ("MPSNNSubtractionNode");
	__xamarin_class_map [692].handle = objc_getClass ("MPSRNNImageInferenceLayer");
	__xamarin_class_map [693].handle = objc_getClass ("MPSRNNMatrixInferenceLayer");
	__xamarin_class_map [694].handle = objc_getClass ("MPSRNNRecurrentImageState");
	__xamarin_class_map [695].handle = objc_getClass ("MPSRNNRecurrentMatrixState");
	__xamarin_class_map [696].handle = objc_getClass ("MPSRNNSingleGateDescriptor");
	__xamarin_class_map [697].handle = objc_getClass ("MPSTemporaryImage");
	__xamarin_class_map [698].handle = objc_getClass ("MPSTemporaryMatrix");
	__xamarin_class_map [699].handle = objc_getClass ("MPSVector");
	__xamarin_class_map [700].handle = objc_getClass ("MPSTemporaryVector");
	__xamarin_class_map [701].handle = objc_getClass ("MPSVectorDescriptor");
	__xamarin_class_map [702].handle = objc_getClass ("MTKMesh");
	__xamarin_class_map [703].handle = objc_getClass ("MTKMeshBuffer");
	__xamarin_class_map [704].handle = objc_getClass ("MTKMeshBufferAllocator");
	__xamarin_class_map [705].handle = objc_getClass ("MTKSubmesh");
	__xamarin_class_map [706].handle = objc_getClass ("MTKView");
	__xamarin_class_map [707].handle = objc_getClass ("MTKViewDelegate");
	__xamarin_class_map [708].handle = objc_getClass ("MTLArgument");
	__xamarin_class_map [709].handle = objc_getClass ("MTLArgumentDescriptor");
	__xamarin_class_map [710].handle = objc_getClass ("MTLType");
	__xamarin_class_map [711].handle = objc_getClass ("MTLArrayType");
	__xamarin_class_map [712].handle = objc_getClass ("MTLAttribute");
	__xamarin_class_map [713].handle = objc_getClass ("MTLAttributeDescriptor");
	__xamarin_class_map [714].handle = objc_getClass ("MTLAttributeDescriptorArray");
	__xamarin_class_map [715].handle = objc_getClass ("MTLBufferLayoutDescriptor");
	__xamarin_class_map [716].handle = objc_getClass ("MTLBufferLayoutDescriptorArray");
	__xamarin_class_map [717].handle = objc_getClass ("MTLCaptureManager");
	__xamarin_class_map [718].handle = objc_getClass ("Xamarin_Mac__Metal_MTLCaptureScope");
	__xamarin_class_map [719].handle = objc_getClass ("MTLCompileOptions");
	__xamarin_class_map [720].handle = objc_getClass ("MTLComputePipelineDescriptor");
	__xamarin_class_map [721].handle = objc_getClass ("MTLComputePipelineReflection");
	__xamarin_class_map [722].handle = objc_getClass ("MTLDepthStencilDescriptor");
	__xamarin_class_map [723].handle = objc_getClass ("MTLDrawable");
	__xamarin_class_map [724].handle = objc_getClass ("MTLFunctionConstant");
	__xamarin_class_map [725].handle = objc_getClass ("MTLFunctionConstantValues");
	__xamarin_class_map [726].handle = objc_getClass ("MTLHeapDescriptor");
	__xamarin_class_map [727].handle = objc_getClass ("MTLIndirectCommandBufferDescriptor");
	__xamarin_class_map [728].handle = objc_getClass ("MTLPipelineBufferDescriptor");
	__xamarin_class_map [729].handle = objc_getClass ("MTLPipelineBufferDescriptorArray");
	__xamarin_class_map [730].handle = objc_getClass ("MTLPointerType");
	__xamarin_class_map [731].handle = objc_getClass ("MTLRenderPassAttachmentDescriptor");
	__xamarin_class_map [732].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptor");
	__xamarin_class_map [733].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptorArray");
	__xamarin_class_map [734].handle = objc_getClass ("MTLRenderPassDepthAttachmentDescriptor");
	__xamarin_class_map [735].handle = objc_getClass ("MTLRenderPassDescriptor");
	__xamarin_class_map [736].handle = objc_getClass ("MTLRenderPassStencilAttachmentDescriptor");
	__xamarin_class_map [737].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptor");
	__xamarin_class_map [738].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptorArray");
	__xamarin_class_map [739].handle = objc_getClass ("MTLRenderPipelineDescriptor");
	__xamarin_class_map [740].handle = objc_getClass ("MTLRenderPipelineReflection");
	__xamarin_class_map [741].handle = objc_getClass ("MTLSamplerDescriptor");
	__xamarin_class_map [742].handle = objc_getClass ("MTLSharedEventHandle");
	__xamarin_class_map [743].handle = objc_getClass ("MTLSharedEventListener");
	__xamarin_class_map [744].handle = objc_getClass ("MTLSharedTextureHandle");
	__xamarin_class_map [745].handle = objc_getClass ("MTLStageInputOutputDescriptor");
	__xamarin_class_map [746].handle = objc_getClass ("MTLStencilDescriptor");
	__xamarin_class_map [747].handle = objc_getClass ("MTLStructMember");
	__xamarin_class_map [748].handle = objc_getClass ("MTLStructType");
	__xamarin_class_map [749].handle = objc_getClass ("MTLTextureDescriptor");
	__xamarin_class_map [750].handle = objc_getClass ("MTLTextureReferenceType");
	__xamarin_class_map [751].handle = objc_getClass ("MTLVertexAttribute");
	__xamarin_class_map [752].handle = objc_getClass ("MTLVertexAttributeDescriptor");
	__xamarin_class_map [753].handle = objc_getClass ("MTLVertexAttributeDescriptorArray");
	__xamarin_class_map [754].handle = objc_getClass ("MTLVertexBufferLayoutDescriptor");
	__xamarin_class_map [755].handle = objc_getClass ("MTLVertexBufferLayoutDescriptorArray");
	__xamarin_class_map [756].handle = objc_getClass ("MTLVertexDescriptor");
	__xamarin_class_map [757].handle = objc_getClass ("MPRemoteCommandEvent");
	__xamarin_class_map [758].handle = objc_getClass ("MPChangeLanguageOptionCommandEvent");
	__xamarin_class_map [759].handle = objc_getClass ("MPRemoteCommand");
	__xamarin_class_map [760].handle = objc_getClass ("MPChangePlaybackPositionCommand");
	__xamarin_class_map [761].handle = objc_getClass ("MPChangePlaybackPositionCommandEvent");
	__xamarin_class_map [762].handle = objc_getClass ("MPChangePlaybackRateCommand");
	__xamarin_class_map [763].handle = objc_getClass ("MPChangePlaybackRateCommandEvent");
	__xamarin_class_map [764].handle = objc_getClass ("MPChangeRepeatModeCommand");
	__xamarin_class_map [765].handle = objc_getClass ("MPChangeRepeatModeCommandEvent");
	__xamarin_class_map [766].handle = objc_getClass ("MPChangeShuffleModeCommand");
	__xamarin_class_map [767].handle = objc_getClass ("MPChangeShuffleModeCommandEvent");
	__xamarin_class_map [768].handle = objc_getClass ("MPContentItem");
	__xamarin_class_map [769].handle = objc_getClass ("MPFeedbackCommand");
	__xamarin_class_map [770].handle = objc_getClass ("MPFeedbackCommandEvent");
	__xamarin_class_map [771].handle = objc_getClass ("MPMediaItem");
	__xamarin_class_map [772].handle = objc_getClass ("MPMediaItemArtwork");
	__xamarin_class_map [773].handle = objc_getClass ("MPNowPlayingInfoCenter");
	__xamarin_class_map [774].handle = objc_getClass ("MPNowPlayingInfoLanguageOption");
	__xamarin_class_map [775].handle = objc_getClass ("MPNowPlayingInfoLanguageOptionGroup");
	__xamarin_class_map [776].handle = objc_getClass ("MPRatingCommand");
	__xamarin_class_map [777].handle = objc_getClass ("MPRatingCommandEvent");
	__xamarin_class_map [778].handle = objc_getClass ("MPRemoteCommandCenter");
	__xamarin_class_map [779].handle = objc_getClass ("MPSeekCommandEvent");
	__xamarin_class_map [780].handle = objc_getClass ("MPSkipIntervalCommandEvent");
	__xamarin_class_map [781].handle = objc_getClass ("MLMediaGroup");
	__xamarin_class_map [782].handle = objc_getClass ("MLMediaLibrary");
	__xamarin_class_map [783].handle = objc_getClass ("MLMediaObject");
	__xamarin_class_map [784].handle = objc_getClass ("MLMediaSource");
	__xamarin_class_map [785].handle = objc_getClass ("MKAnnotation");
	__xamarin_class_map [786].handle = objc_getClass ("MKAnnotationView");
	__xamarin_class_map [787].handle = objc_getClass ("MKShape");
	__xamarin_class_map [788].handle = objc_getClass ("MKCircle");
	__xamarin_class_map [789].handle = objc_getClass ("MKOverlayRenderer");
	__xamarin_class_map [790].handle = objc_getClass ("MKOverlayPathRenderer");
	__xamarin_class_map [791].handle = objc_getClass ("MKCircleRenderer");
	__xamarin_class_map [792].handle = objc_getClass ("MKClusterAnnotation");
	__xamarin_class_map [793].handle = objc_getClass ("MKDirectionsRequest");
	__xamarin_class_map [794].handle = objc_getClass ("MKDirectionsResponse");
	__xamarin_class_map [795].handle = objc_getClass ("NSFormatter");
	__xamarin_class_map [796].handle = objc_getClass ("MKDistanceFormatter");
	__xamarin_class_map [797].handle = objc_getClass ("MKETAResponse");
	__xamarin_class_map [798].handle = objc_getClass ("MKMultiPoint");
	__xamarin_class_map [799].handle = objc_getClass ("MKPolyline");
	__xamarin_class_map [800].handle = objc_getClass ("MKGeodesicPolyline");
	__xamarin_class_map [801].handle = objc_getClass ("MKLocalSearchCompleter");
	__xamarin_class_map [802].handle = objc_getClass ("MKLocalSearchCompleterDelegate");
	__xamarin_class_map [803].handle = objc_getClass ("MKLocalSearchCompletion");
	__xamarin_class_map [804].handle = objc_getClass ("MKLocalSearchRequest");
	__xamarin_class_map [805].handle = objc_getClass ("MKLocalSearchResponse");
	__xamarin_class_map [806].handle = objc_getClass ("MKMapCamera");
	__xamarin_class_map [807].handle = objc_getClass ("MKMapItem");
	__xamarin_class_map [808].handle = objc_getClass ("MKMapSnapshot");
	__xamarin_class_map [809].handle = objc_getClass ("MKMapSnapshotOptions");
	__xamarin_class_map [810].handle = objc_getClass ("MKMapViewDelegate");
	__xamarin_class_map [811].handle = objc_getClass ("MKOverlay");
	__xamarin_class_map [812].handle = objc_getClass ("MKPinAnnotationView");
	__xamarin_class_map [813].handle = objc_getClass ("CLPlacemark");
	__xamarin_class_map [814].handle = objc_getClass ("MKPlacemark");
	__xamarin_class_map [815].handle = objc_getClass ("MKPointAnnotation");
	__xamarin_class_map [816].handle = objc_getClass ("MKPolygon");
	__xamarin_class_map [817].handle = objc_getClass ("MKPolygonRenderer");
	__xamarin_class_map [818].handle = objc_getClass ("MKPolylineRenderer");
	__xamarin_class_map [819].handle = objc_getClass ("MKRoute");
	__xamarin_class_map [820].handle = objc_getClass ("MKRouteStep");
	__xamarin_class_map [821].handle = objc_getClass ("MKTileOverlay");
	__xamarin_class_map [822].handle = objc_getClass ("MKTileOverlayRenderer");
	__xamarin_class_map [823].handle = objc_getClass ("MKUserLocation");
	__xamarin_class_map [824].handle = objc_getClass ("JSContext");
	__xamarin_class_map [825].handle = objc_getClass ("Xamarin_Mac__JavaScriptCore_JSExport");
	__xamarin_class_map [826].handle = objc_getClass ("JSManagedValue");
	__xamarin_class_map [827].handle = objc_getClass ("JSValue");
	__xamarin_class_map [828].handle = objc_getClass ("JSVirtualMachine");
	__xamarin_class_map [829].handle = objc_getClass ("ITLibAlbum");
	__xamarin_class_map [830].handle = objc_getClass ("ITLibArtist");
	__xamarin_class_map [831].handle = objc_getClass ("ITLibArtwork");
	__xamarin_class_map [832].handle = objc_getClass ("ITLibMediaEntity");
	__xamarin_class_map [833].handle = objc_getClass ("ITLibMediaItem");
	__xamarin_class_map [834].handle = objc_getClass ("ITLibMediaItemVideoInfo");
	__xamarin_class_map [835].handle = objc_getClass ("ITLibPlaylist");
	__xamarin_class_map [836].handle = objc_getClass ("ITLibrary");
	__xamarin_class_map [837].handle = objc_getClass ("IOSurface");
	__xamarin_class_map [838].handle = objc_getClass ("INIntentResolutionResult");
	__xamarin_class_map [839].handle = objc_getClass ("INCallDestinationTypeResolutionResult");
	__xamarin_class_map [840].handle = objc_getClass ("INCallRecord");
	__xamarin_class_map [841].handle = objc_getClass ("INCallRecordTypeOptionsResolutionResult");
	__xamarin_class_map [842].handle = objc_getClass ("INCallRecordTypeResolutionResult");
	__xamarin_class_map [843].handle = objc_getClass ("INDateComponentsRange");
	__xamarin_class_map [844].handle = objc_getClass ("INDateComponentsRangeResolutionResult");
	__xamarin_class_map [845].handle = objc_getClass ("INImage");
	__xamarin_class_map [846].handle = objc_getClass ("INIntent");
	__xamarin_class_map [847].handle = objc_getClass ("INIntentResponse");
	__xamarin_class_map [848].handle = objc_getClass ("INMessage");
	__xamarin_class_map [849].handle = objc_getClass ("INMessageAttributeOptionsResolutionResult");
	__xamarin_class_map [850].handle = objc_getClass ("INMessageAttributeResolutionResult");
	__xamarin_class_map [851].handle = objc_getClass ("INParameter");
	__xamarin_class_map [852].handle = objc_getClass ("INPerson");
	__xamarin_class_map [853].handle = objc_getClass ("INPersonHandle");
	__xamarin_class_map [854].handle = objc_getClass ("INPersonResolutionResult");
	__xamarin_class_map [855].handle = objc_getClass ("INPlacemarkResolutionResult");
	__xamarin_class_map [856].handle = objc_getClass ("INRecurrenceRule");
	__xamarin_class_map [857].handle = objc_getClass ("INSearchCallHistoryIntent");
	__xamarin_class_map [858].handle = objc_getClass ("INSearchCallHistoryIntentResponse");
	__xamarin_class_map [859].handle = objc_getClass ("INSearchForMessagesIntent");
	__xamarin_class_map [860].handle = objc_getClass ("INSearchForMessagesIntentResponse");
	__xamarin_class_map [861].handle = objc_getClass ("INSendMessageIntent");
	__xamarin_class_map [862].handle = objc_getClass ("INSendMessageIntentResponse");
	__xamarin_class_map [863].handle = objc_getClass ("INSendMessageRecipientResolutionResult");
	__xamarin_class_map [864].handle = objc_getClass ("INSpeakableString");
	__xamarin_class_map [865].handle = objc_getClass ("INSpeakableStringResolutionResult");
	__xamarin_class_map [866].handle = objc_getClass ("INStartAudioCallIntent");
	__xamarin_class_map [867].handle = objc_getClass ("INStartAudioCallIntentResponse");
	__xamarin_class_map [868].handle = objc_getClass ("INStartVideoCallIntent");
	__xamarin_class_map [869].handle = objc_getClass ("INStartVideoCallIntentResponse");
	__xamarin_class_map [870].handle = objc_getClass ("INStringResolutionResult");
	__xamarin_class_map [871].handle = objc_getClass ("IKCameraDeviceViewDelegate");
	__xamarin_class_map [872].handle = objc_getClass ("IKDeviceBrowserViewDelegate");
	__xamarin_class_map [873].handle = objc_getClass ("IKFilterBrowserView");
	__xamarin_class_map [874].handle = objc_getClass ("IKFilterCustomUIProvider");
	__xamarin_class_map [875].handle = objc_getClass ("IKFilterUIView");
	__xamarin_class_map [876].handle = objc_getClass ("IKImageBrowserCell");
	__xamarin_class_map [877].handle = objc_getClass ("IKImageBrowserDataSource");
	__xamarin_class_map [878].handle = objc_getClass ("IKImageBrowserDelegate");
	__xamarin_class_map [879].handle = objc_getClass ("IKImageBrowserItem");
	__xamarin_class_map [880].handle = objc_getClass ("IKImageEditPanel");
	__xamarin_class_map [881].handle = objc_getClass ("IKImageEditPanelDataSource");
	__xamarin_class_map [882].handle = objc_getClass ("IKImageView");
	__xamarin_class_map [883].handle = objc_getClass ("IKPictureTaker");
	__xamarin_class_map [884].handle = objc_getClass ("IKSaveOptionsDelegate");
	__xamarin_class_map [885].handle = objc_getClass ("IKScannerDeviceViewDelegate");
	__xamarin_class_map [886].handle = objc_getClass ("IKSlideshow");
	__xamarin_class_map [887].handle = objc_getClass ("IKSlideshowDataSource");
	__xamarin_class_map [888].handle = objc_getClass ("GLKBaseEffect");
	__xamarin_class_map [889].handle = objc_getClass ("GLKEffectProperty");
	__xamarin_class_map [890].handle = objc_getClass ("GLKEffectPropertyFog");
	__xamarin_class_map [891].handle = objc_getClass ("GLKEffectPropertyLight");
	__xamarin_class_map [892].handle = objc_getClass ("GLKEffectPropertyMaterial");
	__xamarin_class_map [893].handle = objc_getClass ("GLKEffectPropertyTexture");
	__xamarin_class_map [894].handle = objc_getClass ("GLKEffectPropertyTransform");
	__xamarin_class_map [895].handle = objc_getClass ("GLKMesh");
	__xamarin_class_map [896].handle = objc_getClass ("GLKMeshBuffer");
	__xamarin_class_map [897].handle = objc_getClass ("GLKMeshBufferAllocator");
	__xamarin_class_map [898].handle = objc_getClass ("GLKNamedEffect");
	__xamarin_class_map [899].handle = objc_getClass ("GLKReflectionMapEffect");
	__xamarin_class_map [900].handle = objc_getClass ("GLKSkyboxEffect");
	__xamarin_class_map [901].handle = objc_getClass ("GLKSubmesh");
	__xamarin_class_map [902].handle = objc_getClass ("GLKTextureInfo");
	__xamarin_class_map [903].handle = objc_getClass ("GKComponent");
	__xamarin_class_map [904].handle = objc_getClass ("GKAgent");
	__xamarin_class_map [905].handle = objc_getClass ("GKAgent2D");
	__xamarin_class_map [906].handle = objc_getClass ("GKAgent3D");
	__xamarin_class_map [907].handle = objc_getClass ("GKAgentDelegate");
	__xamarin_class_map [908].handle = objc_getClass ("GKRandomSource");
	__xamarin_class_map [909].handle = objc_getClass ("GKARC4RandomSource");
	__xamarin_class_map [910].handle = objc_getClass ("GKBehavior");
	__xamarin_class_map [911].handle = objc_getClass ("GKNoiseSource");
	__xamarin_class_map [912].handle = objc_getClass ("GKCoherentNoiseSource");
	__xamarin_class_map [913].handle = objc_getClass ("GKBillowNoiseSource");
	__xamarin_class_map [914].handle = objc_getClass ("GKCheckerboardNoiseSource");
	__xamarin_class_map [915].handle = objc_getClass ("GKObstacle");
	__xamarin_class_map [916].handle = objc_getClass ("GKCircleObstacle");
	__xamarin_class_map [917].handle = objc_getClass ("GKComponentSystem");
	__xamarin_class_map [918].handle = objc_getClass ("GKCompositeBehavior");
	__xamarin_class_map [919].handle = objc_getClass ("GKConstantNoiseSource");
	__xamarin_class_map [920].handle = objc_getClass ("GKCylindersNoiseSource");
	__xamarin_class_map [921].handle = objc_getClass ("GKDecisionNode");
	__xamarin_class_map [922].handle = objc_getClass ("GKDecisionTree");
	__xamarin_class_map [923].handle = objc_getClass ("GKEntity");
	__xamarin_class_map [924].handle = objc_getClass ("GKRandomDistribution");
	__xamarin_class_map [925].handle = objc_getClass ("GKGaussianDistribution");
	__xamarin_class_map [926].handle = objc_getClass ("GKGoal");
	__xamarin_class_map [927].handle = objc_getClass ("GKGraph");
	__xamarin_class_map [928].handle = objc_getClass ("GKGraphNode");
	__xamarin_class_map [929].handle = objc_getClass ("GKGraphNode2D");
	__xamarin_class_map [930].handle = objc_getClass ("GKGraphNode3D");
	__xamarin_class_map [931].handle = objc_getClass ("GKGridGraph");
	__xamarin_class_map [932].handle = objc_getClass ("GKGridGraphNode");
	__xamarin_class_map [933].handle = objc_getClass ("GKLinearCongruentialRandomSource");
	__xamarin_class_map [934].handle = objc_getClass ("GKMersenneTwisterRandomSource");
	__xamarin_class_map [935].handle = objc_getClass ("GKMeshGraph");
	__xamarin_class_map [936].handle = objc_getClass ("GKMinmaxStrategist");
	__xamarin_class_map [937].handle = objc_getClass ("GKMonteCarloStrategist");
	__xamarin_class_map [938].handle = objc_getClass ("GKNoise");
	__xamarin_class_map [939].handle = objc_getClass ("GKNoiseMap");
	__xamarin_class_map [940].handle = objc_getClass ("GKRule");
	__xamarin_class_map [941].handle = objc_getClass ("GKNSPredicateRule");
	__xamarin_class_map [942].handle = objc_getClass ("GKObstacleGraph");
	__xamarin_class_map [943].handle = objc_getClass ("GKOctree");
	__xamarin_class_map [944].handle = objc_getClass ("GKOctreeNode");
	__xamarin_class_map [945].handle = objc_getClass ("GKPath");
	__xamarin_class_map [946].handle = objc_getClass ("GKPerlinNoiseSource");
	__xamarin_class_map [947].handle = objc_getClass ("GKPolygonObstacle");
	__xamarin_class_map [948].handle = objc_getClass ("GKQuadtree");
	__xamarin_class_map [949].handle = objc_getClass ("GKQuadtreeNode");
	__xamarin_class_map [950].handle = objc_getClass ("GKRidgedNoiseSource");
	__xamarin_class_map [951].handle = objc_getClass ("GKRTree");
	__xamarin_class_map [952].handle = objc_getClass ("GKRuleSystem");
	__xamarin_class_map [953].handle = objc_getClass ("GKScene");
	__xamarin_class_map [954].handle = objc_getClass ("GKSCNNodeComponent");
	__xamarin_class_map [955].handle = objc_getClass ("GKShuffledDistribution");
	__xamarin_class_map [956].handle = objc_getClass ("GKSKNodeComponent");
	__xamarin_class_map [957].handle = objc_getClass ("GKSphereObstacle");
	__xamarin_class_map [958].handle = objc_getClass ("GKSpheresNoiseSource");
	__xamarin_class_map [959].handle = objc_getClass ("GKState");
	__xamarin_class_map [960].handle = objc_getClass ("GKStateMachine");
	__xamarin_class_map [961].handle = objc_getClass ("GKVoronoiNoiseSource");
	__xamarin_class_map [962].handle = objc_getClass ("GKChallenge");
	__xamarin_class_map [963].handle = objc_getClass ("GKAchievementChallenge");
	__xamarin_class_map [964].handle = objc_getClass ("GKAchievementViewControllerDelegate");
	__xamarin_class_map [965].handle = objc_getClass ("GKBasePlayer");
	__xamarin_class_map [966].handle = objc_getClass ("GKChallengeEventHandlerDelegate");
	__xamarin_class_map [967].handle = objc_getClass ("GKChallengeListener");
	__xamarin_class_map [968].handle = objc_getClass ("GKChallengesViewController");
	__xamarin_class_map [969].handle = objc_getClass ("GKChallengesViewControllerDelegate");
	__xamarin_class_map [970].handle = objc_getClass ("GKCloudPlayer");
	__xamarin_class_map [971].handle = objc_getClass ("GKDialogController");
	__xamarin_class_map [972].handle = objc_getClass ("GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [973].handle = objc_getClass ("GKGameCenterControllerDelegate");
	__xamarin_class_map [974].handle = objc_getClass ("GKInvite");
	__xamarin_class_map [975].handle = objc_getClass ("GKInviteEventListener");
	__xamarin_class_map [976].handle = objc_getClass ("GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [977].handle = objc_getClass ("GKLocalPlayerListener");
	__xamarin_class_map [978].handle = objc_getClass ("GKMatchDelegate");
	__xamarin_class_map [979].handle = objc_getClass ("GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [980].handle = objc_getClass ("GKMatchRequest");
	__xamarin_class_map [981].handle = objc_getClass ("GKSavedGameListener");
	__xamarin_class_map [982].handle = objc_getClass ("GKScoreChallenge");
	__xamarin_class_map [983].handle = objc_getClass ("GKSession");
	__xamarin_class_map [984].handle = objc_getClass ("GKSessionDelegate");
	__xamarin_class_map [985].handle = objc_getClass ("GKTurnBasedEventHandler");
	__xamarin_class_map [986].handle = objc_getClass ("GKTurnBasedEventHandlerDelegate");
	__xamarin_class_map [987].handle = objc_getClass ("GKTurnBasedEventListener");
	__xamarin_class_map [988].handle = objc_getClass ("GKTurnBasedExchangeReply");
	__xamarin_class_map [989].handle = objc_getClass ("GKTurnBasedMatchmakerViewController");
	__xamarin_class_map [990].handle = objc_getClass ("GKTurnBasedMatchmakerViewControllerDelegate");
	__xamarin_class_map [991].handle = objc_getClass ("GKTurnBasedParticipant");
	__xamarin_class_map [992].handle = objc_getClass ("GKVoiceChat");
	__xamarin_class_map [993].handle = objc_getClass ("GCControllerElement");
	__xamarin_class_map [994].handle = objc_getClass ("GCControllerAxisInput");
	__xamarin_class_map [995].handle = objc_getClass ("GCControllerButtonInput");
	__xamarin_class_map [996].handle = objc_getClass ("GCControllerDirectionPad");
	__xamarin_class_map [997].handle = objc_getClass ("GCEventViewController");
	__xamarin_class_map [998].handle = objc_getClass ("GCExtendedGamepad");
	__xamarin_class_map [999].handle = objc_getClass ("GCExtendedGamepadSnapshot");
	__xamarin_class_map [1000].handle = objc_getClass ("GCGamepad");
	__xamarin_class_map [1001].handle = objc_getClass ("GCGamepadSnapshot");
	__xamarin_class_map [1002].handle = objc_getClass ("GCMicroGamepad");
	__xamarin_class_map [1003].handle = objc_getClass ("GCMicroGamepadSnapshot");
	__xamarin_class_map [1004].handle = objc_getClass ("GCMotion");
	__xamarin_class_map [1005].handle = objc_getClass ("EAAccessoryDelegate");
	__xamarin_class_map [1006].handle = objc_getClass ("EASession");
	__xamarin_class_map [1007].handle = objc_getClass ("EKObject");
	__xamarin_class_map [1008].handle = objc_getClass ("EKAlarm");
	__xamarin_class_map [1009].handle = objc_getClass ("EKCalendar");
	__xamarin_class_map [1010].handle = objc_getClass ("EKCalendarItem");
	__xamarin_class_map [1011].handle = objc_getClass ("EKEvent");
	__xamarin_class_map [1012].handle = objc_getClass ("EKParticipant");
	__xamarin_class_map [1013].handle = objc_getClass ("EKRecurrenceDayOfWeek");
	__xamarin_class_map [1014].handle = objc_getClass ("EKRecurrenceEnd");
	__xamarin_class_map [1015].handle = objc_getClass ("EKRecurrenceRule");
	__xamarin_class_map [1016].handle = objc_getClass ("EKReminder");
	__xamarin_class_map [1017].handle = objc_getClass ("EKSource");
	__xamarin_class_map [1018].handle = objc_getClass ("EKStructuredLocation");
	__xamarin_class_map [1019].handle = objc_getClass ("CW8021XProfile");
	__xamarin_class_map [1020].handle = objc_getClass ("CWChannel");
	__xamarin_class_map [1021].handle = objc_getClass ("CWConfiguration");
	__xamarin_class_map [1022].handle = objc_getClass ("CWEventDelegate");
	__xamarin_class_map [1023].handle = objc_getClass ("CWMutableConfiguration");
	__xamarin_class_map [1024].handle = objc_getClass ("CWNetworkProfile");
	__xamarin_class_map [1025].handle = objc_getClass ("CWMutableNetworkProfile");
	__xamarin_class_map [1026].handle = objc_getClass ("CWNetwork");
	__xamarin_class_map [1027].handle = objc_getClass ("CWWiFiClient");
	__xamarin_class_map [1028].handle = objc_getClass ("CWWirelessProfile");
	__xamarin_class_map [1029].handle = objc_getClass ("CSCustomAttributeKey");
	__xamarin_class_map [1030].handle = objc_getClass ("CSIndexExtensionRequestHandler");
	__xamarin_class_map [1031].handle = objc_getClass ("NSString");
	__xamarin_class_map [1032].handle = objc_getClass ("CSLocalizedString");
	__xamarin_class_map [1033].handle = objc_getClass ("CSPerson");
	__xamarin_class_map [1034].handle = objc_getClass ("CSSearchableIndexDelegate");
	__xamarin_class_map [1035].handle = objc_getClass ("CSSearchableItem");
	__xamarin_class_map [1036].handle = objc_getClass ("CSSearchableItemAttributeSet");
	__xamarin_class_map [1037].handle = objc_getClass ("CSSearchQuery");
	__xamarin_class_map [1038].handle = objc_getClass ("MLArrayBatchProvider");
	__xamarin_class_map [1039].handle = objc_getClass ("Xamarin_Mac__CoreML_MLCustomModel");
	__xamarin_class_map [1040].handle = objc_getClass ("MLDictionaryConstraint");
	__xamarin_class_map [1041].handle = objc_getClass ("MLDictionaryFeatureProvider");
	__xamarin_class_map [1042].handle = objc_getClass ("MLFeatureDescription");
	__xamarin_class_map [1043].handle = objc_getClass ("MLFeatureValue");
	__xamarin_class_map [1044].handle = objc_getClass ("MLImageConstraint");
	__xamarin_class_map [1045].handle = objc_getClass ("MLImageSize");
	__xamarin_class_map [1046].handle = objc_getClass ("MLImageSizeConstraint");
	__xamarin_class_map [1047].handle = objc_getClass ("MLModel");
	__xamarin_class_map [1048].handle = objc_getClass ("MLModelConfiguration");
	__xamarin_class_map [1049].handle = objc_getClass ("MLModelDescription");
	__xamarin_class_map [1050].handle = objc_getClass ("MLMultiArrayConstraint");
	__xamarin_class_map [1051].handle = objc_getClass ("MLMultiArrayShapeConstraint");
	__xamarin_class_map [1052].handle = objc_getClass ("MLPredictionOptions");
	__xamarin_class_map [1053].handle = objc_getClass ("MLSequence");
	__xamarin_class_map [1054].handle = objc_getClass ("MLSequenceConstraint");
	__xamarin_class_map [1055].handle = objc_getClass ("MIDICIProfile");
	__xamarin_class_map [1056].handle = objc_getClass ("MIDICIProfileState");
	__xamarin_class_map [1057].handle = objc_getClass ("MIDICISession");
	__xamarin_class_map [1058].handle = objc_getClass ("CLRegion");
	__xamarin_class_map [1059].handle = objc_getClass ("CLCircularRegion");
	__xamarin_class_map [1060].handle = objc_getClass ("CLHeading");
	__xamarin_class_map [1061].handle = objc_getClass ("CLLocation");
	__xamarin_class_map [1062].handle = objc_getClass ("CLLocationManagerDelegate");
	__xamarin_class_map [1063].handle = objc_getClass ("CIFilter");
	__xamarin_class_map [1064].handle = objc_getClass ("CoreImage_CIAccordionFoldTransition");
	__xamarin_class_map [1065].handle = objc_getClass ("CoreImage_CICompositingFilter");
	__xamarin_class_map [1066].handle = objc_getClass ("CoreImage_CIAdditionCompositing");
	__xamarin_class_map [1067].handle = objc_getClass ("CoreImage_CIAffineFilter");
	__xamarin_class_map [1068].handle = objc_getClass ("CoreImage_CIAffineClamp");
	__xamarin_class_map [1069].handle = objc_getClass ("CoreImage_CIAffineTile");
	__xamarin_class_map [1070].handle = objc_getClass ("CoreImage_CIAffineTransform");
	__xamarin_class_map [1071].handle = objc_getClass ("CoreImage_CIAreaAverage");
	__xamarin_class_map [1072].handle = objc_getClass ("CoreImage_CIAreaHistogram");
	__xamarin_class_map [1073].handle = objc_getClass ("CoreImage_CIReductionFilter");
	__xamarin_class_map [1074].handle = objc_getClass ("CoreImage_CIAreaMaximum");
	__xamarin_class_map [1075].handle = objc_getClass ("CoreImage_CIAreaMaximumAlpha");
	__xamarin_class_map [1076].handle = objc_getClass ("CoreImage_CIAreaMinimum");
	__xamarin_class_map [1077].handle = objc_getClass ("CoreImage_CIAreaMinimumAlpha");
	__xamarin_class_map [1078].handle = objc_getClass ("CoreImage_CIAreaMinMax");
	__xamarin_class_map [1079].handle = objc_getClass ("CoreImage_CIAreaMinMaxRed");
	__xamarin_class_map [1080].handle = objc_getClass ("CoreImage_CIImageGenerator");
	__xamarin_class_map [1081].handle = objc_getClass ("CoreImage_CIAttributedTextImageGenerator");
	__xamarin_class_map [1082].handle = objc_getClass ("CIBarcodeDescriptor");
	__xamarin_class_map [1083].handle = objc_getClass ("CIAztecCodeDescriptor");
	__xamarin_class_map [1084].handle = objc_getClass ("CoreImage_CICodeGenerator");
	__xamarin_class_map [1085].handle = objc_getClass ("CoreImage_CIAztecCodeGenerator");
	__xamarin_class_map [1086].handle = objc_getClass ("CoreImage_CIBarcodeGenerator");
	__xamarin_class_map [1087].handle = objc_getClass ("CoreImage_CITransitionFilter");
	__xamarin_class_map [1088].handle = objc_getClass ("CoreImage_CIBarsSwipeTransition");
	__xamarin_class_map [1089].handle = objc_getClass ("CoreImage_CIBicubicScaleTransform");
	__xamarin_class_map [1090].handle = objc_getClass ("CoreImage_CIBlendFilter");
	__xamarin_class_map [1091].handle = objc_getClass ("CIKernel");
	__xamarin_class_map [1092].handle = objc_getClass ("CIColorKernel");
	__xamarin_class_map [1093].handle = objc_getClass ("CIBlendKernel");
	__xamarin_class_map [1094].handle = objc_getClass ("CoreImage_CIBlendWithMask");
	__xamarin_class_map [1095].handle = objc_getClass ("CoreImage_CIBlendWithAlphaMask");
	__xamarin_class_map [1096].handle = objc_getClass ("CoreImage_CIBlendWithBlueMask");
	__xamarin_class_map [1097].handle = objc_getClass ("CoreImage_CIBlendWithRedMask");
	__xamarin_class_map [1098].handle = objc_getClass ("CoreImage_CIBloom");
	__xamarin_class_map [1099].handle = objc_getClass ("CoreImage_CILinearBlur");
	__xamarin_class_map [1100].handle = objc_getClass ("CoreImage_CIBokehBlur");
	__xamarin_class_map [1101].handle = objc_getClass ("CoreImage_CIBoxBlur");
	__xamarin_class_map [1102].handle = objc_getClass ("CoreImage_CIDistortionFilter");
	__xamarin_class_map [1103].handle = objc_getClass ("CoreImage_CIBumpDistortion");
	__xamarin_class_map [1104].handle = objc_getClass ("CoreImage_CIBumpDistortionLinear");
	__xamarin_class_map [1105].handle = objc_getClass ("CoreImage_CICameraCalibrationLensCorrection");
	__xamarin_class_map [1106].handle = objc_getClass ("CoreImage_CICheckerboardGenerator");
	__xamarin_class_map [1107].handle = objc_getClass ("CoreImage_CICircleSplashDistortion");
	__xamarin_class_map [1108].handle = objc_getClass ("CoreImage_CIScreenFilter");
	__xamarin_class_map [1109].handle = objc_getClass ("CoreImage_CICircularScreen");
	__xamarin_class_map [1110].handle = objc_getClass ("CoreImage_CICircularWrap");
	__xamarin_class_map [1111].handle = objc_getClass ("CoreImage_CIClamp");
	__xamarin_class_map [1112].handle = objc_getClass ("CoreImage_CICmykHalftone");
	__xamarin_class_map [1113].handle = objc_getClass ("CoreImage_CICode128BarcodeGenerator");
	__xamarin_class_map [1114].handle = objc_getClass ("CIColor");
	__xamarin_class_map [1115].handle = objc_getClass ("CoreImage_CIColorBlendMode");
	__xamarin_class_map [1116].handle = objc_getClass ("CoreImage_CIColorBurnBlendMode");
	__xamarin_class_map [1117].handle = objc_getClass ("CoreImage_CIColorClamp");
	__xamarin_class_map [1118].handle = objc_getClass ("CoreImage_CIColorControls");
	__xamarin_class_map [1119].handle = objc_getClass ("CoreImage_CIColorCrossPolynomial");
	__xamarin_class_map [1120].handle = objc_getClass ("CoreImage_CIColorCube");
	__xamarin_class_map [1121].handle = objc_getClass ("CoreImage_CIColorCubesMixedWithMask");
	__xamarin_class_map [1122].handle = objc_getClass ("CoreImage_CIColorCubeWithColorSpace");
	__xamarin_class_map [1123].handle = objc_getClass ("CoreImage_CIColorCurves");
	__xamarin_class_map [1124].handle = objc_getClass ("CoreImage_CIColorDodgeBlendMode");
	__xamarin_class_map [1125].handle = objc_getClass ("CoreImage_CIColorInvert");
	__xamarin_class_map [1126].handle = objc_getClass ("CoreImage_CIColorMap");
	__xamarin_class_map [1127].handle = objc_getClass ("CoreImage_CIColorMatrix");
	__xamarin_class_map [1128].handle = objc_getClass ("CoreImage_CIColorMonochrome");
	__xamarin_class_map [1129].handle = objc_getClass ("CoreImage_CIColorPolynomial");
	__xamarin_class_map [1130].handle = objc_getClass ("CoreImage_CIColorPosterize");
	__xamarin_class_map [1131].handle = objc_getClass ("CoreImage_CIColumnAverage");
	__xamarin_class_map [1132].handle = objc_getClass ("CoreImage_CIComicEffect");
	__xamarin_class_map [1133].handle = objc_getClass ("CoreImage_CIConstantColorGenerator");
	__xamarin_class_map [1134].handle = objc_getClass ("CIContext");
	__xamarin_class_map [1135].handle = objc_getClass ("CoreImage_CIConvolutionCore");
	__xamarin_class_map [1136].handle = objc_getClass ("CoreImage_CIConvolution3X3");
	__xamarin_class_map [1137].handle = objc_getClass ("CoreImage_CIConvolution5X5");
	__xamarin_class_map [1138].handle = objc_getClass ("CoreImage_CIConvolution7X7");
	__xamarin_class_map [1139].handle = objc_getClass ("CoreImage_CIConvolution9Horizontal");
	__xamarin_class_map [1140].handle = objc_getClass ("CoreImage_CIConvolution9Vertical");
	__xamarin_class_map [1141].handle = objc_getClass ("CoreImage_CICopyMachineTransition");
	__xamarin_class_map [1142].handle = objc_getClass ("CoreImage_CICoreMLModelFilter");
	__xamarin_class_map [1143].handle = objc_getClass ("CoreImage_CICrop");
	__xamarin_class_map [1144].handle = objc_getClass ("CoreImage_CICrystallize");
	__xamarin_class_map [1145].handle = objc_getClass ("CoreImage_CIDarkenBlendMode");
	__xamarin_class_map [1146].handle = objc_getClass ("CIDataMatrixCodeDescriptor");
	__xamarin_class_map [1147].handle = objc_getClass ("CoreImage_CIDepthBlurEffect");
	__xamarin_class_map [1148].handle = objc_getClass ("CoreImage_CIDepthDisparityConverter");
	__xamarin_class_map [1149].handle = objc_getClass ("CoreImage_CIDepthOfField");
	__xamarin_class_map [1150].handle = objc_getClass ("CoreImage_CIDepthToDisparity");
	__xamarin_class_map [1151].handle = objc_getClass ("CIDetector");
	__xamarin_class_map [1152].handle = objc_getClass ("CoreImage_CIDifferenceBlendMode");
	__xamarin_class_map [1153].handle = objc_getClass ("CoreImage_CIDiscBlur");
	__xamarin_class_map [1154].handle = objc_getClass ("CoreImage_CIDisintegrateWithMaskTransition");
	__xamarin_class_map [1155].handle = objc_getClass ("CoreImage_CIDisparityToDepth");
	__xamarin_class_map [1156].handle = objc_getClass ("CoreImage_CIDisplacementDistortion");
	__xamarin_class_map [1157].handle = objc_getClass ("CoreImage_CIDissolveTransition");
	__xamarin_class_map [1158].handle = objc_getClass ("CoreImage_CIDither");
	__xamarin_class_map [1159].handle = objc_getClass ("CoreImage_CIDivideBlendMode");
	__xamarin_class_map [1160].handle = objc_getClass ("CoreImage_CIDotScreen");
	__xamarin_class_map [1161].handle = objc_getClass ("CoreImage_CIDroste");
	__xamarin_class_map [1162].handle = objc_getClass ("CoreImage_CIEdgePreserveUpsampleFilter");
	__xamarin_class_map [1163].handle = objc_getClass ("CoreImage_CIEdges");
	__xamarin_class_map [1164].handle = objc_getClass ("CoreImage_CIEdgeWork");
	__xamarin_class_map [1165].handle = objc_getClass ("CoreImage_CITileFilter");
	__xamarin_class_map [1166].handle = objc_getClass ("CoreImage_CIEightfoldReflectedTile");
	__xamarin_class_map [1167].handle = objc_getClass ("CoreImage_CIExclusionBlendMode");
	__xamarin_class_map [1168].handle = objc_getClass ("CoreImage_CIExposureAdjust");
	__xamarin_class_map [1169].handle = objc_getClass ("CoreImage_CIFaceBalance");
	__xamarin_class_map [1170].handle = objc_getClass ("CIFeature");
	__xamarin_class_map [1171].handle = objc_getClass ("CIFaceFeature");
	__xamarin_class_map [1172].handle = objc_getClass ("CoreImage_CIFalseColor");
	__xamarin_class_map [1173].handle = objc_getClass ("CIFilterGenerator");
	__xamarin_class_map [1174].handle = objc_getClass ("CIFilterShape");
	__xamarin_class_map [1175].handle = objc_getClass ("CoreImage_CIFlashTransition");
	__xamarin_class_map [1176].handle = objc_getClass ("CoreImage_CIFourfoldReflectedTile");
	__xamarin_class_map [1177].handle = objc_getClass ("CoreImage_CIFourfoldRotatedTile");
	__xamarin_class_map [1178].handle = objc_getClass ("CoreImage_CIFourfoldTranslatedTile");
	__xamarin_class_map [1179].handle = objc_getClass ("CoreImage_CIGammaAdjust");
	__xamarin_class_map [1180].handle = objc_getClass ("CoreImage_CIGaussianBlur");
	__xamarin_class_map [1181].handle = objc_getClass ("CoreImage_CIGaussianGradient");
	__xamarin_class_map [1182].handle = objc_getClass ("CoreImage_CIGlassDistortion");
	__xamarin_class_map [1183].handle = objc_getClass ("CoreImage_CIGlassLozenge");
	__xamarin_class_map [1184].handle = objc_getClass ("CoreImage_CIGlideReflectedTile");
	__xamarin_class_map [1185].handle = objc_getClass ("CoreImage_CIGloom");
	__xamarin_class_map [1186].handle = objc_getClass ("CoreImage_CIGuidedFilter");
	__xamarin_class_map [1187].handle = objc_getClass ("CoreImage_CIHardLightBlendMode");
	__xamarin_class_map [1188].handle = objc_getClass ("CoreImage_CIHatchedScreen");
	__xamarin_class_map [1189].handle = objc_getClass ("CoreImage_CIHeightFieldFromMask");
	__xamarin_class_map [1190].handle = objc_getClass ("CoreImage_CIHexagonalPixellate");
	__xamarin_class_map [1191].handle = objc_getClass ("CoreImage_CIHighlightShadowAdjust");
	__xamarin_class_map [1192].handle = objc_getClass ("CoreImage_CIHistogramDisplayFilter");
	__xamarin_class_map [1193].handle = objc_getClass ("CoreImage_CIHoleDistortion");
	__xamarin_class_map [1194].handle = objc_getClass ("CoreImage_CIHueAdjust");
	__xamarin_class_map [1195].handle = objc_getClass ("CoreImage_CIHueBlendMode");
	__xamarin_class_map [1196].handle = objc_getClass ("CoreImage_CIHueSaturationValueGradient");
	__xamarin_class_map [1197].handle = objc_getClass ("CIImage");
	__xamarin_class_map [1198].handle = objc_getClass ("CIImageAccumulator");
	__xamarin_class_map [1199].handle = objc_getClass ("CIImageProcessorKernel");
	__xamarin_class_map [1200].handle = objc_getClass ("CoreImage_CIKaleidoscope");
	__xamarin_class_map [1201].handle = objc_getClass ("CoreImage_CILabDeltaE");
	__xamarin_class_map [1202].handle = objc_getClass ("CoreImage_CILanczosScaleTransform");
	__xamarin_class_map [1203].handle = objc_getClass ("CoreImage_CILenticularHaloGenerator");
	__xamarin_class_map [1204].handle = objc_getClass ("CoreImage_CILightenBlendMode");
	__xamarin_class_map [1205].handle = objc_getClass ("CoreImage_CILightTunnel");
	__xamarin_class_map [1206].handle = objc_getClass ("CoreImage_CILinearBurnBlendMode");
	__xamarin_class_map [1207].handle = objc_getClass ("CoreImage_CILinearDodgeBlendMode");
	__xamarin_class_map [1208].handle = objc_getClass ("CoreImage_CILinearGradient");
	__xamarin_class_map [1209].handle = objc_getClass ("CoreImage_CILinearToSRGBToneCurve");
	__xamarin_class_map [1210].handle = objc_getClass ("CoreImage_CILineOverlay");
	__xamarin_class_map [1211].handle = objc_getClass ("CoreImage_CILineScreen");
	__xamarin_class_map [1212].handle = objc_getClass ("CoreImage_CILuminosityBlendMode");
	__xamarin_class_map [1213].handle = objc_getClass ("CoreImage_CIMaskedVariableBlur");
	__xamarin_class_map [1214].handle = objc_getClass ("CoreImage_CIMaskToAlpha");
	__xamarin_class_map [1215].handle = objc_getClass ("CoreImage_CIMaximumComponent");
	__xamarin_class_map [1216].handle = objc_getClass ("CoreImage_CIMaximumCompositing");
	__xamarin_class_map [1217].handle = objc_getClass ("CoreImage_CIMedianFilter");
	__xamarin_class_map [1218].handle = objc_getClass ("CoreImage_CIMeshGenerator");
	__xamarin_class_map [1219].handle = objc_getClass ("CoreImage_CIMinimumComponent");
	__xamarin_class_map [1220].handle = objc_getClass ("CoreImage_CIMinimumCompositing");
	__xamarin_class_map [1221].handle = objc_getClass ("CoreImage_CIMix");
	__xamarin_class_map [1222].handle = objc_getClass ("CoreImage_CIModTransition");
	__xamarin_class_map [1223].handle = objc_getClass ("CoreImage_CIMorphology");
	__xamarin_class_map [1224].handle = objc_getClass ("CoreImage_CIMorphologyGradient");
	__xamarin_class_map [1225].handle = objc_getClass ("CoreImage_CIMorphologyMaximum");
	__xamarin_class_map [1226].handle = objc_getClass ("CoreImage_CIMorphologyMinimum");
	__xamarin_class_map [1227].handle = objc_getClass ("CoreImage_CIMotionBlur");
	__xamarin_class_map [1228].handle = objc_getClass ("CoreImage_CIMultiplyBlendMode");
	__xamarin_class_map [1229].handle = objc_getClass ("CoreImage_CIMultiplyCompositing");
	__xamarin_class_map [1230].handle = objc_getClass ("CoreImage_CINinePartStretched");
	__xamarin_class_map [1231].handle = objc_getClass ("CoreImage_CINinePartTiled");
	__xamarin_class_map [1232].handle = objc_getClass ("CoreImage_CINoiseReduction");
	__xamarin_class_map [1233].handle = objc_getClass ("CoreImage_CIOpTile");
	__xamarin_class_map [1234].handle = objc_getClass ("CoreImage_CIOverlayBlendMode");
	__xamarin_class_map [1235].handle = objc_getClass ("CoreImage_CIPageCurlTransition");
	__xamarin_class_map [1236].handle = objc_getClass ("CoreImage_CIPageCurlWithShadowTransition");
	__xamarin_class_map [1237].handle = objc_getClass ("CoreImage_CIParallelogramTile");
	__xamarin_class_map [1238].handle = objc_getClass ("CoreImage_CIPdf417BarcodeGenerator");
	__xamarin_class_map [1239].handle = objc_getClass ("CIPDF417CodeDescriptor");
	__xamarin_class_map [1240].handle = objc_getClass ("CoreImage_CIPerspectiveTransform");
	__xamarin_class_map [1241].handle = objc_getClass ("CoreImage_CIPerspectiveCorrection");
	__xamarin_class_map [1242].handle = objc_getClass ("CoreImage_CIPerspectiveTile");
	__xamarin_class_map [1243].handle = objc_getClass ("CoreImage_CIPerspectiveTransformWithExtent");
	__xamarin_class_map [1244].handle = objc_getClass ("CoreImage_CIPhotoEffect");
	__xamarin_class_map [1245].handle = objc_getClass ("CoreImage_CIPhotoEffectChrome");
	__xamarin_class_map [1246].handle = objc_getClass ("CoreImage_CIPhotoEffectFade");
	__xamarin_class_map [1247].handle = objc_getClass ("CoreImage_CIPhotoEffectInstant");
	__xamarin_class_map [1248].handle = objc_getClass ("CoreImage_CIPhotoEffectMono");
	__xamarin_class_map [1249].handle = objc_getClass ("CoreImage_CIPhotoEffectNoir");
	__xamarin_class_map [1250].handle = objc_getClass ("CoreImage_CIPhotoEffectProcess");
	__xamarin_class_map [1251].handle = objc_getClass ("CoreImage_CIPhotoEffectTonal");
	__xamarin_class_map [1252].handle = objc_getClass ("CoreImage_CIPhotoEffectTransfer");
	__xamarin_class_map [1253].handle = objc_getClass ("CoreImage_CIPinchDistortion");
	__xamarin_class_map [1254].handle = objc_getClass ("CoreImage_CIPinLightBlendMode");
	__xamarin_class_map [1255].handle = objc_getClass ("CoreImage_CIPixellate");
	__xamarin_class_map [1256].handle = objc_getClass ("CIPlugIn");
	__xamarin_class_map [1257].handle = objc_getClass ("CoreImage_CIPointillize");
	__xamarin_class_map [1258].handle = objc_getClass ("CIQRCodeDescriptor");
	__xamarin_class_map [1259].handle = objc_getClass ("CIQRCodeFeature");
	__xamarin_class_map [1260].handle = objc_getClass ("CoreImage_CIQRCodeGenerator");
	__xamarin_class_map [1261].handle = objc_getClass ("CoreImage_CIRadialGradient");
	__xamarin_class_map [1262].handle = objc_getClass ("CoreImage_CIRandomGenerator");
	__xamarin_class_map [1263].handle = objc_getClass ("CIRectangleFeature");
	__xamarin_class_map [1264].handle = objc_getClass ("CIRenderDestination");
	__xamarin_class_map [1265].handle = objc_getClass ("CIRenderInfo");
	__xamarin_class_map [1266].handle = objc_getClass ("CIRenderTask");
	__xamarin_class_map [1267].handle = objc_getClass ("CoreImage_CIRippleTransition");
	__xamarin_class_map [1268].handle = objc_getClass ("CoreImage_CIRowAverage");
	__xamarin_class_map [1269].handle = objc_getClass ("CoreImage_CISaliencyMapFilter");
	__xamarin_class_map [1270].handle = objc_getClass ("CoreImage_CISampleNearest");
	__xamarin_class_map [1271].handle = objc_getClass ("CISampler");
	__xamarin_class_map [1272].handle = objc_getClass ("CoreImage_CISaturationBlendMode");
	__xamarin_class_map [1273].handle = objc_getClass ("CoreImage_CIScreenBlendMode");
	__xamarin_class_map [1274].handle = objc_getClass ("CoreImage_CISepiaTone");
	__xamarin_class_map [1275].handle = objc_getClass ("CoreImage_CIShadedMaterial");
	__xamarin_class_map [1276].handle = objc_getClass ("CoreImage_CISharpenLuminance");
	__xamarin_class_map [1277].handle = objc_getClass ("CoreImage_CISixfoldReflectedTile");
	__xamarin_class_map [1278].handle = objc_getClass ("CoreImage_CISixfoldRotatedTile");
	__xamarin_class_map [1279].handle = objc_getClass ("CoreImage_CISmoothLinearGradient");
	__xamarin_class_map [1280].handle = objc_getClass ("CoreImage_CISoftLightBlendMode");
	__xamarin_class_map [1281].handle = objc_getClass ("CoreImage_CISourceAtopCompositing");
	__xamarin_class_map [1282].handle = objc_getClass ("CoreImage_CISourceInCompositing");
	__xamarin_class_map [1283].handle = objc_getClass ("CoreImage_CISourceOutCompositing");
	__xamarin_class_map [1284].handle = objc_getClass ("CoreImage_CISourceOverCompositing");
	__xamarin_class_map [1285].handle = objc_getClass ("CoreImage_CISpotColor");
	__xamarin_class_map [1286].handle = objc_getClass ("CoreImage_CISpotLight");
	__xamarin_class_map [1287].handle = objc_getClass ("CoreImage_CISRGBToneCurveToLinear");
	__xamarin_class_map [1288].handle = objc_getClass ("CoreImage_CIStarShineGenerator");
	__xamarin_class_map [1289].handle = objc_getClass ("CoreImage_CIStraightenFilter");
	__xamarin_class_map [1290].handle = objc_getClass ("CoreImage_CIStretchCrop");
	__xamarin_class_map [1291].handle = objc_getClass ("CoreImage_CIStripesGenerator");
	__xamarin_class_map [1292].handle = objc_getClass ("CoreImage_CISubtractBlendMode");
	__xamarin_class_map [1293].handle = objc_getClass ("CoreImage_CISunbeamsGenerator");
	__xamarin_class_map [1294].handle = objc_getClass ("CoreImage_CISwipeTransition");
	__xamarin_class_map [1295].handle = objc_getClass ("CoreImage_CITemperatureAndTint");
	__xamarin_class_map [1296].handle = objc_getClass ("CITextFeature");
	__xamarin_class_map [1297].handle = objc_getClass ("CoreImage_CITextImageGenerator");
	__xamarin_class_map [1298].handle = objc_getClass ("CoreImage_CIThermal");
	__xamarin_class_map [1299].handle = objc_getClass ("CoreImage_CIToneCurve");
	__xamarin_class_map [1300].handle = objc_getClass ("CoreImage_CITorusLensDistortion");
	__xamarin_class_map [1301].handle = objc_getClass ("CoreImage_CITriangleKaleidoscope");
	__xamarin_class_map [1302].handle = objc_getClass ("CoreImage_CITriangleTile");
	__xamarin_class_map [1303].handle = objc_getClass ("CoreImage_CITwelvefoldReflectedTile");
	__xamarin_class_map [1304].handle = objc_getClass ("CoreImage_CITwirlDistortion");
	__xamarin_class_map [1305].handle = objc_getClass ("CoreImage_CIUnsharpMask");
	__xamarin_class_map [1306].handle = objc_getClass ("CIVector");
	__xamarin_class_map [1307].handle = objc_getClass ("CoreImage_CIVibrance");
	__xamarin_class_map [1308].handle = objc_getClass ("CoreImage_CIVignette");
	__xamarin_class_map [1309].handle = objc_getClass ("CoreImage_CIVignetteEffect");
	__xamarin_class_map [1310].handle = objc_getClass ("CoreImage_CIVortexDistortion");
	__xamarin_class_map [1311].handle = objc_getClass ("CIWarpKernel");
	__xamarin_class_map [1312].handle = objc_getClass ("CoreImage_CIWhitePointAdjust");
	__xamarin_class_map [1313].handle = objc_getClass ("CoreImage_CIXRay");
	__xamarin_class_map [1314].handle = objc_getClass ("CoreImage_CIZoomBlur");
	__xamarin_class_map [1315].handle = objc_getClass ("CoreImage_CICMYKHalftone");
	__xamarin_class_map [1316].handle = objc_getClass ("NSPersistentStoreRequest");
	__xamarin_class_map [1317].handle = objc_getClass ("NSAsynchronousFetchRequest");
	__xamarin_class_map [1318].handle = objc_getClass ("NSPersistentStoreResult");
	__xamarin_class_map [1319].handle = objc_getClass ("NSPersistentStoreAsynchronousResult");
	__xamarin_class_map [1320].handle = objc_getClass ("NSAsynchronousFetchResult");
	__xamarin_class_map [1321].handle = objc_getClass ("NSPersistentStore");
	__xamarin_class_map [1322].handle = objc_getClass ("NSAtomicStore");
	__xamarin_class_map [1323].handle = objc_getClass ("NSAtomicStoreCacheNode");
	__xamarin_class_map [1324].handle = objc_getClass ("NSPropertyDescription");
	__xamarin_class_map [1325].handle = objc_getClass ("NSAttributeDescription");
	__xamarin_class_map [1326].handle = objc_getClass ("NSBatchDeleteRequest");
	__xamarin_class_map [1327].handle = objc_getClass ("NSBatchDeleteResult");
	__xamarin_class_map [1328].handle = objc_getClass ("NSBatchUpdateRequest");
	__xamarin_class_map [1329].handle = objc_getClass ("NSBatchUpdateResult");
	__xamarin_class_map [1330].handle = objc_getClass ("NSConstraintConflict");
	__xamarin_class_map [1331].handle = objc_getClass ("NSCoreDataCoreSpotlightDelegate");
	__xamarin_class_map [1332].handle = objc_getClass ("NSEntityDescription");
	__xamarin_class_map [1333].handle = objc_getClass ("NSEntityMapping");
	__xamarin_class_map [1334].handle = objc_getClass ("NSEntityMigrationPolicy");
	__xamarin_class_map [1335].handle = objc_getClass ("NSExpressionDescription");
	__xamarin_class_map [1336].handle = objc_getClass ("NSFetchedPropertyDescription");
	__xamarin_class_map [1337].handle = objc_getClass ("NSFetchIndexDescription");
	__xamarin_class_map [1338].handle = objc_getClass ("NSFetchIndexElementDescription");
	__xamarin_class_map [1339].handle = objc_getClass ("NSFetchRequest");
	__xamarin_class_map [1340].handle = objc_getClass ("NSExpression");
	__xamarin_class_map [1341].handle = objc_getClass ("NSFetchRequestExpression");
	__xamarin_class_map [1342].handle = objc_getClass ("NSIncrementalStore");
	__xamarin_class_map [1343].handle = objc_getClass ("NSIncrementalStoreNode");
	__xamarin_class_map [1344].handle = objc_getClass ("NSManagedObject");
	__xamarin_class_map [1345].handle = objc_getClass ("NSManagedObjectID");
	__xamarin_class_map [1346].handle = objc_getClass ("NSManagedObjectModel");
	__xamarin_class_map [1347].handle = objc_getClass ("NSMappingModel");
	__xamarin_class_map [1348].handle = objc_getClass ("NSMergeConflict");
	__xamarin_class_map [1349].handle = objc_getClass ("NSMergePolicy");
	__xamarin_class_map [1350].handle = objc_getClass ("NSMigrationManager");
	__xamarin_class_map [1351].handle = objc_getClass ("NSPersistentHistoryChange");
	__xamarin_class_map [1352].handle = objc_getClass ("NSPersistentHistoryChangeRequest");
	__xamarin_class_map [1353].handle = objc_getClass ("NSPersistentHistoryResult");
	__xamarin_class_map [1354].handle = objc_getClass ("NSPersistentHistoryToken");
	__xamarin_class_map [1355].handle = objc_getClass ("NSPersistentHistoryTransaction");
	__xamarin_class_map [1356].handle = objc_getClass ("NSPersistentStoreDescription");
	__xamarin_class_map [1357].handle = objc_getClass ("NSPropertyMapping");
	__xamarin_class_map [1358].handle = objc_getClass ("NSQueryGenerationToken");
	__xamarin_class_map [1359].handle = objc_getClass ("NSRelationshipDescription");
	__xamarin_class_map [1360].handle = objc_getClass ("NSSaveChangesRequest");
	__xamarin_class_map [1361].handle = objc_getClass ("CBATTRequest");
	__xamarin_class_map [1362].handle = objc_getClass ("CBAttribute");
	__xamarin_class_map [1363].handle = objc_getClass ("CBPeer");
	__xamarin_class_map [1364].handle = objc_getClass ("CBCentral");
	__xamarin_class_map [1365].handle = objc_getClass ("CBCentralManagerDelegate");
	__xamarin_class_map [1366].handle = objc_getClass ("CBCharacteristic");
	__xamarin_class_map [1367].handle = objc_getClass ("CBDescriptor");
	__xamarin_class_map [1368].handle = objc_getClass ("CBL2CAPChannel");
	__xamarin_class_map [1369].handle = objc_getClass ("CBManager");
	__xamarin_class_map [1370].handle = objc_getClass ("CBMutableCharacteristic");
	__xamarin_class_map [1371].handle = objc_getClass ("CBMutableDescriptor");
	__xamarin_class_map [1372].handle = objc_getClass ("CBService");
	__xamarin_class_map [1373].handle = objc_getClass ("CBMutableService");
	__xamarin_class_map [1374].handle = objc_getClass ("CBPeripheralDelegate");
	__xamarin_class_map [1375].handle = objc_getClass ("CBPeripheralManagerDelegate");
	__xamarin_class_map [1376].handle = objc_getClass ("CBUUID");
	__xamarin_class_map [1377].handle = objc_getClass ("AUAudioUnitViewConfiguration");
	__xamarin_class_map [1378].handle = objc_getClass ("AUGenericView");
	__xamarin_class_map [1379].handle = objc_getClass ("AUPannerView");
	__xamarin_class_map [1380].handle = objc_getClass ("AUViewController");
	__xamarin_class_map [1381].handle = objc_getClass ("NSWindowController");
	__xamarin_class_map [1382].handle = objc_getClass ("CABTLEMIDIWindowController");
	__xamarin_class_map [1383].handle = objc_getClass ("CAInterDeviceAudioViewController");
	__xamarin_class_map [1384].handle = objc_getClass ("CANetworkBrowserWindowController");
	__xamarin_class_map [1385].handle = objc_getClass ("CAAction");
	__xamarin_class_map [1386].handle = objc_getClass ("CAAnimationDelegate");
	__xamarin_class_map [1387].handle = objc_getClass ("CAAnimation");
	__xamarin_class_map [1388].handle = objc_getClass ("CAAnimationGroup");
	__xamarin_class_map [1389].handle = objc_getClass ("CAPropertyAnimation");
	__xamarin_class_map [1390].handle = objc_getClass ("CABasicAnimation");
	__xamarin_class_map [1391].handle = objc_getClass ("CAConstraint");
	__xamarin_class_map [1392].handle = objc_getClass ("CAConstraintLayoutManager");
	__xamarin_class_map [1393].handle = objc_getClass ("CAEmitterBehavior");
	__xamarin_class_map [1394].handle = objc_getClass ("CAEmitterCell");
	__xamarin_class_map [1395].handle = objc_getClass ("CAEmitterLayer");
	__xamarin_class_map [1396].handle = objc_getClass ("CAGradientLayer");
	__xamarin_class_map [1397].handle = objc_getClass ("CAKeyframeAnimation");
	__xamarin_class_map [1398].handle = objc_getClass ("CALayerDelegate");
	__xamarin_class_map [1399].handle = objc_getClass ("CAMediaTiming");
	__xamarin_class_map [1400].handle = objc_getClass ("CAMediaTimingFunction");
	__xamarin_class_map [1401].handle = objc_getClass ("CAMetalLayer");
	__xamarin_class_map [1402].handle = objc_getClass ("CARenderer");
	__xamarin_class_map [1403].handle = objc_getClass ("CAReplicatorLayer");
	__xamarin_class_map [1404].handle = objc_getClass ("CAScrollLayer");
	__xamarin_class_map [1405].handle = objc_getClass ("CAShapeLayer");
	__xamarin_class_map [1406].handle = objc_getClass ("CASpringAnimation");
	__xamarin_class_map [1407].handle = objc_getClass ("CATextLayer");
	__xamarin_class_map [1408].handle = objc_getClass ("CATiledLayer");
	__xamarin_class_map [1409].handle = objc_getClass ("CATransaction");
	__xamarin_class_map [1410].handle = objc_getClass ("CATransformLayer");
	__xamarin_class_map [1411].handle = objc_getClass ("CATransition");
	__xamarin_class_map [1412].handle = objc_getClass ("CAValueFunction");
	__xamarin_class_map [1413].handle = objc_getClass ("CNContactPicker");
	__xamarin_class_map [1414].handle = objc_getClass ("CNContactPickerDelegate");
	__xamarin_class_map [1415].handle = objc_getClass ("CNContactViewController");
	__xamarin_class_map [1416].handle = objc_getClass ("CNContactFetchRequest");
	__xamarin_class_map [1417].handle = objc_getClass ("CNContactFormatter");
	__xamarin_class_map [1418].handle = objc_getClass ("CNContactProperty");
	__xamarin_class_map [1419].handle = objc_getClass ("CNContactRelation");
	__xamarin_class_map [1420].handle = objc_getClass ("CNContactsUserDefaults");
	__xamarin_class_map [1421].handle = objc_getClass ("CNContactVCardSerialization");
	__xamarin_class_map [1422].handle = objc_getClass ("CNContainer");
	__xamarin_class_map [1423].handle = objc_getClass ("CNGroup");
	__xamarin_class_map [1424].handle = objc_getClass ("CNInstantMessageAddress");
	__xamarin_class_map [1425].handle = objc_getClass ("CNLabeledValue");
	__xamarin_class_map [1426].handle = objc_getClass ("CNContact");
	__xamarin_class_map [1427].handle = objc_getClass ("CNMutableContact");
	__xamarin_class_map [1428].handle = objc_getClass ("CNMutableGroup");
	__xamarin_class_map [1429].handle = objc_getClass ("CNPostalAddress");
	__xamarin_class_map [1430].handle = objc_getClass ("CNMutablePostalAddress");
	__xamarin_class_map [1431].handle = objc_getClass ("CNPhoneNumber");
	__xamarin_class_map [1432].handle = objc_getClass ("CNPostalAddressFormatter");
	__xamarin_class_map [1433].handle = objc_getClass ("CNSaveRequest");
	__xamarin_class_map [1434].handle = objc_getClass ("CNSocialProfile");
	__xamarin_class_map [1435].handle = objc_getClass ("NSOperation");
	__xamarin_class_map [1436].handle = objc_getClass ("CKOperation");
	__xamarin_class_map [1437].handle = objc_getClass ("CKAcceptSharesOperation");
	__xamarin_class_map [1438].handle = objc_getClass ("CKAsset");
	__xamarin_class_map [1439].handle = objc_getClass ("CKNotification");
	__xamarin_class_map [1440].handle = objc_getClass ("CKDatabaseNotification");
	__xamarin_class_map [1441].handle = objc_getClass ("CKDatabaseOperation");
	__xamarin_class_map [1442].handle = objc_getClass ("CKSubscription");
	__xamarin_class_map [1443].handle = objc_getClass ("CKDatabaseSubscription");
	__xamarin_class_map [1444].handle = objc_getClass ("CKDiscoverAllContactsOperation");
	__xamarin_class_map [1445].handle = objc_getClass ("CKDiscoverAllUserIdentitiesOperation");
	__xamarin_class_map [1446].handle = objc_getClass ("CKDiscoveredUserInfo");
	__xamarin_class_map [1447].handle = objc_getClass ("CKDiscoverUserIdentitiesOperation");
	__xamarin_class_map [1448].handle = objc_getClass ("CKDiscoverUserInfosOperation");
	__xamarin_class_map [1449].handle = objc_getClass ("CKFetchDatabaseChangesOperation");
	__xamarin_class_map [1450].handle = objc_getClass ("CKFetchNotificationChangesOperation");
	__xamarin_class_map [1451].handle = objc_getClass ("CKFetchRecordChangesOperation");
	__xamarin_class_map [1452].handle = objc_getClass ("CKFetchRecordsOperation");
	__xamarin_class_map [1453].handle = objc_getClass ("CKFetchRecordZoneChangesConfiguration");
	__xamarin_class_map [1454].handle = objc_getClass ("CKFetchRecordZoneChangesOperation");
	__xamarin_class_map [1455].handle = objc_getClass ("CKFetchRecordZoneChangesOptions");
	__xamarin_class_map [1456].handle = objc_getClass ("CKFetchRecordZonesOperation");
	__xamarin_class_map [1457].handle = objc_getClass ("CKFetchShareMetadataOperation");
	__xamarin_class_map [1458].handle = objc_getClass ("CKFetchShareParticipantsOperation");
	__xamarin_class_map [1459].handle = objc_getClass ("CKFetchSubscriptionsOperation");
	__xamarin_class_map [1460].handle = objc_getClass ("CKFetchWebAuthTokenOperation");
	__xamarin_class_map [1461].handle = objc_getClass ("NSSortDescriptor");
	__xamarin_class_map [1462].handle = objc_getClass ("CKLocationSortDescriptor");
	__xamarin_class_map [1463].handle = objc_getClass ("CKMarkNotificationsReadOperation");
	__xamarin_class_map [1464].handle = objc_getClass ("CKModifyBadgeOperation");
	__xamarin_class_map [1465].handle = objc_getClass ("CKModifyRecordsOperation");
	__xamarin_class_map [1466].handle = objc_getClass ("CKModifyRecordZonesOperation");
	__xamarin_class_map [1467].handle = objc_getClass ("CKModifySubscriptionsOperation");
	__xamarin_class_map [1468].handle = objc_getClass ("CKNotificationID");
	__xamarin_class_map [1469].handle = objc_getClass ("CKNotificationInfo");
	__xamarin_class_map [1470].handle = objc_getClass ("CKOperationConfiguration");
	__xamarin_class_map [1471].handle = objc_getClass ("CKOperationGroup");
	__xamarin_class_map [1472].handle = objc_getClass ("CKQuery");
	__xamarin_class_map [1473].handle = objc_getClass ("CKQueryCursor");
	__xamarin_class_map [1474].handle = objc_getClass ("CKQueryNotification");
	__xamarin_class_map [1475].handle = objc_getClass ("CKQueryOperation");
	__xamarin_class_map [1476].handle = objc_getClass ("CKQuerySubscription");
	__xamarin_class_map [1477].handle = objc_getClass ("CKRecord");
	__xamarin_class_map [1478].handle = objc_getClass ("CKRecordID");
	__xamarin_class_map [1479].handle = objc_getClass ("CKRecordValue");
	__xamarin_class_map [1480].handle = objc_getClass ("CKRecordZone");
	__xamarin_class_map [1481].handle = objc_getClass ("CKRecordZoneID");
	__xamarin_class_map [1482].handle = objc_getClass ("CKRecordZoneNotification");
	__xamarin_class_map [1483].handle = objc_getClass ("CKRecordZoneSubscription");
	__xamarin_class_map [1484].handle = objc_getClass ("CKReference");
	__xamarin_class_map [1485].handle = objc_getClass ("CKServerChangeToken");
	__xamarin_class_map [1486].handle = objc_getClass ("CKShare");
	__xamarin_class_map [1487].handle = objc_getClass ("CKShareMetadata");
	__xamarin_class_map [1488].handle = objc_getClass ("CKShareParticipant");
	__xamarin_class_map [1489].handle = objc_getClass ("CKUserIdentity");
	__xamarin_class_map [1490].handle = objc_getClass ("CKUserIdentityLookupInfo");
	__xamarin_class_map [1491].handle = objc_getClass ("BCChatAction");
	__xamarin_class_map [1492].handle = objc_getClass ("NSControl");
	__xamarin_class_map [1493].handle = objc_getClass ("BCChatButton");
	__xamarin_class_map [1494].handle = objc_getClass ("AVCaptureView");
	__xamarin_class_map [1495].handle = objc_getClass ("AVCaptureViewDelegate");
	__xamarin_class_map [1496].handle = objc_getClass ("AVPlayerView");
	__xamarin_class_map [1497].handle = objc_getClass ("AVAssetCache");
	__xamarin_class_map [1498].handle = objc_getClass ("AVAssetImageGenerator");
	__xamarin_class_map [1499].handle = objc_getClass ("AVAssetReader");
	__xamarin_class_map [1500].handle = objc_getClass ("AVAssetReaderOutput");
	__xamarin_class_map [1501].handle = objc_getClass ("AVAssetReaderAudioMixOutput");
	__xamarin_class_map [1502].handle = objc_getClass ("AVAssetReaderOutputMetadataAdaptor");
	__xamarin_class_map [1503].handle = objc_getClass ("AVAssetReaderSampleReferenceOutput");
	__xamarin_class_map [1504].handle = objc_getClass ("AVAssetReaderTrackOutput");
	__xamarin_class_map [1505].handle = objc_getClass ("AVAssetReaderVideoCompositionOutput");
	__xamarin_class_map [1506].handle = objc_getClass ("AVAssetResourceLoader");
	__xamarin_class_map [1507].handle = objc_getClass ("AVAssetResourceLoaderDelegate");
	__xamarin_class_map [1508].handle = objc_getClass ("AVAssetResourceLoadingContentInformationRequest");
	__xamarin_class_map [1509].handle = objc_getClass ("AVAssetResourceLoadingDataRequest");
	__xamarin_class_map [1510].handle = objc_getClass ("AVAssetResourceLoadingRequest");
	__xamarin_class_map [1511].handle = objc_getClass ("AVAssetResourceLoadingRequestor");
	__xamarin_class_map [1512].handle = objc_getClass ("AVAssetResourceRenewalRequest");
	__xamarin_class_map [1513].handle = objc_getClass ("AVAssetTrackGroup");
	__xamarin_class_map [1514].handle = objc_getClass ("AVAssetTrackSegment");
	__xamarin_class_map [1515].handle = objc_getClass ("AVAssetWriterInput");
	__xamarin_class_map [1516].handle = objc_getClass ("AVMediaSelectionGroup");
	__xamarin_class_map [1517].handle = objc_getClass ("AVAssetWriterInputGroup");
	__xamarin_class_map [1518].handle = objc_getClass ("AVAssetWriterInputMetadataAdaptor");
	__xamarin_class_map [1519].handle = objc_getClass ("AVAssetWriterInputPassDescription");
	__xamarin_class_map [1520].handle = objc_getClass ("AVAssetWriterInputPixelBufferAdaptor");
	__xamarin_class_map [1521].handle = objc_getClass ("AVAsynchronousCIImageFilteringRequest");
	__xamarin_class_map [1522].handle = objc_getClass ("AVAsynchronousKeyValueLoading");
	__xamarin_class_map [1523].handle = objc_getClass ("AVAsynchronousVideoCompositionRequest");
	__xamarin_class_map [1524].handle = objc_getClass ("AVAudio3DMixing");
	__xamarin_class_map [1525].handle = objc_getClass ("AVAudioBuffer");
	__xamarin_class_map [1526].handle = objc_getClass ("AVAudioChannelLayout");
	__xamarin_class_map [1527].handle = objc_getClass ("AVAudioCompressedBuffer");
	__xamarin_class_map [1528].handle = objc_getClass ("AVAudioConnectionPoint");
	__xamarin_class_map [1529].handle = objc_getClass ("AVAudioConverter");
	__xamarin_class_map [1530].handle = objc_getClass ("AVAudioEnvironmentDistanceAttenuationParameters");
	__xamarin_class_map [1531].handle = objc_getClass ("AVAudioNode");
	__xamarin_class_map [1532].handle = objc_getClass ("AVAudioEnvironmentNode");
	__xamarin_class_map [1533].handle = objc_getClass ("AVAudioEnvironmentReverbParameters");
	__xamarin_class_map [1534].handle = objc_getClass ("AVAudioFile");
	__xamarin_class_map [1535].handle = objc_getClass ("AVAudioFormat");
	__xamarin_class_map [1536].handle = objc_getClass ("AVAudioIONode");
	__xamarin_class_map [1537].handle = objc_getClass ("AVAudioInputNode");
	__xamarin_class_map [1538].handle = objc_getClass ("AVAudioMix");
	__xamarin_class_map [1539].handle = objc_getClass ("AVAudioMixerNode");
	__xamarin_class_map [1540].handle = objc_getClass ("AVAudioMixingDestination");
	__xamarin_class_map [1541].handle = objc_getClass ("AVAudioMixInputParameters");
	__xamarin_class_map [1542].handle = objc_getClass ("AVAudioOutputNode");
	__xamarin_class_map [1543].handle = objc_getClass ("AVAudioPCMBuffer");
	__xamarin_class_map [1544].handle = objc_getClass ("AVAudioPlayer");
	__xamarin_class_map [1545].handle = objc_getClass ("AVAudioPlayerDelegate");
	__xamarin_class_map [1546].handle = objc_getClass ("AVAudioRecorder");
	__xamarin_class_map [1547].handle = objc_getClass ("AVAudioRecorderDelegate");
	__xamarin_class_map [1548].handle = objc_getClass ("AVAudioSequencer");
	__xamarin_class_map [1549].handle = objc_getClass ("AVAudioStereoMixing");
	__xamarin_class_map [1550].handle = objc_getClass ("AVAudioTime");
	__xamarin_class_map [1551].handle = objc_getClass ("AVAudioUnitComponentManager");
	__xamarin_class_map [1552].handle = objc_getClass ("AVAudioUnit");
	__xamarin_class_map [1553].handle = objc_getClass ("AVAudioUnitEffect");
	__xamarin_class_map [1554].handle = objc_getClass ("AVAudioUnitDelay");
	__xamarin_class_map [1555].handle = objc_getClass ("AVAudioUnitDistortion");
	__xamarin_class_map [1556].handle = objc_getClass ("AVAudioUnitEQ");
	__xamarin_class_map [1557].handle = objc_getClass ("AVAudioUnitEQFilterParameters");
	__xamarin_class_map [1558].handle = objc_getClass ("AVAudioUnitGenerator");
	__xamarin_class_map [1559].handle = objc_getClass ("AVAudioUnitMIDIInstrument");
	__xamarin_class_map [1560].handle = objc_getClass ("AVAudioUnitReverb");
	__xamarin_class_map [1561].handle = objc_getClass ("AVAudioUnitSampler");
	__xamarin_class_map [1562].handle = objc_getClass ("AVAudioUnitTimeEffect");
	__xamarin_class_map [1563].handle = objc_getClass ("AVAudioUnitTimePitch");
	__xamarin_class_map [1564].handle = objc_getClass ("AVAudioUnitVarispeed");
	__xamarin_class_map [1565].handle = objc_getClass ("AVCameraCalibrationData");
	__xamarin_class_map [1566].handle = objc_getClass ("AVCaptureAudioChannel");
	__xamarin_class_map [1567].handle = objc_getClass ("AVCaptureOutput");
	__xamarin_class_map [1568].handle = objc_getClass ("AVCaptureAudioDataOutput");
	__xamarin_class_map [1569].handle = objc_getClass ("AVCaptureAudioDataOutputSampleBufferDelegate");
	__xamarin_class_map [1570].handle = objc_getClass ("AVCaptureFileOutput");
	__xamarin_class_map [1571].handle = objc_getClass ("AVCaptureAudioFileOutput");
	__xamarin_class_map [1572].handle = objc_getClass ("AVCaptureAudioPreviewOutput");
	__xamarin_class_map [1573].handle = objc_getClass ("AVCaptureConnection");
	__xamarin_class_map [1574].handle = objc_getClass ("AVCaptureDeviceFormat");
	__xamarin_class_map [1575].handle = objc_getClass ("AVCaptureInput");
	__xamarin_class_map [1576].handle = objc_getClass ("AVCaptureDeviceInput");
	__xamarin_class_map [1577].handle = objc_getClass ("AVCaptureDeviceInputSource");
	__xamarin_class_map [1578].handle = objc_getClass ("AVCaptureFileOutputDelegate");
	__xamarin_class_map [1579].handle = objc_getClass ("AVCaptureFileOutputRecordingDelegate");
	__xamarin_class_map [1580].handle = objc_getClass ("AVCaptureInputPort");
	__xamarin_class_map [1581].handle = objc_getClass ("AVCaptureMovieFileOutput");
	__xamarin_class_map [1582].handle = objc_getClass ("AVCaptureScreenInput");
	__xamarin_class_map [1583].handle = objc_getClass ("AVCaptureSynchronizedData");
	__xamarin_class_map [1584].handle = objc_getClass ("AVCaptureSynchronizedDataCollection");
	__xamarin_class_map [1585].handle = objc_getClass ("AVCaptureVideoDataOutput");
	__xamarin_class_map [1586].handle = objc_getClass ("AVCaptureVideoDataOutputSampleBufferDelegate");
	__xamarin_class_map [1587].handle = objc_getClass ("AVAsset");
	__xamarin_class_map [1588].handle = objc_getClass ("AVComposition");
	__xamarin_class_map [1589].handle = objc_getClass ("AVAssetTrack");
	__xamarin_class_map [1590].handle = objc_getClass ("AVCompositionTrack");
	__xamarin_class_map [1591].handle = objc_getClass ("AVCompositionTrackSegment");
	__xamarin_class_map [1592].handle = objc_getClass ("AVContentKeyResponse");
	__xamarin_class_map [1593].handle = objc_getClass ("AVContentKeySession");
	__xamarin_class_map [1594].handle = objc_getClass ("AVContentKeySessionDelegate");
	__xamarin_class_map [1595].handle = objc_getClass ("AVMetadataGroup");
	__xamarin_class_map [1596].handle = objc_getClass ("AVDateRangeMetadataGroup");
	__xamarin_class_map [1597].handle = objc_getClass ("AVDepthData");
	__xamarin_class_map [1598].handle = objc_getClass ("AVURLAsset");
	__xamarin_class_map [1599].handle = objc_getClass ("AVFragmentedAsset");
	__xamarin_class_map [1600].handle = objc_getClass ("AVFragmentedAssetMinder");
	__xamarin_class_map [1601].handle = objc_getClass ("AVFragmentedAssetTrack");
	__xamarin_class_map [1602].handle = objc_getClass ("AVFragmentedMovieMinder");
	__xamarin_class_map [1603].handle = objc_getClass ("AVFrameRateRange");
	__xamarin_class_map [1604].handle = objc_getClass ("AVMediaDataStorage");
	__xamarin_class_map [1605].handle = objc_getClass ("AVMediaSelection");
	__xamarin_class_map [1606].handle = objc_getClass ("AVMediaSelectionOption");
	__xamarin_class_map [1607].handle = objc_getClass ("AVMetadataObject");
	__xamarin_class_map [1608].handle = objc_getClass ("AVMetadataFaceObject");
	__xamarin_class_map [1609].handle = objc_getClass ("AVMetadataItemFilter");
	__xamarin_class_map [1610].handle = objc_getClass ("AVMetadataItemValueRequest");
	__xamarin_class_map [1611].handle = objc_getClass ("AVMovie");
	__xamarin_class_map [1612].handle = objc_getClass ("AVMovieTrack");
	__xamarin_class_map [1613].handle = objc_getClass ("AVMusicTrack");
	__xamarin_class_map [1614].handle = objc_getClass ("AVMutableAudioMix");
	__xamarin_class_map [1615].handle = objc_getClass ("AVMutableAudioMixInputParameters");
	__xamarin_class_map [1616].handle = objc_getClass ("AVMutableComposition");
	__xamarin_class_map [1617].handle = objc_getClass ("AVMutableCompositionTrack");
	__xamarin_class_map [1618].handle = objc_getClass ("AVMutableDateRangeMetadataGroup");
	__xamarin_class_map [1619].handle = objc_getClass ("AVMutableMediaSelection");
	__xamarin_class_map [1620].handle = objc_getClass ("AVMetadataItem");
	__xamarin_class_map [1621].handle = objc_getClass ("AVMutableMetadataItem");
	__xamarin_class_map [1622].handle = objc_getClass ("AVMutableMovie");
	__xamarin_class_map [1623].handle = objc_getClass ("AVMutableMovieTrack");
	__xamarin_class_map [1624].handle = objc_getClass ("AVTimedMetadataGroup");
	__xamarin_class_map [1625].handle = objc_getClass ("AVMutableTimedMetadataGroup");
	__xamarin_class_map [1626].handle = objc_getClass ("AVVideoComposition");
	__xamarin_class_map [1627].handle = objc_getClass ("AVMutableVideoComposition");
	__xamarin_class_map [1628].handle = objc_getClass ("AVVideoCompositionInstruction");
	__xamarin_class_map [1629].handle = objc_getClass ("AVMutableVideoCompositionInstruction");
	__xamarin_class_map [1630].handle = objc_getClass ("AVVideoCompositionLayerInstruction");
	__xamarin_class_map [1631].handle = objc_getClass ("AVMutableVideoCompositionLayerInstruction");
	__xamarin_class_map [1632].handle = objc_getClass ("AVOutputSettingsAssistant");
	__xamarin_class_map [1633].handle = objc_getClass ("AVContentKeyRequest");
	__xamarin_class_map [1634].handle = objc_getClass ("AVPersistableContentKeyRequest");
	__xamarin_class_map [1635].handle = objc_getClass ("AVPlayerItemAccessLog");
	__xamarin_class_map [1636].handle = objc_getClass ("AVPlayerItemAccessLogEvent");
	__xamarin_class_map [1637].handle = objc_getClass ("AVPlayerItemErrorLog");
	__xamarin_class_map [1638].handle = objc_getClass ("AVPlayerItemErrorLogEvent");
	__xamarin_class_map [1639].handle = objc_getClass ("AVPlayerItemOutput");
	__xamarin_class_map [1640].handle = objc_getClass ("AVPlayerItemLegibleOutput");
	__xamarin_class_map [1641].handle = objc_getClass ("AVPlayerItemOutputPushDelegate");
	__xamarin_class_map [1642].handle = objc_getClass ("AVPlayerItemLegibleOutputPushDelegate");
	__xamarin_class_map [1643].handle = objc_getClass ("AVPlayerItemMediaDataCollector");
	__xamarin_class_map [1644].handle = objc_getClass ("AVPlayerItemMetadataCollector");
	__xamarin_class_map [1645].handle = objc_getClass ("AVPlayerItemMetadataCollectorPushDelegate");
	__xamarin_class_map [1646].handle = objc_getClass ("AVPlayerItemMetadataOutput");
	__xamarin_class_map [1647].handle = objc_getClass ("AVPlayerItemMetadataOutputPushDelegate");
	__xamarin_class_map [1648].handle = objc_getClass ("AVPlayerItemOutputPullDelegate");
	__xamarin_class_map [1649].handle = objc_getClass ("AVPlayerItemTrack");
	__xamarin_class_map [1650].handle = objc_getClass ("AVPlayerLayer");
	__xamarin_class_map [1651].handle = objc_getClass ("AVPlayerLooper");
	__xamarin_class_map [1652].handle = objc_getClass ("AVPlayerMediaSelectionCriteria");
	__xamarin_class_map [1653].handle = objc_getClass ("AVPortraitEffectsMatte");
	__xamarin_class_map [1654].handle = objc_getClass ("AVPlayer");
	__xamarin_class_map [1655].handle = objc_getClass ("AVQueuePlayer");
	__xamarin_class_map [1656].handle = objc_getClass ("AVSampleBufferRequest");
	__xamarin_class_map [1657].handle = objc_getClass ("AVSampleCursor");
	__xamarin_class_map [1658].handle = objc_getClass ("AVSynchronizedLayer");
	__xamarin_class_map [1659].handle = objc_getClass ("AVTextStyleRule");
	__xamarin_class_map [1660].handle = objc_getClass ("AVVideoCompositing");
	__xamarin_class_map [1661].handle = objc_getClass ("AVVideoCompositionCoreAnimationTool");
	__xamarin_class_map [1662].handle = objc_getClass ("AVVideoCompositionRenderContext");
	__xamarin_class_map [1663].handle = objc_getClass ("AVVideoCompositionValidationHandling");
	__xamarin_class_map [1664].handle = objc_getClass ("AVFoundation_AVCaptureDataOutputSynchronizer");
	__xamarin_class_map [1665].handle = objc_getClass ("AVFoundation_AVCaptureDataOutputSynchronizerDelegate");
	__xamarin_class_map [1666].handle = objc_getClass ("AVFoundation_InternalAVAudioPlayerDelegate");
	__xamarin_class_map [1667].handle = objc_getClass ("AVFoundation_InternalAVAudioRecorderDelegate");
	__xamarin_class_map [1668].handle = objc_getClass ("AUAudioUnitBus");
	__xamarin_class_map [1669].handle = objc_getClass ("AUAudioUnitBusArray");
	__xamarin_class_map [1670].handle = objc_getClass ("AUAudioUnitPreset");
	__xamarin_class_map [1671].handle = objc_getClass ("AUParameterNode");
	__xamarin_class_map [1672].handle = objc_getClass ("AUParameter");
	__xamarin_class_map [1673].handle = objc_getClass ("AUParameterGroup");
	__xamarin_class_map [1674].handle = objc_getClass ("AUParameterTree");
	__xamarin_class_map [1675].handle = objc_getClass ("NSAccessibilityCustomAction");
	__xamarin_class_map [1676].handle = objc_getClass ("NSAccessibilityCustomRotor");
	__xamarin_class_map [1677].handle = objc_getClass ("NSAccessibilityCustomRotorItemResult");
	__xamarin_class_map [1678].handle = objc_getClass ("NSAccessibilityCustomRotorItemSearchDelegate");
	__xamarin_class_map [1679].handle = objc_getClass ("NSAccessibilityCustomRotorSearchParameters");
	__xamarin_class_map [1680].handle = objc_getClass ("NSCell");
	__xamarin_class_map [1681].handle = objc_getClass ("NSActionCell");
	__xamarin_class_map [1682].handle = objc_getClass ("NSAlertDelegate");
	__xamarin_class_map [1683].handle = objc_getClass ("NSAlignmentFeedbackFilter");
	__xamarin_class_map [1684].handle = objc_getClass ("NSAlignmentFeedbackToken");
	__xamarin_class_map [1685].handle = objc_getClass ("NSAnimationContext");
	__xamarin_class_map [1686].handle = objc_getClass ("NSAnimationDelegate");
	__xamarin_class_map [1687].handle = objc_getClass ("NSAppearance");
	__xamarin_class_map [1688].handle = objc_getClass ("NSAppearanceCustomization");
	__xamarin_class_map [1689].handle = objc_getClass ("NSApplicationDelegate");
	__xamarin_class_map [1690].handle = objc_getClass ("NSController");
	__xamarin_class_map [1691].handle = objc_getClass ("NSObjectController");
	__xamarin_class_map [1692].handle = objc_getClass ("NSArrayController");
	__xamarin_class_map [1693].handle = objc_getClass ("NSTypesetter");
	__xamarin_class_map [1694].handle = objc_getClass ("NSATSTypesetter");
	__xamarin_class_map [1695].handle = objc_getClass ("NSBezierPath");
	__xamarin_class_map [1696].handle = objc_getClass ("NSImageRep");
	__xamarin_class_map [1697].handle = objc_getClass ("NSBitmapImageRep");
	__xamarin_class_map [1698].handle = objc_getClass ("NSBox");
	__xamarin_class_map [1699].handle = objc_getClass ("NSBrowserCell");
	__xamarin_class_map [1700].handle = objc_getClass ("NSBrowserDelegate");
	__xamarin_class_map [1701].handle = objc_getClass ("NSButton");
	__xamarin_class_map [1702].handle = objc_getClass ("NSButtonCell");
	__xamarin_class_map [1703].handle = objc_getClass ("NSCachedImageRep");
	__xamarin_class_map [1704].handle = objc_getClass ("NSTouchBarItem");
	__xamarin_class_map [1705].handle = objc_getClass ("NSCandidateListTouchBarItem");
	__xamarin_class_map [1706].handle = objc_getClass ("NSCandidateListTouchBarItemDelegate");
	__xamarin_class_map [1707].handle = objc_getClass ("NSCIImageRep");
	__xamarin_class_map [1708].handle = objc_getClass ("NSClipView");
	__xamarin_class_map [1709].handle = objc_getClass ("NSSharingServiceDelegate");
	__xamarin_class_map [1710].handle = objc_getClass ("NSCloudSharingServiceDelegate");
	__xamarin_class_map [1711].handle = objc_getClass ("NSCollectionView");
	__xamarin_class_map [1712].handle = objc_getClass ("NSCollectionViewDataSource");
	__xamarin_class_map [1713].handle = objc_getClass ("NSCollectionViewDelegate");
	__xamarin_class_map [1714].handle = objc_getClass ("NSCollectionViewDelegateFlowLayout");
	__xamarin_class_map [1715].handle = objc_getClass ("NSCollectionViewElement");
	__xamarin_class_map [1716].handle = objc_getClass ("NSCollectionViewLayout");
	__xamarin_class_map [1717].handle = objc_getClass ("NSCollectionViewFlowLayout");
	__xamarin_class_map [1718].handle = objc_getClass ("NSCollectionViewLayoutInvalidationContext");
	__xamarin_class_map [1719].handle = objc_getClass ("NSCollectionViewFlowLayoutInvalidationContext");
	__xamarin_class_map [1720].handle = objc_getClass ("NSCollectionViewGridLayout");
	__xamarin_class_map [1721].handle = objc_getClass ("NSCollectionViewItem");
	__xamarin_class_map [1722].handle = objc_getClass ("NSCollectionViewLayoutAttributes");
	__xamarin_class_map [1723].handle = objc_getClass ("NSCollectionViewTransitionLayout");
	__xamarin_class_map [1724].handle = objc_getClass ("NSCollectionViewUpdateItem");
	__xamarin_class_map [1725].handle = objc_getClass ("NSColorList");
	__xamarin_class_map [1726].handle = objc_getClass ("NSColorPicker");
	__xamarin_class_map [1727].handle = objc_getClass ("NSColorPickerTouchBarItem");
	__xamarin_class_map [1728].handle = objc_getClass ("NSColorSpace");
	__xamarin_class_map [1729].handle = objc_getClass ("NSColorWell");
	__xamarin_class_map [1730].handle = objc_getClass ("NSTextFieldCell");
	__xamarin_class_map [1731].handle = objc_getClass ("NSComboBoxCell");
	__xamarin_class_map [1732].handle = objc_getClass ("NSComboBoxCellDataSource");
	__xamarin_class_map [1733].handle = objc_getClass ("NSComboBoxDataSource");
	__xamarin_class_map [1734].handle = objc_getClass ("NSTextFieldDelegate");
	__xamarin_class_map [1735].handle = objc_getClass ("NSComboBoxDelegate");
	__xamarin_class_map [1736].handle = objc_getClass ("NSControlTextEditingDelegate");
	__xamarin_class_map [1737].handle = objc_getClass ("NSCursor");
	__xamarin_class_map [1738].handle = objc_getClass ("NSCustomImageRep");
	__xamarin_class_map [1739].handle = objc_getClass ("NSCustomTouchBarItem");
	__xamarin_class_map [1740].handle = objc_getClass ("NSDataAsset");
	__xamarin_class_map [1741].handle = objc_getClass ("NSDatePickerCellDelegate");
	__xamarin_class_map [1742].handle = objc_getClass ("NSDictionaryController");
	__xamarin_class_map [1743].handle = objc_getClass ("NSDictionaryControllerKeyValuePair");
	__xamarin_class_map [1744].handle = objc_getClass ("NSDockTile");
	__xamarin_class_map [1745].handle = objc_getClass ("NSDockTilePlugIn");
	__xamarin_class_map [1746].handle = objc_getClass ("NSDocumentController");
	__xamarin_class_map [1747].handle = objc_getClass ("NSDraggingDestination");
	__xamarin_class_map [1748].handle = objc_getClass ("NSDraggingImageComponent");
	__xamarin_class_map [1749].handle = objc_getClass ("NSDraggingItem");
	__xamarin_class_map [1750].handle = objc_getClass ("NSDraggingSession");
	__xamarin_class_map [1751].handle = objc_getClass ("NSDraggingSource");
	__xamarin_class_map [1752].handle = objc_getClass ("NSDrawerDelegate");
	__xamarin_class_map [1753].handle = objc_getClass ("NSEPSImageRep");
	__xamarin_class_map [1754].handle = objc_getClass ("NSFilePromiseProvider");
	__xamarin_class_map [1755].handle = objc_getClass ("NSFilePromiseReceiver");
	__xamarin_class_map [1756].handle = objc_getClass ("NSFontAssetRequest");
	__xamarin_class_map [1757].handle = objc_getClass ("NSFontDescriptor");
	__xamarin_class_map [1758].handle = objc_getClass ("NSFontManager");
	__xamarin_class_map [1759].handle = objc_getClass ("NSFontPanel");
	__xamarin_class_map [1760].handle = objc_getClass ("NSMatrix");
	__xamarin_class_map [1761].handle = objc_getClass ("NSForm");
	__xamarin_class_map [1762].handle = objc_getClass ("NSFormCell");
	__xamarin_class_map [1763].handle = objc_getClass ("NSGestureRecognizerDelegate");
	__xamarin_class_map [1764].handle = objc_getClass ("NSGlyphGenerator");
	__xamarin_class_map [1765].handle = objc_getClass ("NSGlyphInfo");
	__xamarin_class_map [1766].handle = objc_getClass ("NSGraphicsContext");
	__xamarin_class_map [1767].handle = objc_getClass ("NSGridCell");
	__xamarin_class_map [1768].handle = objc_getClass ("NSGridColumn");
	__xamarin_class_map [1769].handle = objc_getClass ("NSGridRow");
	__xamarin_class_map [1770].handle = objc_getClass ("NSGridView");
	__xamarin_class_map [1771].handle = objc_getClass ("NSGroupTouchBarItem");
	__xamarin_class_map [1772].handle = objc_getClass ("NSHapticFeedbackManager");
	__xamarin_class_map [1773].handle = objc_getClass ("NSHapticFeedbackPerformer");
	__xamarin_class_map [1774].handle = objc_getClass ("NSImageCell");
	__xamarin_class_map [1775].handle = objc_getClass ("NSImageDelegate");
	__xamarin_class_map [1776].handle = objc_getClass ("NSImageView");
	__xamarin_class_map [1777].handle = objc_getClass ("NSLayoutAnchor");
	__xamarin_class_map [1778].handle = objc_getClass ("NSLayoutConstraint");
	__xamarin_class_map [1779].handle = objc_getClass ("NSLayoutDimension");
	__xamarin_class_map [1780].handle = objc_getClass ("NSLayoutGuide");
	__xamarin_class_map [1781].handle = objc_getClass ("NSLayoutManager");
	__xamarin_class_map [1782].handle = objc_getClass ("NSLayoutManagerDelegate");
	__xamarin_class_map [1783].handle = objc_getClass ("NSLayoutXAxisAnchor");
	__xamarin_class_map [1784].handle = objc_getClass ("NSLayoutYAxisAnchor");
	__xamarin_class_map [1785].handle = objc_getClass ("NSLevelIndicator");
	__xamarin_class_map [1786].handle = objc_getClass ("NSLevelIndicatorCell");
	__xamarin_class_map [1787].handle = objc_getClass ("NSMatrixDelegate");
	__xamarin_class_map [1788].handle = objc_getClass ("NSMenuDelegate");
	__xamarin_class_map [1789].handle = objc_getClass ("NSMenuItemCell");
	__xamarin_class_map [1790].handle = objc_getClass ("NSMenuView");
	__xamarin_class_map [1791].handle = objc_getClass ("NSFontCollection");
	__xamarin_class_map [1792].handle = objc_getClass ("NSMutableFontCollection");
	__xamarin_class_map [1793].handle = objc_getClass ("NSParagraphStyle");
	__xamarin_class_map [1794].handle = objc_getClass ("NSMutableParagraphStyle");
	__xamarin_class_map [1795].handle = objc_getClass ("NSNib");
	__xamarin_class_map [1796].handle = objc_getClass ("NSOpenGLContext");
	__xamarin_class_map [1797].handle = objc_getClass ("NSOpenGLLayer");
	__xamarin_class_map [1798].handle = objc_getClass ("NSOpenGLPixelBuffer");
	__xamarin_class_map [1799].handle = objc_getClass ("NSOpenGLPixelFormat");
	__xamarin_class_map [1800].handle = objc_getClass ("NSOpenGLView");
	__xamarin_class_map [1801].handle = objc_getClass ("NSSavePanel");
	__xamarin_class_map [1802].handle = objc_getClass ("NSOpenPanel");
	__xamarin_class_map [1803].handle = objc_getClass ("NSOpenSavePanelDelegate");
	__xamarin_class_map [1804].handle = objc_getClass ("NSOutlineViewDataSource");
	__xamarin_class_map [1805].handle = objc_getClass ("NSOutlineViewDelegate");
	__xamarin_class_map [1806].handle = objc_getClass ("NSPageControllerDelegate");
	__xamarin_class_map [1807].handle = objc_getClass ("NSPageLayout");
	__xamarin_class_map [1808].handle = objc_getClass ("NSPasteboard");
	__xamarin_class_map [1809].handle = objc_getClass ("NSPasteboardItem");
	__xamarin_class_map [1810].handle = objc_getClass ("NSPasteboardItemDataProvider");
	__xamarin_class_map [1811].handle = objc_getClass ("NSPasteboardReading");
	__xamarin_class_map [1812].handle = objc_getClass ("NSPasteboardWriting");
	__xamarin_class_map [1813].handle = objc_getClass ("NSPathCellDelegate");
	__xamarin_class_map [1814].handle = objc_getClass ("NSPathComponentCell");
	__xamarin_class_map [1815].handle = objc_getClass ("NSPathControl");
	__xamarin_class_map [1816].handle = objc_getClass ("NSPathControlDelegate");
	__xamarin_class_map [1817].handle = objc_getClass ("NSPathControlItem");
	__xamarin_class_map [1818].handle = objc_getClass ("NSPDFImageRep");
	__xamarin_class_map [1819].handle = objc_getClass ("NSPopoverDelegate");
	__xamarin_class_map [1820].handle = objc_getClass ("NSPopoverTouchBarItem");
	__xamarin_class_map [1821].handle = objc_getClass ("NSRuleEditor");
	__xamarin_class_map [1822].handle = objc_getClass ("NSPredicateEditor");
	__xamarin_class_map [1823].handle = objc_getClass ("NSPressureConfiguration");
	__xamarin_class_map [1824].handle = objc_getClass ("NSPrinter");
	__xamarin_class_map [1825].handle = objc_getClass ("NSPrintInfo");
	__xamarin_class_map [1826].handle = objc_getClass ("NSPrintOperation");
	__xamarin_class_map [1827].handle = objc_getClass ("NSPrintPanel");
	__xamarin_class_map [1828].handle = objc_getClass ("NSPrintPanelAccessorizing");
	__xamarin_class_map [1829].handle = objc_getClass ("NSPrintPreviewGraphicsContext");
	__xamarin_class_map [1830].handle = objc_getClass ("NSProgressIndicator");
	__xamarin_class_map [1831].handle = objc_getClass ("NSRemoteOpenPanel");
	__xamarin_class_map [1832].handle = objc_getClass ("NSRemoteSavePanel");
	__xamarin_class_map [1833].handle = objc_getClass ("NSRuleEditorDelegate");
	__xamarin_class_map [1834].handle = objc_getClass ("NSRulerMarker");
	__xamarin_class_map [1835].handle = objc_getClass ("NSRulerView");
	__xamarin_class_map [1836].handle = objc_getClass ("NSRunningApplication");
	__xamarin_class_map [1837].handle = objc_getClass ("NSScrubber");
	__xamarin_class_map [1838].handle = objc_getClass ("NSScrubberArrangedView");
	__xamarin_class_map [1839].handle = objc_getClass ("NSScrubberDataSource");
	__xamarin_class_map [1840].handle = objc_getClass ("NSScrubberDelegate");
	__xamarin_class_map [1841].handle = objc_getClass ("NSScrubberLayout");
	__xamarin_class_map [1842].handle = objc_getClass ("NSScrubberFlowLayout");
	__xamarin_class_map [1843].handle = objc_getClass ("NSScrubberFlowLayoutDelegate");
	__xamarin_class_map [1844].handle = objc_getClass ("NSScrubberItemView");
	__xamarin_class_map [1845].handle = objc_getClass ("NSScrubberImageItemView");
	__xamarin_class_map [1846].handle = objc_getClass ("NSScrubberLayoutAttributes");
	__xamarin_class_map [1847].handle = objc_getClass ("NSScrubberProportionalLayout");
	__xamarin_class_map [1848].handle = objc_getClass ("NSScrubberSelectionStyle");
	__xamarin_class_map [1849].handle = objc_getClass ("NSScrubberSelectionView");
	__xamarin_class_map [1850].handle = objc_getClass ("NSScrubberTextItemView");
	__xamarin_class_map [1851].handle = objc_getClass ("NSSearchFieldCell");
	__xamarin_class_map [1852].handle = objc_getClass ("NSSearchFieldDelegate");
	__xamarin_class_map [1853].handle = objc_getClass ("NSTextField");
	__xamarin_class_map [1854].handle = objc_getClass ("NSSecureTextField");
	__xamarin_class_map [1855].handle = objc_getClass ("NSSecureTextFieldCell");
	__xamarin_class_map [1856].handle = objc_getClass ("NSSegmentedCell");
	__xamarin_class_map [1857].handle = objc_getClass ("NSSegmentedControl");
	__xamarin_class_map [1858].handle = objc_getClass ("NSSeguePerforming");
	__xamarin_class_map [1859].handle = objc_getClass ("NSShadow");
	__xamarin_class_map [1860].handle = objc_getClass ("NSSharingServicePickerDelegate");
	__xamarin_class_map [1861].handle = objc_getClass ("NSSharingServicePickerTouchBarItem");
	__xamarin_class_map [1862].handle = objc_getClass ("NSSharingServicePickerTouchBarItemDelegate");
	__xamarin_class_map [1863].handle = objc_getClass ("NSSlider");
	__xamarin_class_map [1864].handle = objc_getClass ("NSSliderAccessoryBehavior");
	__xamarin_class_map [1865].handle = objc_getClass ("NSSliderCell");
	__xamarin_class_map [1866].handle = objc_getClass ("NSSliderTouchBarItem");
	__xamarin_class_map [1867].handle = objc_getClass ("NSSoundDelegate");
	__xamarin_class_map [1868].handle = objc_getClass ("NSSpeechRecognizer");
	__xamarin_class_map [1869].handle = objc_getClass ("NSSpeechRecognizerDelegate");
	__xamarin_class_map [1870].handle = objc_getClass ("NSSpeechSynthesizer");
	__xamarin_class_map [1871].handle = objc_getClass ("NSSpeechSynthesizerDelegate");
	__xamarin_class_map [1872].handle = objc_getClass ("NSSplitViewController");
	__xamarin_class_map [1873].handle = objc_getClass ("NSSplitViewDelegate");
	__xamarin_class_map [1874].handle = objc_getClass ("NSSplitViewItem");
	__xamarin_class_map [1875].handle = objc_getClass ("NSSpringLoadingDestination");
	__xamarin_class_map [1876].handle = objc_getClass ("NSStackView");
	__xamarin_class_map [1877].handle = objc_getClass ("NSStackViewDelegate");
	__xamarin_class_map [1878].handle = objc_getClass ("NSStatusBar");
	__xamarin_class_map [1879].handle = objc_getClass ("NSStatusBarButton");
	__xamarin_class_map [1880].handle = objc_getClass ("NSStatusItem");
	__xamarin_class_map [1881].handle = objc_getClass ("NSStepper");
	__xamarin_class_map [1882].handle = objc_getClass ("NSStepperCell");
	__xamarin_class_map [1883].handle = objc_getClass ("NSStoryboard");
	__xamarin_class_map [1884].handle = objc_getClass ("NSStoryboardSegue");
	__xamarin_class_map [1885].handle = objc_getClass ("NSStringDrawingContext");
	__xamarin_class_map [1886].handle = objc_getClass ("NSTableCellView");
	__xamarin_class_map [1887].handle = objc_getClass ("NSTableColumn");
	__xamarin_class_map [1888].handle = objc_getClass ("NSTableHeaderCell");
	__xamarin_class_map [1889].handle = objc_getClass ("NSTableHeaderView");
	__xamarin_class_map [1890].handle = objc_getClass ("NSTableRowView");
	__xamarin_class_map [1891].handle = objc_getClass ("NSTableViewDataSource");
	__xamarin_class_map [1892].handle = objc_getClass ("NSTableViewDelegate");
	__xamarin_class_map [1893].handle = objc_getClass ("NSTableViewRowAction");
	__xamarin_class_map [1894].handle = objc_getClass ("NSTableViewSource");
	__xamarin_class_map [1895].handle = objc_getClass ("NSTabViewController");
	__xamarin_class_map [1896].handle = objc_getClass ("NSTabViewDelegate");
	__xamarin_class_map [1897].handle = objc_getClass ("NSTabViewItem");
	__xamarin_class_map [1898].handle = objc_getClass ("NSTextAttachment");
	__xamarin_class_map [1899].handle = objc_getClass ("NSTextAttachmentCell");
	__xamarin_class_map [1900].handle = objc_getClass ("NSTextAttachmentContainer");
	__xamarin_class_map [1901].handle = objc_getClass ("NSTextBlock");
	__xamarin_class_map [1902].handle = objc_getClass ("NSTextContainer");
	__xamarin_class_map [1903].handle = objc_getClass ("NSTextDelegate");
	__xamarin_class_map [1904].handle = objc_getClass ("NSTextFinder");
	__xamarin_class_map [1905].handle = objc_getClass ("NSTextFinderBarContainer");
	__xamarin_class_map [1906].handle = objc_getClass ("NSTextFinderClient");
	__xamarin_class_map [1907].handle = objc_getClass ("NSTextInputClient");
	__xamarin_class_map [1908].handle = objc_getClass ("NSTextList");
	__xamarin_class_map [1909].handle = objc_getClass ("NSTextStorageDelegate");
	__xamarin_class_map [1910].handle = objc_getClass ("NSTextTab");
	__xamarin_class_map [1911].handle = objc_getClass ("NSTextTable");
	__xamarin_class_map [1912].handle = objc_getClass ("NSTextTableBlock");
	__xamarin_class_map [1913].handle = objc_getClass ("NSTextViewDelegate");
	__xamarin_class_map [1914].handle = objc_getClass ("NSTitlebarAccessoryViewController");
	__xamarin_class_map [1915].handle = objc_getClass ("NSTokenField");
	__xamarin_class_map [1916].handle = objc_getClass ("NSTokenFieldCell");
	__xamarin_class_map [1917].handle = objc_getClass ("NSTokenFieldCellDelegate");
	__xamarin_class_map [1918].handle = objc_getClass ("NSTokenFieldDelegate");
	__xamarin_class_map [1919].handle = objc_getClass ("NSToolbarDelegate");
	__xamarin_class_map [1920].handle = objc_getClass ("NSToolbarItem");
	__xamarin_class_map [1921].handle = objc_getClass ("NSToolbarItemGroup");
	__xamarin_class_map [1922].handle = objc_getClass ("NSTouch");
	__xamarin_class_map [1923].handle = objc_getClass ("NSTouchBarDelegate");
	__xamarin_class_map [1924].handle = objc_getClass ("NSTrackingArea");
	__xamarin_class_map [1925].handle = objc_getClass ("NSTreeController");
	__xamarin_class_map [1926].handle = objc_getClass ("NSTreeNode");
	__xamarin_class_map [1927].handle = objc_getClass ("NSUserDefaultsController");
	__xamarin_class_map [1928].handle = objc_getClass ("NSUserInterfaceCompressionOptions");
	__xamarin_class_map [1929].handle = objc_getClass ("NSAnimation");
	__xamarin_class_map [1930].handle = objc_getClass ("NSViewAnimation");
	__xamarin_class_map [1931].handle = objc_getClass ("NSViewControllerPresentationAnimator");
	__xamarin_class_map [1932].handle = objc_getClass ("NSVisualEffectView");
	__xamarin_class_map [1933].handle = objc_getClass ("NSWindowDelegate");
	__xamarin_class_map [1934].handle = objc_getClass ("NSWindowRestoration");
	__xamarin_class_map [1935].handle = objc_getClass ("NSWindowTab");
	__xamarin_class_map [1936].handle = objc_getClass ("NSWindowTabGroup");
	__xamarin_class_map [1937].handle = objc_getClass ("NSWorkspaceAuthorization");
	__xamarin_class_map [1938].handle = objc_getClass ("__monomac_internal_ActionDispatcher");
	__xamarin_class_map [1939].handle = objc_getClass ("__MonoMac_NSAlertDidEndDispatcher");
	__xamarin_class_map [1940].handle = objc_getClass ("ASIdentifierManager");
	__xamarin_class_map [1941].handle = objc_getClass ("ACAccount");
	__xamarin_class_map [1942].handle = objc_getClass ("ACAccountCredential");
	__xamarin_class_map [1943].handle = objc_getClass ("ACAccountType");
	__xamarin_class_map [1944].handle = objc_getClass ("NSAffineTransform");
	__xamarin_class_map [1945].handle = objc_getClass ("NSAppleEventDescriptor");
	__xamarin_class_map [1946].handle = objc_getClass ("NSAppleEventManager");
	__xamarin_class_map [1947].handle = objc_getClass ("NSAppleScript");
	__xamarin_class_map [1948].handle = objc_getClass ("NSAttributedString");
	__xamarin_class_map [1949].handle = objc_getClass ("NSBindingSelectionMarker");
	__xamarin_class_map [1950].handle = objc_getClass ("NSBlockOperation");
	__xamarin_class_map [1951].handle = objc_getClass ("NSBundle");
	__xamarin_class_map [1952].handle = objc_getClass ("NSByteCountFormatter");
	__xamarin_class_map [1953].handle = objc_getClass ("NSCacheDelegate");
	__xamarin_class_map [1954].handle = objc_getClass ("NSCachedURLResponse");
	__xamarin_class_map [1955].handle = objc_getClass ("NSDate");
	__xamarin_class_map [1956].handle = objc_getClass ("NSCalendarDate");
	__xamarin_class_map [1957].handle = objc_getClass ("NSCharacterSet");
	__xamarin_class_map [1958].handle = objc_getClass ("NSCoder");
	__xamarin_class_map [1959].handle = objc_getClass ("NSCoding");
	__xamarin_class_map [1960].handle = objc_getClass ("NSPredicate");
	__xamarin_class_map [1961].handle = objc_getClass ("NSComparisonPredicate");
	__xamarin_class_map [1962].handle = objc_getClass ("NSCompoundPredicate");
	__xamarin_class_map [1963].handle = objc_getClass ("NSCondition");
	__xamarin_class_map [1964].handle = objc_getClass ("NSConditionLock");
	__xamarin_class_map [1965].handle = objc_getClass ("NSConnection");
	__xamarin_class_map [1966].handle = objc_getClass ("NSConnectionDelegate");
	__xamarin_class_map [1967].handle = objc_getClass ("NSCopying");
	__xamarin_class_map [1968].handle = objc_getClass ("NSRegularExpression");
	__xamarin_class_map [1969].handle = objc_getClass ("NSDataDetector");
	__xamarin_class_map [1970].handle = objc_getClass ("NSDateComponents");
	__xamarin_class_map [1971].handle = objc_getClass ("NSDateComponentsFormatter");
	__xamarin_class_map [1972].handle = objc_getClass ("NSDateFormatter");
	__xamarin_class_map [1973].handle = objc_getClass ("NSDateInterval");
	__xamarin_class_map [1974].handle = objc_getClass ("NSDateIntervalFormatter");
	__xamarin_class_map [1975].handle = objc_getClass ("NSValue");
	__xamarin_class_map [1976].handle = objc_getClass ("NSNumber");
	__xamarin_class_map [1977].handle = objc_getClass ("NSDecimalNumber");
	__xamarin_class_map [1978].handle = objc_getClass ("NSUnit");
	__xamarin_class_map [1979].handle = objc_getClass ("NSDimension");
	__xamarin_class_map [1980].handle = objc_getClass ("NSEnumerator");
	__xamarin_class_map [1981].handle = objc_getClass ("NSDirectoryEnumerator");
	__xamarin_class_map [1982].handle = objc_getClass ("NSDistantObjectRequest");
	__xamarin_class_map [1983].handle = objc_getClass ("NSDistributedLock");
	__xamarin_class_map [1984].handle = objc_getClass ("NSNotificationCenter");
	__xamarin_class_map [1985].handle = objc_getClass ("NSDistributedNotificationCenter");
	__xamarin_class_map [1986].handle = objc_getClass ("NSEnergyFormatter");
	__xamarin_class_map [1987].handle = objc_getClass ("NSError");
	__xamarin_class_map [1988].handle = objc_getClass ("NSException");
	__xamarin_class_map [1989].handle = objc_getClass ("NSExtensionItem");
	__xamarin_class_map [1990].handle = objc_getClass ("NSExtensionRequestHandling");
	__xamarin_class_map [1991].handle = objc_getClass ("NSFileAccessIntent");
	__xamarin_class_map [1992].handle = objc_getClass ("NSFileCoordinator");
	__xamarin_class_map [1993].handle = objc_getClass ("NSFileManagerDelegate");
	__xamarin_class_map [1994].handle = objc_getClass ("NSFilePresenter");
	__xamarin_class_map [1995].handle = objc_getClass ("NSFileProviderService");
	__xamarin_class_map [1996].handle = objc_getClass ("NSFileWrapper");
	__xamarin_class_map [1997].handle = objc_getClass ("NSHTTPCookie");
	__xamarin_class_map [1998].handle = objc_getClass ("NSURLResponse");
	__xamarin_class_map [1999].handle = objc_getClass ("NSHTTPURLResponse");
	__xamarin_class_map [2000].handle = objc_getClass ("NSStream");
	__xamarin_class_map [2001].handle = objc_getClass ("NSInputStream");
	__xamarin_class_map [2002].handle = objc_getClass ("NSInvocation");
	__xamarin_class_map [2003].handle = objc_getClass ("NSISO8601DateFormatter");
	__xamarin_class_map [2004].handle = objc_getClass ("NSJSONSerialization");
	__xamarin_class_map [2005].handle = objc_getClass ("NSKeyedArchiverDelegate");
	__xamarin_class_map [2006].handle = objc_getClass ("NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2007].handle = objc_getClass ("NSLengthFormatter");
	__xamarin_class_map [2008].handle = objc_getClass ("NSLinguisticTagger");
	__xamarin_class_map [2009].handle = objc_getClass ("NSLock");
	__xamarin_class_map [2010].handle = objc_getClass ("NSPort");
	__xamarin_class_map [2011].handle = objc_getClass ("NSMachPort");
	__xamarin_class_map [2012].handle = objc_getClass ("NSPortDelegate");
	__xamarin_class_map [2013].handle = objc_getClass ("NSMachPortDelegate");
	__xamarin_class_map [2014].handle = objc_getClass ("NSMassFormatter");
	__xamarin_class_map [2015].handle = objc_getClass ("NSMeasurement");
	__xamarin_class_map [2016].handle = objc_getClass ("NSMeasurementFormatter");
	__xamarin_class_map [2017].handle = objc_getClass ("NSMetadataItem");
	__xamarin_class_map [2018].handle = objc_getClass ("NSMetadataQueryAttributeValueTuple");
	__xamarin_class_map [2019].handle = objc_getClass ("NSMetadataQueryDelegate");
	__xamarin_class_map [2020].handle = objc_getClass ("NSMetadataQueryResultGroup");
	__xamarin_class_map [2021].handle = objc_getClass ("NSMethodSignature");
	__xamarin_class_map [2022].handle = objc_getClass ("NSMutableAttributedString");
	__xamarin_class_map [2023].handle = objc_getClass ("NSMutableCharacterSet");
	__xamarin_class_map [2024].handle = objc_getClass ("NSMutableCopying");
	__xamarin_class_map [2025].handle = objc_getClass ("NSIndexSet");
	__xamarin_class_map [2026].handle = objc_getClass ("NSMutableIndexSet");
	__xamarin_class_map [2027].handle = objc_getClass ("NSOrderedSet");
	__xamarin_class_map [2028].handle = objc_getClass ("NSMutableOrderedSet");
	__xamarin_class_map [2029].handle = objc_getClass ("NSSet");
	__xamarin_class_map [2030].handle = objc_getClass ("NSMutableSet");
	__xamarin_class_map [2031].handle = objc_getClass ("NSMutableString");
	__xamarin_class_map [2032].handle = objc_getClass ("NSURLRequest");
	__xamarin_class_map [2033].handle = objc_getClass ("NSMutableURLRequest");
	__xamarin_class_map [2034].handle = objc_getClass ("NSNetServiceBrowserDelegate");
	__xamarin_class_map [2035].handle = objc_getClass ("NSNetServiceDelegate");
	__xamarin_class_map [2036].handle = objc_getClass ("NSNotification");
	__xamarin_class_map [2037].handle = objc_getClass ("NSNotificationQueue");
	__xamarin_class_map [2038].handle = objc_getClass ("NSNull");
	__xamarin_class_map [2039].handle = objc_getClass ("NSNumberFormatter");
	__xamarin_class_map [2040].handle = objc_getClass ("NSOperationQueue");
	__xamarin_class_map [2041].handle = objc_getClass ("NSOrthography");
	__xamarin_class_map [2042].handle = objc_getClass ("NSOutputStream");
	__xamarin_class_map [2043].handle = objc_getClass ("NSPersonNameComponents");
	__xamarin_class_map [2044].handle = objc_getClass ("NSPersonNameComponentsFormatter");
	__xamarin_class_map [2045].handle = objc_getClass ("NSPipe");
	__xamarin_class_map [2046].handle = objc_getClass ("NSPortMessage");
	__xamarin_class_map [2047].handle = objc_getClass ("NSPortNameServer");
	__xamarin_class_map [2048].handle = objc_getClass ("NSPropertyListSerialization");
	__xamarin_class_map [2049].handle = objc_getClass ("NSData");
	__xamarin_class_map [2050].handle = objc_getClass ("NSMutableData");
	__xamarin_class_map [2051].handle = objc_getClass ("NSPurgeableData");
	__xamarin_class_map [2052].handle = objc_getClass ("NSRecursiveLock");
	__xamarin_class_map [2053].handle = objc_getClass ("NSRunLoop");
	__xamarin_class_map [2054].handle = objc_getClass ("NSScriptCommand");
	__xamarin_class_map [2055].handle = objc_getClass ("NSScriptCommandDescription");
	__xamarin_class_map [2056].handle = objc_getClass ("NSStreamDelegate");
	__xamarin_class_map [2057].handle = objc_getClass ("NSTextCheckingResult");
	__xamarin_class_map [2058].handle = objc_getClass ("NSTimer");
	__xamarin_class_map [2059].handle = objc_getClass ("NSTimeZone");
	__xamarin_class_map [2060].handle = objc_getClass ("NSUnitAcceleration");
	__xamarin_class_map [2061].handle = objc_getClass ("NSUnitAngle");
	__xamarin_class_map [2062].handle = objc_getClass ("NSUnitArea");
	__xamarin_class_map [2063].handle = objc_getClass ("NSUnitConcentrationMass");
	__xamarin_class_map [2064].handle = objc_getClass ("NSUnitConverter");
	__xamarin_class_map [2065].handle = objc_getClass ("NSUnitConverterLinear");
	__xamarin_class_map [2066].handle = objc_getClass ("NSUnitDispersion");
	__xamarin_class_map [2067].handle = objc_getClass ("NSUnitDuration");
	__xamarin_class_map [2068].handle = objc_getClass ("NSUnitElectricCharge");
	__xamarin_class_map [2069].handle = objc_getClass ("NSUnitElectricCurrent");
	__xamarin_class_map [2070].handle = objc_getClass ("NSUnitElectricPotentialDifference");
	__xamarin_class_map [2071].handle = objc_getClass ("NSUnitElectricResistance");
	__xamarin_class_map [2072].handle = objc_getClass ("NSUnitEnergy");
	__xamarin_class_map [2073].handle = objc_getClass ("NSUnitFrequency");
	__xamarin_class_map [2074].handle = objc_getClass ("NSUnitFuelEfficiency");
	__xamarin_class_map [2075].handle = objc_getClass ("NSUnitIlluminance");
	__xamarin_class_map [2076].handle = objc_getClass ("NSUnitLength");
	__xamarin_class_map [2077].handle = objc_getClass ("NSUnitMass");
	__xamarin_class_map [2078].handle = objc_getClass ("NSUnitPower");
	__xamarin_class_map [2079].handle = objc_getClass ("NSUnitPressure");
	__xamarin_class_map [2080].handle = objc_getClass ("NSUnitSpeed");
	__xamarin_class_map [2081].handle = objc_getClass ("NSUnitTemperature");
	__xamarin_class_map [2082].handle = objc_getClass ("NSUnitVolume");
	__xamarin_class_map [2083].handle = objc_getClass ("NSURLAuthenticationChallenge");
	__xamarin_class_map [2084].handle = objc_getClass ("NSURLAuthenticationChallengeSender");
	__xamarin_class_map [2085].handle = objc_getClass ("NSURLComponents");
	__xamarin_class_map [2086].handle = objc_getClass ("NSURLConnectionDelegate");
	__xamarin_class_map [2087].handle = objc_getClass ("NSURLConnectionDataDelegate");
	__xamarin_class_map [2088].handle = objc_getClass ("NSURLConnectionDownloadDelegate");
	__xamarin_class_map [2089].handle = objc_getClass ("NSURLCredential");
	__xamarin_class_map [2090].handle = objc_getClass ("NSUrlDownloadDelegate");
	__xamarin_class_map [2091].handle = objc_getClass ("NSURLProtectionSpace");
	__xamarin_class_map [2092].handle = objc_getClass ("NSURLProtocol");
	__xamarin_class_map [2093].handle = objc_getClass ("NSURLQueryItem");
	__xamarin_class_map [2094].handle = objc_getClass ("NSURLSessionConfiguration");
	__xamarin_class_map [2095].handle = objc_getClass ("NSURLSessionDelegate");
	__xamarin_class_map [2096].handle = objc_getClass ("NSURLSessionTaskDelegate");
	__xamarin_class_map [2097].handle = objc_getClass ("NSURLSessionDataDelegate");
	__xamarin_class_map [2098].handle = objc_getClass ("NSURLSessionTask");
	__xamarin_class_map [2099].handle = objc_getClass ("NSURLSessionDataTask");
	__xamarin_class_map [2100].handle = objc_getClass ("NSURLSessionDownloadDelegate");
	__xamarin_class_map [2101].handle = objc_getClass ("NSURLSessionDownloadTask");
	__xamarin_class_map [2102].handle = objc_getClass ("NSURLSessionStreamDelegate");
	__xamarin_class_map [2103].handle = objc_getClass ("NSURLSessionTaskMetrics");
	__xamarin_class_map [2104].handle = objc_getClass ("NSURLSessionTaskTransactionMetrics");
	__xamarin_class_map [2105].handle = objc_getClass ("NSURLSessionUploadTask");
	__xamarin_class_map [2106].handle = objc_getClass ("NSUserActivityDelegate");
	__xamarin_class_map [2107].handle = objc_getClass ("NSUserNotification");
	__xamarin_class_map [2108].handle = objc_getClass ("NSUserNotificationAction");
	__xamarin_class_map [2109].handle = objc_getClass ("NSUserNotificationCenterDelegate");
	__xamarin_class_map [2110].handle = objc_getClass ("NSUUID");
	__xamarin_class_map [2111].handle = objc_getClass ("NSValueTransformer");
	__xamarin_class_map [2112].handle = objc_getClass ("NSXPCListenerEndpoint");
	__xamarin_class_map [2113].handle = objc_getClass ("Foundation_InternalNSNotificationHandler");
	__xamarin_class_map [2114].handle = objc_getClass ("NSProxy");
	__xamarin_class_map [2115].handle = objc_getClass ("Foundation_NSUrlProtocolClient");
	__xamarin_class_map [2116].handle = objc_getClass ("Foundation_NSDispatcher");
	__xamarin_class_map [2117].handle = objc_getClass ("__MonoMac_NSActionDispatcher");
	__xamarin_class_map [2118].handle = objc_getClass ("__MonoMac_NSSynchronizationContextDispatcher");
	__xamarin_class_map [2119].handle = objc_getClass ("__Xamarin_NSTimerActionDispatcher");
	__xamarin_class_map [2120].handle = objc_getClass ("Foundation_NSAsyncDispatcher");
	__xamarin_class_map [2121].handle = objc_getClass ("__MonoMac_NSAsyncActionDispatcher");
	__xamarin_class_map [2122].handle = objc_getClass ("__MonoMac_NSAsyncSynchronizationContextDispatcher");
	__xamarin_class_map [2123].handle = objc_getClass ("NSAutoreleasePool");
	__xamarin_class_map [2124].handle = objc_getClass ("UNUserNotificationCenter");
	__xamarin_class_map [2125].handle = objc_getClass ("WebHistoryItem");
	__xamarin_class_map [2126].handle = objc_getClass ("WebView");
	__xamarin_class_map [2127].handle = objc_getClass ("WKContentRuleListStore");
	__xamarin_class_map [2128].handle = objc_getClass ("WKHTTPCookieStore");
	__xamarin_class_map [2129].handle = objc_getClass ("WKWebsiteDataStore");
	__xamarin_class_map [2130].handle = objc_getClass ("WKWebView");
	__xamarin_class_map [2131].handle = objc_getClass ("SKProductsRequest");
	__xamarin_class_map [2132].handle = objc_getClass ("SKPhysicsWorld");
	__xamarin_class_map [2133].handle = objc_getClass ("SKTextureAtlas");
	__xamarin_class_map [2134].handle = objc_getClass ("SLRequest");
	__xamarin_class_map [2135].handle = objc_getClass ("SBApplication");
	__xamarin_class_map [2136].handle = objc_getClass ("SCNAnimationEvent");
	__xamarin_class_map [2137].handle = objc_getClass ("SCNLayer");
	__xamarin_class_map [2138].handle = objc_getClass ("SCNPhysicsWorld");
	__xamarin_class_map [2139].handle = objc_getClass ("SCNRenderer");
	__xamarin_class_map [2140].handle = objc_getClass ("SCNView");
	__xamarin_class_map [2141].handle = objc_getClass ("SFContentBlockerManager");
	__xamarin_class_map [2142].handle = objc_getClass ("SFSafariApplication");
	__xamarin_class_map [2143].handle = objc_getClass ("SFSafariExtensionHandler");
	__xamarin_class_map [2144].handle = objc_getClass ("SFSafariPage");
	__xamarin_class_map [2145].handle = objc_getClass ("SFSafariTab");
	__xamarin_class_map [2146].handle = objc_getClass ("SFSafariWindow");
	__xamarin_class_map [2147].handle = objc_getClass ("PHLivePhotoEditingContext");
	__xamarin_class_map [2148].handle = objc_getClass ("PHPhotoLibrary");
	__xamarin_class_map [2149].handle = objc_getClass ("PDFDocument");
	__xamarin_class_map [2150].handle = objc_getClass ("PDFThumbnailView");
	__xamarin_class_map [2151].handle = objc_getClass ("PDFView");
	__xamarin_class_map [2152].handle = objc_getClass ("NCWidgetListViewController");
	__xamarin_class_map [2153].handle = objc_getClass ("NCWidgetSearchViewController");
	__xamarin_class_map [2154].handle = objc_getClass ("NEAppProxyFlow");
	__xamarin_class_map [2155].handle = objc_getClass ("NEProvider");
	__xamarin_class_map [2156].handle = objc_getClass ("NETunnelProvider");
	__xamarin_class_map [2157].handle = objc_getClass ("NEAppProxyProvider");
	__xamarin_class_map [2158].handle = objc_getClass ("NEVPNManager");
	__xamarin_class_map [2159].handle = objc_getClass ("NETunnelProviderManager");
	__xamarin_class_map [2160].handle = objc_getClass ("NEAppProxyProviderManager");
	__xamarin_class_map [2161].handle = objc_getClass ("NEAppProxyTCPFlow");
	__xamarin_class_map [2162].handle = objc_getClass ("NEAppProxyUDPFlow");
	__xamarin_class_map [2163].handle = objc_getClass ("NEFilterManager");
	__xamarin_class_map [2164].handle = objc_getClass ("NEFilterProvider");
	__xamarin_class_map [2165].handle = objc_getClass ("NEPacketTunnelFlow");
	__xamarin_class_map [2166].handle = objc_getClass ("NEPacketTunnelProvider");
	__xamarin_class_map [2167].handle = objc_getClass ("NWTCPConnection");
	__xamarin_class_map [2168].handle = objc_getClass ("NWUDPSession");
	__xamarin_class_map [2169].handle = objc_getClass ("NLLanguageRecognizer");
	__xamarin_class_map [2170].handle = objc_getClass ("NLTagger");
	__xamarin_class_map [2171].handle = objc_getClass ("MCSession");
	__xamarin_class_map [2172].handle = objc_getClass ("MDLMesh");
	__xamarin_class_map [2173].handle = objc_getClass ("MPSNNGraph");
	__xamarin_class_map [2174].handle = objc_getClass ("MTKTextureLoader");
	__xamarin_class_map [2175].handle = objc_getClass ("MPSkipIntervalCommand");
	__xamarin_class_map [2176].handle = objc_getClass ("MKDirections");
	__xamarin_class_map [2177].handle = objc_getClass ("MKLocalSearch");
	__xamarin_class_map [2178].handle = objc_getClass ("MKMapSnapshotter");
	__xamarin_class_map [2179].handle = objc_getClass ("MKMapView");
	__xamarin_class_map [2180].handle = objc_getClass ("LAContext");
	__xamarin_class_map [2181].handle = objc_getClass ("INInteraction");
	__xamarin_class_map [2182].handle = objc_getClass ("IKCameraDeviceView");
	__xamarin_class_map [2183].handle = objc_getClass ("IKDeviceBrowserView");
	__xamarin_class_map [2184].handle = objc_getClass ("IKFilterBrowserPanel");
	__xamarin_class_map [2185].handle = objc_getClass ("IKImageBrowserView");
	__xamarin_class_map [2186].handle = objc_getClass ("IKSaveOptions");
	__xamarin_class_map [2187].handle = objc_getClass ("IKScannerDeviceView");
	__xamarin_class_map [2188].handle = objc_getClass ("GLKTextureLoader");
	__xamarin_class_map [2189].handle = objc_getClass ("GKAchievement");
	__xamarin_class_map [2190].handle = objc_getClass ("GKAchievementDescription");
	__xamarin_class_map [2191].handle = objc_getClass ("GKGameCenterViewController");
	__xamarin_class_map [2192].handle = objc_getClass ("GKAchievementViewController");
	__xamarin_class_map [2193].handle = objc_getClass ("GKChallengeEventHandler");
	__xamarin_class_map [2194].handle = objc_getClass ("GKFriendRequestComposeViewController");
	__xamarin_class_map [2195].handle = objc_getClass ("GKGameSession");
	__xamarin_class_map [2196].handle = objc_getClass ("GKLeaderboard");
	__xamarin_class_map [2197].handle = objc_getClass ("GKLeaderboardSet");
	__xamarin_class_map [2198].handle = objc_getClass ("GKLeaderboardViewController");
	__xamarin_class_map [2199].handle = objc_getClass ("GKPlayer");
	__xamarin_class_map [2200].handle = objc_getClass ("GKLocalPlayer");
	__xamarin_class_map [2201].handle = objc_getClass ("GKMatch");
	__xamarin_class_map [2202].handle = objc_getClass ("GKMatchmaker");
	__xamarin_class_map [2203].handle = objc_getClass ("GKMatchmakerViewController");
	__xamarin_class_map [2204].handle = objc_getClass ("GKNotificationBanner");
	__xamarin_class_map [2205].handle = objc_getClass ("GKSavedGame");
	__xamarin_class_map [2206].handle = objc_getClass ("GKScore");
	__xamarin_class_map [2207].handle = objc_getClass ("GKTurnBasedExchange");
	__xamarin_class_map [2208].handle = objc_getClass ("GKTurnBasedMatch");
	__xamarin_class_map [2209].handle = objc_getClass ("GCController");
	__xamarin_class_map [2210].handle = objc_getClass ("FIFinderSync");
	__xamarin_class_map [2211].handle = objc_getClass ("FIFinderSyncController");
	__xamarin_class_map [2212].handle = objc_getClass ("EAAccessory");
	__xamarin_class_map [2213].handle = objc_getClass ("EAAccessoryManager");
	__xamarin_class_map [2214].handle = objc_getClass ("EKEventStore");
	__xamarin_class_map [2215].handle = objc_getClass ("CWInterface");
	__xamarin_class_map [2216].handle = objc_getClass ("CSSearchableIndex");
	__xamarin_class_map [2217].handle = objc_getClass ("MLMultiArray");
	__xamarin_class_map [2218].handle = objc_getClass ("CLGeocoder");
	__xamarin_class_map [2219].handle = objc_getClass ("CLLocationManager");
	__xamarin_class_map [2220].handle = objc_getClass ("NSManagedObjectContext");
	__xamarin_class_map [2221].handle = objc_getClass ("NSPersistentContainer");
	__xamarin_class_map [2222].handle = objc_getClass ("NSPersistentStoreCoordinator");
	__xamarin_class_map [2223].handle = objc_getClass ("CBCentralManager");
	__xamarin_class_map [2224].handle = objc_getClass ("CBPeripheral");
	__xamarin_class_map [2225].handle = objc_getClass ("CBPeripheralManager");
	__xamarin_class_map [2226].handle = objc_getClass ("CNContactStore");
	__xamarin_class_map [2227].handle = objc_getClass ("CKContainer");
	__xamarin_class_map [2228].handle = objc_getClass ("CKDatabase");
	__xamarin_class_map [2229].handle = objc_getClass ("AVAssetExportSession");
	__xamarin_class_map [2230].handle = objc_getClass ("AVAssetWriter");
	__xamarin_class_map [2231].handle = objc_getClass ("AVAudioEngine");
	__xamarin_class_map [2232].handle = objc_getClass ("AVAudioPlayerNode");
	__xamarin_class_map [2233].handle = objc_getClass ("AVAudioUnitComponent");
	__xamarin_class_map [2234].handle = objc_getClass ("AVCaptureDevice");
	__xamarin_class_map [2235].handle = objc_getClass ("AVCaptureSession");
	__xamarin_class_map [2236].handle = objc_getClass ("AVCaptureStillImageOutput");
	__xamarin_class_map [2237].handle = objc_getClass ("AVCaptureVideoPreviewLayer");
	__xamarin_class_map [2238].handle = objc_getClass ("AVFragmentedMovie");
	__xamarin_class_map [2239].handle = objc_getClass ("AVFragmentedMovieTrack");
	__xamarin_class_map [2240].handle = objc_getClass ("AVMIDIPlayer");
	__xamarin_class_map [2241].handle = objc_getClass ("AVPlayerItem");
	__xamarin_class_map [2242].handle = objc_getClass ("AVPlayerItemVideoOutput");
	__xamarin_class_map [2243].handle = objc_getClass ("AVRouteDetector");
	__xamarin_class_map [2244].handle = objc_getClass ("AVSampleBufferAudioRenderer");
	__xamarin_class_map [2245].handle = objc_getClass ("AVSampleBufferDisplayLayer");
	__xamarin_class_map [2246].handle = objc_getClass ("AVSampleBufferGenerator");
	__xamarin_class_map [2247].handle = objc_getClass ("AVSampleBufferRenderSynchronizer");
	__xamarin_class_map [2248].handle = objc_getClass ("AUAudioUnit");
	__xamarin_class_map [2249].handle = objc_getClass ("NSAccessibilityElement");
	__xamarin_class_map [2250].handle = objc_getClass ("NSAlert");
	__xamarin_class_map [2251].handle = objc_getClass ("NSApplication");
	__xamarin_class_map [2252].handle = objc_getClass ("NSBrowser");
	__xamarin_class_map [2253].handle = objc_getClass ("NSGestureRecognizer");
	__xamarin_class_map [2254].handle = objc_getClass ("NSClickGestureRecognizer");
	__xamarin_class_map [2255].handle = objc_getClass ("NSColor");
	__xamarin_class_map [2256].handle = objc_getClass ("NSColorPanel");
	__xamarin_class_map [2257].handle = objc_getClass ("NSComboBox");
	__xamarin_class_map [2258].handle = objc_getClass ("NSDatePicker");
	__xamarin_class_map [2259].handle = objc_getClass ("NSDatePickerCell");
	__xamarin_class_map [2260].handle = objc_getClass ("NSDocument");
	__xamarin_class_map [2261].handle = objc_getClass ("NSDrawer");
	__xamarin_class_map [2262].handle = objc_getClass ("NSEvent");
	__xamarin_class_map [2263].handle = objc_getClass ("NSFont");
	__xamarin_class_map [2264].handle = objc_getClass ("NSGradient");
	__xamarin_class_map [2265].handle = objc_getClass ("NSHelpManager");
	__xamarin_class_map [2266].handle = objc_getClass ("NSImage");
	__xamarin_class_map [2267].handle = objc_getClass ("NSMagnificationGestureRecognizer");
	__xamarin_class_map [2268].handle = objc_getClass ("NSMenu");
	__xamarin_class_map [2269].handle = objc_getClass ("NSMenuItem");
	__xamarin_class_map [2270].handle = objc_getClass ("NSTableView");
	__xamarin_class_map [2271].handle = objc_getClass ("NSOutlineView");
	__xamarin_class_map [2272].handle = objc_getClass ("NSPageController");
	__xamarin_class_map [2273].handle = objc_getClass ("NSPanGestureRecognizer");
	__xamarin_class_map [2274].handle = objc_getClass ("NSPathCell");
	__xamarin_class_map [2275].handle = objc_getClass ("NSPopover");
	__xamarin_class_map [2276].handle = objc_getClass ("NSPopUpButton");
	__xamarin_class_map [2277].handle = objc_getClass ("NSPopUpButtonCell");
	__xamarin_class_map [2278].handle = objc_getClass ("NSPredicateEditorRowTemplate");
	__xamarin_class_map [2279].handle = objc_getClass ("NSPressGestureRecognizer");
	__xamarin_class_map [2280].handle = objc_getClass ("NSRotationGestureRecognizer");
	__xamarin_class_map [2281].handle = objc_getClass ("NSScreen");
	__xamarin_class_map [2282].handle = objc_getClass ("NSScroller");
	__xamarin_class_map [2283].handle = objc_getClass ("NSScrollView");
	__xamarin_class_map [2284].handle = objc_getClass ("NSSearchField");
	__xamarin_class_map [2285].handle = objc_getClass ("NSSharingService");
	__xamarin_class_map [2286].handle = objc_getClass ("NSSharingServicePicker");
	__xamarin_class_map [2287].handle = objc_getClass ("NSSliderAccessory");
	__xamarin_class_map [2288].handle = objc_getClass ("NSSound");
	__xamarin_class_map [2289].handle = objc_getClass ("NSSpellChecker");
	__xamarin_class_map [2290].handle = objc_getClass ("NSSplitView");
	__xamarin_class_map [2291].handle = objc_getClass ("NSTabView");
	__xamarin_class_map [2292].handle = objc_getClass ("NSText");
	__xamarin_class_map [2293].handle = objc_getClass ("NSTextAlternatives");
	__xamarin_class_map [2294].handle = objc_getClass ("NSTextInputContext");
	__xamarin_class_map [2295].handle = objc_getClass ("NSTextStorage");
	__xamarin_class_map [2296].handle = objc_getClass ("NSTextView");
	__xamarin_class_map [2297].handle = objc_getClass ("NSToolbar");
	__xamarin_class_map [2298].handle = objc_getClass ("NSTouchBar");
	__xamarin_class_map [2299].handle = objc_getClass ("NSWorkspace");
	__xamarin_class_map [2300].handle = objc_getClass ("ACAccountStore");
	__xamarin_class_map [2301].handle = objc_getClass ("NSCache");
	__xamarin_class_map [2302].handle = objc_getClass ("NSCalendar");
	__xamarin_class_map [2303].handle = objc_getClass ("NSDictionary");
	__xamarin_class_map [2304].handle = objc_getClass ("NSFileHandle");
	__xamarin_class_map [2305].handle = objc_getClass ("NSFileManager");
	__xamarin_class_map [2306].handle = objc_getClass ("NSFileVersion");
	__xamarin_class_map [2307].handle = objc_getClass ("NSHost");
	__xamarin_class_map [2308].handle = objc_getClass ("NSHTTPCookieStorage");
	__xamarin_class_map [2309].handle = objc_getClass ("NSIndexPath");
	__xamarin_class_map [2310].handle = objc_getClass ("NSItemProvider");
	__xamarin_class_map [2311].handle = objc_getClass ("NSKeyedArchiver");
	__xamarin_class_map [2312].handle = objc_getClass ("NSKeyedUnarchiver");
	__xamarin_class_map [2313].handle = objc_getClass ("NSLocale");
	__xamarin_class_map [2314].handle = objc_getClass ("NSMetadataQuery");
	__xamarin_class_map [2315].handle = objc_getClass ("NSMutableDictionary");
	__xamarin_class_map [2316].handle = objc_getClass ("NSNetService");
	__xamarin_class_map [2317].handle = objc_getClass ("NSNetServiceBrowser");
	__xamarin_class_map [2318].handle = objc_getClass ("NSProcessInfo");
	__xamarin_class_map [2319].handle = objc_getClass ("NSProgress");
	__xamarin_class_map [2320].handle = objc_getClass ("NSSecureUnarchiveFromDataTransformer");
	__xamarin_class_map [2321].handle = objc_getClass ("NSTask");
	__xamarin_class_map [2322].handle = objc_getClass ("NSThread");
	__xamarin_class_map [2323].handle = objc_getClass ("NSUbiquitousKeyValueStore");
	__xamarin_class_map [2324].handle = objc_getClass ("NSUndoManager");
	__xamarin_class_map [2325].handle = objc_getClass ("NSURL");
	__xamarin_class_map [2326].handle = objc_getClass ("NSURLCache");
	__xamarin_class_map [2327].handle = objc_getClass ("NSURLConnection");
	__xamarin_class_map [2328].handle = objc_getClass ("NSURLCredentialStorage");
	__xamarin_class_map [2329].handle = objc_getClass ("NSURLSession");
	__xamarin_class_map [2330].handle = objc_getClass ("NSURLSessionStreamTask");
	__xamarin_class_map [2331].handle = objc_getClass ("NSUserActivity");
	__xamarin_class_map [2332].handle = objc_getClass ("NSUserDefaults");
	__xamarin_class_map [2333].handle = objc_getClass ("NSUserNotificationCenter");
	__xamarin_class_map [2334].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy");
	__xamarin_class_map [2335].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy2");
	__xamarin_class_map [2336].handle = objc_getClass ("WebKit_WebView__WebFrameLoadDelegate");
	__xamarin_class_map [2337].handle = objc_getClass ("WebKit_WebView__WebDownloadDelegate");
	__xamarin_class_map [2338].handle = objc_getClass ("WebKit_WebView__WebResourceLoadDelegate");
	__xamarin_class_map [2339].handle = objc_getClass ("WebKit_WebView__WebUIDelegate");
	__xamarin_class_map [2340].handle = objc_getClass ("WebKit_WebView__WebPolicyDelegate");
	__xamarin_class_map [2341].handle = objc_getClass ("StoreKit_SKRequest__SKRequestDelegate");
	__xamarin_class_map [2342].handle = objc_getClass ("StoreKit_SKProductsRequest__SKProductsRequestDelegate");
	__xamarin_class_map [2343].handle = objc_getClass ("SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate");
	__xamarin_class_map [2344].handle = objc_getClass ("ScriptingBridge_SBApplication__SBApplicationDelegate");
	__xamarin_class_map [2345].handle = objc_getClass ("SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate");
	__xamarin_class_map [2346].handle = objc_getClass ("PdfKit_PdfDocument__PdfDocumentDelegate");
	__xamarin_class_map [2347].handle = objc_getClass ("PdfKit_PdfView__PdfViewDelegate");
	__xamarin_class_map [2348].handle = objc_getClass ("NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate");
	__xamarin_class_map [2349].handle = objc_getClass ("NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate");
	__xamarin_class_map [2350].handle = objc_getClass ("MapKit_MKMapView__MKMapViewDelegate");
	__xamarin_class_map [2351].handle = objc_getClass ("ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate");
	__xamarin_class_map [2352].handle = objc_getClass ("ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate");
	__xamarin_class_map [2353].handle = objc_getClass ("ImageKit_IKImageBrowserView__IKImageBrowserDelegate");
	__xamarin_class_map [2354].handle = objc_getClass ("ImageKit_IKSaveOptions__IKSaveOptionsDelegate");
	__xamarin_class_map [2355].handle = objc_getClass ("ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate");
	__xamarin_class_map [2356].handle = objc_getClass ("GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate");
	__xamarin_class_map [2357].handle = objc_getClass ("GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate");
	__xamarin_class_map [2358].handle = objc_getClass ("GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate");
	__xamarin_class_map [2359].handle = objc_getClass ("GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [2360].handle = objc_getClass ("GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [2361].handle = objc_getClass ("GameKit_GKMatch__GKMatchDelegate");
	__xamarin_class_map [2362].handle = objc_getClass ("GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [2363].handle = objc_getClass ("ExternalAccessory_EAAccessory__EAAccessoryDelegate");
	__xamarin_class_map [2364].handle = objc_getClass ("CoreLocation_CLLocationManager__CLLocationManagerDelegate");
	__xamarin_class_map [2365].handle = objc_getClass ("CoreBluetooth_CBCentralManager__CBCentralManagerDelegate");
	__xamarin_class_map [2366].handle = objc_getClass ("CoreBluetooth_CBPeripheral__CBPeripheralDelegate");
	__xamarin_class_map [2367].handle = objc_getClass ("CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate");
	__xamarin_class_map [2368].handle = objc_getClass ("CoreAnimation_CAAnimation__CAAnimationDelegate");
	__xamarin_class_map [2369].handle = objc_getClass ("AVFoundation_AVCaptureFileOutput_recordingProxy");
	__xamarin_class_map [2370].handle = objc_getClass ("AppKit_NSAlert__NSAlertDelegate");
	__xamarin_class_map [2371].handle = objc_getClass ("AppKit_NSAnimation__NSAnimationDelegate");
	__xamarin_class_map [2372].handle = objc_getClass ("AppKit_NSApplication__NSApplicationDelegate");
	__xamarin_class_map [2373].handle = objc_getClass ("__NSGestureRecognizerToken");
	__xamarin_class_map [2374].handle = objc_getClass ("__NSClickGestureRecognizer");
	__xamarin_class_map [2375].handle = objc_getClass ("AppKit_NSTextField__NSTextFieldDelegate");
	__xamarin_class_map [2376].handle = objc_getClass ("AppKit_NSComboBox__NSComboBoxDelegate");
	__xamarin_class_map [2377].handle = objc_getClass ("AppKit_NSDatePicker__NSDatePickerCellDelegate");
	__xamarin_class_map [2378].handle = objc_getClass ("AppKit_NSDatePickerCell__NSDatePickerCellDelegate");
	__xamarin_class_map [2379].handle = objc_getClass ("__NSDocumentDuplicateCallback");
	__xamarin_class_map [2380].handle = objc_getClass ("AppKit_NSDrawer__NSDrawerDelegate");
	__xamarin_class_map [2381].handle = objc_getClass ("AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate");
	__xamarin_class_map [2382].handle = objc_getClass ("__NSGestureRecognizerParameterlessToken");
	__xamarin_class_map [2383].handle = objc_getClass ("__NSGestureRecognizerParametrizedToken");
	__xamarin_class_map [2384].handle = objc_getClass ("AppKit_NSImage__NSImageDelegate");
	__xamarin_class_map [2385].handle = objc_getClass ("__NSMagnificationGestureRecognizer");
	__xamarin_class_map [2386].handle = objc_getClass ("AppKit_NSMatrix__NSMatrixDelegate");
	__xamarin_class_map [2387].handle = objc_getClass ("AppKit_NSPageController__NSPageControllerDelegate");
	__xamarin_class_map [2388].handle = objc_getClass ("__NSPanGestureRecognizer");
	__xamarin_class_map [2389].handle = objc_getClass ("AppKit_NSPathCell__NSPathCellDelegate");
	__xamarin_class_map [2390].handle = objc_getClass ("__NSPressGestureRecognizer");
	__xamarin_class_map [2391].handle = objc_getClass ("__NSRotationGestureRecognizer");
	__xamarin_class_map [2392].handle = objc_getClass ("AppKit_NSRuleEditor__NSRuleEditorDelegate");
	__xamarin_class_map [2393].handle = objc_getClass ("AppKit_NSSavePanel__NSOpenSavePanelDelegate");
	__xamarin_class_map [2394].handle = objc_getClass ("AppKit_NSSearchField__NSSearchFieldDelegate");
	__xamarin_class_map [2395].handle = objc_getClass ("AppKit_NSSharingService__NSSharingServiceDelegate");
	__xamarin_class_map [2396].handle = objc_getClass ("AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate");
	__xamarin_class_map [2397].handle = objc_getClass ("AppKit_NSSound__NSSoundDelegate");
	__xamarin_class_map [2398].handle = objc_getClass ("AppKit_NSTableView__NSTableViewDelegate");
	__xamarin_class_map [2399].handle = objc_getClass ("AppKit_NSTabView__NSTabViewDelegate");
	__xamarin_class_map [2400].handle = objc_getClass ("AppKit_NSText__NSTextDelegate");
	__xamarin_class_map [2401].handle = objc_getClass ("AppKit_NSTextStorage__NSTextStorageDelegate");
	__xamarin_class_map [2402].handle = objc_getClass ("AppKit_NSTextView__NSTextViewDelegate");
	__xamarin_class_map [2403].handle = objc_getClass ("AppKit_NSToolbar__NSToolbarDelegate");
	__xamarin_class_map [2404].handle = objc_getClass ("AppKit_NSTouchBar__NSTouchBarDelegate");
	__xamarin_class_map [2405].handle = objc_getClass ("AppKit_NSWindow__NSWindowDelegate");
	__xamarin_class_map [2406].handle = objc_getClass ("Foundation_NSUrlSessionHandler_WrappedNSInputStream");
	__xamarin_class_map [2407].handle = objc_getClass ("Foundation_NSCache__NSCacheDelegate");
	__xamarin_class_map [2408].handle = objc_getClass ("Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate");
	__xamarin_class_map [2409].handle = objc_getClass ("Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2410].handle = objc_getClass ("Foundation_NSMetadataQuery__NSMetadataQueryDelegate");
	__xamarin_class_map [2411].handle = objc_getClass ("Foundation_NSNetService__NSNetServiceDelegate");
	__xamarin_class_map [2412].handle = objc_getClass ("Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate");
	__xamarin_class_map [2413].handle = objc_getClass ("__NSObject_Disposer");
	__xamarin_class_map [2414].handle = objc_getClass ("__XamarinObjectObserver");
	__xamarin_class_map [2415].handle = objc_getClass ("Foundation_NSStream__NSStreamDelegate");
	__xamarin_class_map [2416].handle = objc_getClass ("Foundation_NSThread_ActionThread");
	__xamarin_class_map [2417].handle = objc_getClass ("Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate");
	__xamarin_class_map [2418].handle = objc_getClass ("Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate");
	__xamarin_class_map [2419].handle = [AppDelegate class];
	__xamarin_class_map [2420].handle = [ViewController class];
	__xamarin_class_map [2421].handle = [PeekPoke_ScanTableDataSource class];
	__xamarin_class_map [2422].handle = [PeekPoke_ProductTableDelegate class];
	__xamarin_class_map [2423].handle = [PeekPoke_OutputTableDataSource class];
	__xamarin_class_map [2424].handle = [PeekPoke_OutputTableDelegate class];
	__xamarin_class_map [2425].handle = [PeekPoke_PTTableDataSource class];
	__xamarin_class_map [2426].handle = [PeekPoke_PTTableDelegate class];
	xamarin_add_registration_map (&__xamarin_registration_map);
}


} /* extern "C" */
